<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KOMPOSER - Let AI do the prompting for you | BFL Kontext</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #ffffff;
            overflow: hidden;
            height: 100vh;
            color: #1d1d1f;
            font-size: 17px;
            line-height: 1.47;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-weight: 400;
        }

        /* Musical Animations */
        @keyframes audioWave {
            0%, 100% { transform: scaleY(1); }
            25% { transform: scaleY(1.2); }
            50% { transform: scaleY(0.8); }
            75% { transform: scaleY(1.4); }
        }

        @keyframes gentlePulse {
            0%, 100% { border-color: #a8b5a0; }
            50% { border-color: #8fa085; }
        }

        .generating {
            animation: gentlePulse 2s ease-in-out infinite;
        }

        /* Loading animations */
        @keyframes uploadPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        
        .regenerate-button {
            background: #5A7A70;
            color: #FFFFFF;
            border: 1px solid #B8C5C0;
            padding: 8px 16px;
            border-radius: 2px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-family: inherit;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .regenerate-button:hover {
            background: #B8C5C0;
            color: #1C2A23;
        }
        
        .regenerate-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Empty State Styles */
        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 400px;
            padding: 40px;
            grid-column: 1 / -1;
        }
        
        .empty-state-content {
            text-align: center;
            max-width: 480px;
        }
        
        .empty-state-icon {
            margin-bottom: 24px;
            opacity: 0.7;
        }
        
        .empty-state-title {
            font-size: 28px;
            font-weight: 700;
            color: #1C2A23;
            margin: 0 0 16px 0;
            letter-spacing: -0.02em;
        }
        
        .empty-state-description {
            font-size: 16px;
            color: #5A7A70;
            line-height: 1.6;
            margin: 0 0 32px 0;
        }
        
        .empty-state-steps {
            display: flex;
            flex-direction: row;
            gap: 16px;
            margin-bottom: 32px;
            justify-content: center;
        }
        
        .step {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 12px 20px;
            background: #FFFFFF;
            border: 1px solid #B8C5C0;
            border-radius: 8px;
            flex: 1;
        }
        
        /* Mobile empty state */
        @media (max-width: 768px) {
            .empty-state {
                min-height: 300px;
                padding: 20px;
            }
            
            .empty-state-content {
                max-width: 100%;
            }
            
            .empty-state-title {
                font-size: 24px;
                margin-bottom: 12px;
            }
            
            .empty-state-description {
                font-size: 14px;
                margin-bottom: 24px;
            }
            
            .empty-state-steps {
                flex-direction: column;
                gap: 12px;
                margin-bottom: 24px;
            }
            
            .step {
                padding: 12px 16px;
                gap: 12px;
            }
            
            .step-text {
                font-size: 13px;
            }
            
            .cta-button {
                padding: 14px 28px;
                font-size: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .empty-state-title {
                font-size: 20px;
            }
            
            .empty-state-description {
                font-size: 13px;
            }
            
            .step {
                padding: 10px 14px;
            }
            
            .step-text {
                font-size: 12px;
            }
        }
        
        .step-number {
            width: 28px;
            height: 28px;
            background: #5A7A70;
            color: #FFFFFF;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .step-text {
            font-size: 14px;
            color: #1C2A23;
            font-weight: 500;
        }
        
        .cta-button {
            background: #5A7A70;
            color: #FFFFFF;
            border: none;
            padding: 16px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .cta-button:hover {
            background: #4A6A60;
            transform: translateY(-1px);
        }
        
        .cta-button:active {
            transform: translateY(0);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-loading {
            animation: uploadPulse 1.5s ease-in-out infinite;
            position: relative;
        }

        .upload-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid #a8b5a0;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .upload-success {
            position: relative;
        }

        .upload-success::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: #a8b5a0;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        /* BRANCH button overlay - positioned relative to image bounds */
        .element-content {
            position: relative !important;
        }
        
        .use-as-input-icon {
            position: absolute !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            width: 100% !important;
            height: 10% !important;
            min-height: 32px !important;
            max-height: 50px !important;
            background: rgba(0, 0, 0, 0.85) !important;
            color: white !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            letter-spacing: 0.5px !important;
            transition: all 0.2s ease !important;
            opacity: 1 !important;
            z-index: 50 !important;
            border-radius: 0 !important;
            backdrop-filter: blur(8px) !important;
            pointer-events: auto !important;
            visibility: visible !important;
            clip: none !important;
            overflow: visible !important;
            border: none !important;
            border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
            margin: 0 !important;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.15) !important;
            transform: none !important;
        }

        .use-as-input-icon:hover {
            background: rgba(168, 181, 160, 0.9) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.25) !important;
        }

        .use-as-input-icon:active {
            transform: translateY(0) !important;
            background: rgba(168, 181, 160, 1) !important;
        }

        .use-as-input-icon::before {
            content: '';
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='18' r='3'/%3E%3Ccircle cx='6' cy='6' r='3'/%3E%3Ccircle cx='18' cy='6' r='3'/%3E%3Cpath d='m18 9-4 9-4-9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: 16px 16px;
            width: 16px;
            height: 16px;
            margin-right: 8px;
            display: inline-block;
        }
        
        .use-as-input-icon::after {
            content: 'BRANCH FROM HERE';
            font-size: 14px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* Firefox-specific fixes for REMIX button visibility */
        @-moz-document url-prefix() {
            .use-as-input-icon {
                position: absolute !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                height: 10% !important;
                min-height: 32px !important;
                max-height: 50px !important;
                transform: none !important;
                z-index: 50 !important;
                will-change: transform !important;
                isolation: isolate !important;
            }
            
        }
        
        /* Force button visibility animation */
        @keyframes forceVisible {
            0%, 100% { 
                opacity: 1 !important; 
                visibility: visible !important; 
                display: flex !important;
                z-index: 9999 !important;
            }
        }
        
        .use-as-input-icon {
            animation: forceVisible 0.1s ease-in-out 1s both !important;
        }

        /* Skeleton loading states */
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }

        .skeleton-tile {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200px 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .skeleton-tile::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #d0d0d0;
            border-top: 2px solid #a8b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .empty-grid-tile {
            background: #fafafa;
            border: 1px dashed #e0e0e0;
            border-radius: 4px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c0c0c0;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            position: relative;
        }

        /* Loading spinner for image cards */
        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #f0f0f0;
            border-top: 3px solid #a8b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px auto;
        }

        .status-text {
            color: #8e8e93;
            font-size: 13px;
            text-align: center;
            margin: 0;
        }

        .image-card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        /* Seed History CSS removed - now handled by bottom editing chain */


        /* Tufte-inspired Iteration Sequence Modal */
        .comic-strip-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .comic-strip-modal.show {
            opacity: 1;
        }

        .comic-strip-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 40px;
            box-sizing: border-box;
        }

        .comic-strip-header {
            text-align: center;
            margin-bottom: 48px;
            max-width: 600px;
        }

        .comic-strip-header h2 {
            font-size: 24px;
            font-weight: 400;
            margin: 0 0 8px 0;
            color: #2d2d2d;
            letter-spacing: -0.02em;
        }

        .comic-strip-header p {
            font-size: 16px;
            color: #666;
            margin: 0;
            font-weight: 300;
            line-height: 1.4;
        }

        .comic-strip-header p a {
            color: #007AFF;
            text-decoration: none;
        }

        .comic-strip-header p a:hover {
            text-decoration: underline;
        }

        .comic-strip-sequence {
            display: flex;
            gap: 8px;
            max-width: 95vw;
            overflow-x: auto;
            padding: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            margin-bottom: 48px;
            border: none;
        }

        .comic-panel {
            flex-shrink: 0;
            width: 320px;
            background: white;
            border-radius: 0;
            overflow: hidden;
            border: none;
            box-shadow: none;
            position: relative;
        }

        .comic-panel:first-child::before,
        .comic-panel:last-child::after {
            display: none;
        }

        .comic-panel-header {
            display: none;
        }

        .comic-panel-number {
            display: none;
        }

        .comic-panel-image {
            width: 100%;
            height: auto;
            max-height: 600px;
            object-fit: contain;
            display: block;
            background: #f5f5f5;
        }

        .comic-panel-title {
            display: none;
        }

        .comic-strip-controls {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .comic-control-btn {
            background: transparent;
            color: #333;
            border: 1px solid #ddd;
            padding: 12px 24px;
            border-radius: 0;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.02em;
        }

        .comic-control-btn:hover {
            background: #f5f5f5;
            border-color: #999;
            transform: none;
        }

        .comic-control-btn.secondary {
            background: transparent;
            border-color: #ccc;
            color: #666;
        }

        .comic-control-btn.secondary:hover {
            background: #f9f9f9;
            border-color: #999;
            color: #333;
        }

        .comic-close-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
            font-size: 16px;
            width: 32px;
            height: 32px;
            border-radius: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .comic-close-btn:hover {
            background: #f5f5f5;
            border-color: #999;
            color: #333;
        }

        /* Minimal responsive adjustments */
        @media (max-width: 768px) {
            .comic-strip-content {
                padding: 40px 20px;
            }
            
            .comic-strip-sequence {
                gap: 0;
            }
            
            .comic-panel {
                width: 280px;
            }
            
            .comic-panel-image {
                max-height: 400px;
            }
            
            .comic-strip-header h2 {
                font-size: 20px;
            }
        }

        .whiteboard-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: auto;
            cursor: default;
        }


        .canvas-surface {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #FFFFFF;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr auto;
            grid-template-areas: 
                "main"
                "editing-chain";
            gap: 0;
            padding: 0;
        }
        
        /* Hide left sidebar */
        .left-section {
            display: none;
        }
        
        /* Tablet layout */
        @media (max-width: 1024px) {
            .canvas-surface {
                grid-template-rows: 1fr auto;
            }
            
            .generations-section {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
                gap: 8px;
                padding: 12px;
            }
        }
        
        /* Mobile layout adjustments */
        @media (max-width: 768px) {
            .canvas-surface {
                grid-template-rows: 1fr auto;
                height: auto;
                min-height: 100vh;
            }
            
            .left-section {
                width: 100vw;
                left: -100vw;
                height: 70vh;
                padding: 16px;
            }
            
            /* Start closed on mobile */
            .left-section {
                left: -100vw;
            }
            
            .left-section:not(.closed) {
                left: 0;
            }
            
            /* Toggle button positioning on mobile */
            .sidebar-toggle {
                left: 20px; /* Always left on mobile */
            }
            
            .generations-section {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 12px;
                padding: 16px;
            }
            
            .editing-chain-section {
                padding: 12px;
            }
            
            .chain-image {
                width: 80px;
                height: auto;
                max-height: 120px;
            }
            
            .image-card {
                min-height: 300px;
            }
        }

        .left-section {
            display: none;
        }

        /* Main Section - Full screen images */
        .right-section-container {
            grid-area: main;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }
        
        .sidebar-toggle {
            display: none;
        }

        /* Generations Grid - Now takes full right area */
        .generations-section {
            flex: 1;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            grid-auto-rows: max-content;
            gap: 4px;
            align-content: start;
            overflow-y: auto;
        }
        
        /* Responsive image grid */
        @media (max-width: 1200px) {
            .generations-section {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 6px;
            }
        }
        
        @media (max-width: 768px) {
            .generations-section {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 8px;
                padding: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .generations-section {
                grid-template-columns: 1fr;
                gap: 12px;
                padding: 16px;
            }
        }

        /* Bottom Editing Workspace - Professional Tool Style */
        .editing-chain-section {
            grid-area: editing-chain;
            height: 100%;
            background: linear-gradient(135deg, #F8FAFB 0%, #F1F5F4 100%);
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            border-top: 3px solid #5A7A70;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.08);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            transition: all 0.3s ease;
        }
        
        .editing-chain-section.collapsed {
            padding: 12px 20px;
            background: linear-gradient(135deg, #FAFBFC 0%, #F3F6F5 100%);
        }
        
        .editing-chain-section.collapsed .editing-chain-header {
            margin-bottom: 0;
        }
        
        .editing-chain-section.collapsed h3 {
            font-size: 16px;
            color: #4A5568;
            transition: color 0.2s ease;
            font-weight: 600;
        }
        
        .editing-chain-section.collapsed .editing-chain-header:hover h3 {
            color: #2D3748;
        }
        
        /* Interactive resize handle */
        .resize-handle {
            position: absolute;
            top: -3px;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(to bottom, #5A7A70, #4A6A60);
            cursor: ns-resize;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .resize-handle::before {
            content: '';
            width: 40px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 2px;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.1);
        }
        
        .resize-handle:hover {
            background: #B8C5C0;
        }
        
        .resize-handle::after {
            content: '⋯';
            width: 40px;
            height: 6px;
            background: transparent;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #ccc;
            line-height: 1;
            letter-spacing: 2px;
        }
        
        .resize-handle:hover::after {
            color: #a8b5a0;
            background: rgba(168, 181, 160, 0.1);
            width: 60px;
        }
        
        .resize-handle.dragging {
            background: rgba(168, 181, 160, 0.3);
        }
        
        .resize-handle.dragging::after {
            color: #a8b5a0;
            background: rgba(168, 181, 160, 0.2);
            width: 80px;
        }

        .editing-chain-header {
            margin-bottom: 16px;
            cursor: pointer;
            user-select: none;
            padding: 12px 16px;
            background: rgba(90, 122, 112, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(90, 122, 112, 0.1);
            transition: all 0.2s ease;
        }
        
        .editing-chain-header:hover {
            background: rgba(90, 122, 112, 0.08);
            border-color: rgba(90, 122, 112, 0.2);
        }
        
        .editing-chain-header:hover h3 {
            color: #2D3748;
        }
        
        .collapse-indicator {
            color: #5A7A70;
            font-size: 16px;
            transition: all 0.3s ease;
            margin-left: 12px;
            font-weight: 500;
            display: inline-block;
        }
        
        .collapse-indicator:hover {
            color: #2D3748;
            transform: scale(1.1);
        }
        
        .editing-chain-section.collapsed .collapse-indicator {
            transform: rotate(180deg);
        }
        
        .chain-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .editing-chain-header h3 {
            font-size: 18px;
            font-weight: 600;
            color: #1A202C;
            margin: 0;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        
        .header-controls {
            display: flex;
            gap: 8px;
        }
        
        .export-sequence-btn, .upload-btn, .reset-btn {
            background: #FFFFFF;
            color: #1A202C;
            border: 1px solid #E2E8F0;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .export-sequence-btn:hover, .upload-btn:hover, .reset-btn:hover {
            background: #5A7A70;
            color: #FFFFFF;
            border-color: #5A7A70;
            box-shadow: 0 2px 6px rgba(90, 122, 112, 0.2);
        }
        
        .export-sequence-btn:active, .upload-btn:active, .reset-btn:active {
            background: #4A6A60;
            color: #FFFFFF;
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .editing-chain-header .subtitle {
            font-size: 12px;
            color: #68767D;
            margin: 0;
            font-weight: 400;
            letter-spacing: 0.02em;
            font-family: inherit;
        }

        .editing-chain-header .subtitle a {
            color: #5A7A70;
            text-decoration: underline;
        }

        .editing-chain-header .subtitle a:hover {
            color: #2D3748;
        }

        .workflow-row {
            display: flex;
            gap: 16px;
            align-items: stretch;
            margin-bottom: 16px;
        }
        
        .upload-container-inline {
            flex: 0 0 300px;
            border: 1px solid #5A7A70;
            border-radius: 2px;
            padding: 0;
        }
        
        .upload-zone-inline {
            background: #B8C5C0;
            border: 2px dashed #5A7A70;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .upload-zone-inline:hover {
            background: #A5B2AE;
            border-color: #4A6A60;
        }
        
        .upload-text {
            color: #1C2A23;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .num-images-container {
            flex: 0 0 120px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .num-images-label {
            font-size: 9px;
            color: #B8C5C0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-family: inherit;
            margin-bottom: 4px;
        }
        
        .num-images-input {
            background: #1C2A23;
            border: 1px solid #5A7A70;
            border-radius: 2px;
            color: #FFFFFF;
            font-size: 14px;
            font-weight: 600;
            padding: 8px;
            text-align: center;
            font-family: inherit;
            outline: none;
        }
        
        .num-images-input:focus {
            border-color: #B8C5C0;
        }
        
        .num-images-input::-webkit-outer-spin-button,
        .num-images-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .num-images-input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }
        
        .upload-zone-inline {
            padding: 12px;
            text-align: center;
            background: transparent;
            cursor: pointer;
            transition: background 0.1s ease;
            border: 1px dashed #5A7A70;
            border-radius: 2px;
        }
        
        .upload-zone-inline:hover {
            background: rgba(90, 122, 112, 0.1);
        }
        
        .upload-text {
            font-size: 10px;
            color: #B8C5C0;
            font-weight: 400;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-family: inherit;
        }

        .editing-chain-sequence {
            flex: 1;
            display: flex;
            gap: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: center;
            padding: 16px 0;
            min-height: 80px;
            transition: all 0.3s ease;
        }
        
        .editing-chain-section.collapsed .editing-chain-sequence,
        .editing-chain-section.collapsed .workflow-row {
            display: none;
        }

        .chain-placeholder {
            width: 100%;
            text-align: center;
            color: #5A7A70;
            font-size: 10px;
            font-style: normal;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-family: inherit;
        }

        .chain-image {
            flex-shrink: 0;
            width: 120px;
            height: auto;
            max-height: 200px;
            border-radius: 2px;
            overflow: visible;
            position: relative;
            border: 1px solid #5A7A70;
            background: #B8C5C0;
        }

        .chain-image img {
            width: 100%;
            height: auto;
            object-fit: contain;
            display: block;
        }

        .chain-image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.8) 100%);
            color: white;
            font-size: 10px;
            font-weight: 500;
            padding: 4px 6px;
            text-align: center;
        }

        .chain-arrow {
            flex-shrink: 0;
            color: #999;
            font-size: 16px;
            font-weight: bold;
        }
        

        /* Individual Image Card - Maximum Image Space */
        .image-card {
            background: #ffffff;
            display: block;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            overflow: hidden;
            width: 100%;
            height: auto;
            box-sizing: border-box;
            border: none;
        }
        
        .image-card:hover {
            transform: scale(1.01);
            z-index: 10;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.05);
        }
        
        
        .image-card-header {
            display: none;
        }
        
        .image-card-content {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            position: relative;
        }
        
        .image-card img {
            width: 100%;
            height: auto;
            object-fit: none;
            cursor: pointer;
            border-radius: 0;
            display: block;
        }
        
        /* Mobile koncept labels */
        @media (max-width: 768px) {
            .koncept-label {
                padding: 12px 8px;
                font-size: 8px;
            }
            
            .koncept-label:hover {
                transform: none;
                box-shadow: 2px 2px 0px #fff;
            }
        }
        
        /* Editable koncept input */
        .koncept-input {
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: center;
            width: 100%;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .koncept-input::placeholder {
            color: #666;
            opacity: 0.7;
        }
        

        /* Upload Area Styling */
        .upload-container {
            margin-bottom: 12px;
        }

        .upload-preview {
            margin-bottom: 20px;
        }

        .canvas-element.dragging {
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        /* Mobile canvas elements */
        @media (max-width: 768px) {
            .canvas-element {
                box-shadow: 2px 2px 0px #fff;
                border-width: 2px;
            }
            
            .canvas-element:hover {
                box-shadow: 2px 2px 0px #fff;
                transform: none;
            }
        }

        /* Left Section Items */
        .title-container {
            grid-area: 1;
        }
        
        .upload-container {
            grid-area: 2;
        }
        
        .caption-container {
            grid-area: 3;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Title Box */
        .title-box {
            width: 100%;
            height: auto;
        }

        .title-text {
            font-size: 28px;
            line-height: 1.1;
            color: #1c1c1e;
            padding: 0;
            font-weight: 800;
            text-align: left;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .subtitle-text {
            font-size: 16px;
            line-height: 1.3;
            color: #666;
            padding: 0;
            font-weight: 400;
            text-align: left;
            margin-bottom: 12px;
            display: block;
            width: 100%;
        }
        
        
        .attribution {
            font-size: 13px;
            line-height: 1.4;
            color: #888;
            padding: 8px 0 0 0;
            font-weight: 400;
            text-align: left;
            margin-top: auto;
            display: block;
            width: 100%;
        }
        
        .attribution a {
            color: #007AFF;
            text-decoration: none;
            font-weight: 500;
        }
        
        .attribution a:hover {
            text-decoration: underline;
        }
        
        /* Mobile title and subtitle */
        @media (max-width: 768px) {
            .title-text {
                font-size: 20px;
                padding: 12px;
                letter-spacing: -0.01em;
            }
            
            .subtitle-text {
                font-size: 12px;
                padding: 0 12px 8px 12px;
            }
            
            .value-prop {
                font-size: 10px;
                padding: 0 12px 6px 12px;
            }
            
            .attribution {
                font-size: 10px;
                padding: 0 12px 12px 12px;
            }
        }

        /* Add Koncept Button and Input */
        .add-koncept-btn {
            width: 100%;
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #e5e5e7;
            border-radius: 8px;
            padding: 16px 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-family: inherit;
        }

        .add-koncept-btn:hover {
            background: #a8b5a0;
            color: #ffffff;
            border-color: #a8b5a0;
            transform: none;
            box-shadow: none;
        }

        .custom-koncept-input {
            width: 100%;
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #e5e5e7;
            border-radius: 8px;
            padding: 16px 20px;
            font-size: 14px;
            font-weight: 400;
            font-family: inherit;
            margin-top: 12px;
            outline: none;
            transition: all 0.1s ease;
        }

        .custom-koncept-input::placeholder {
            color: #aeaeb2;
        }

        .custom-koncept-input:focus {
            background: #ffffff;
            border-color: #a8b5a0;
            box-shadow: 0 0 0 2px rgba(168, 181, 160, 0.2);
        }

        .generate-custom-btn {
            width: 100%;
            background: #2d2d2d;
            color: #ffffff;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 14px 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: inherit;
            box-shadow: none;
        }

        .generate-custom-btn:hover {
            background: #1a1a1a;
            border-color: #505050;
            transform: none;
            box-shadow: none;
        }

        .generate-custom-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .generate-custom-btn:disabled:hover {
            background: #2d2d2d;
            border-color: #404040;
            transform: none;
            box-shadow: none;
        }

        /* Empty State Row for Add Custom Koncept */
        .add-koncept-row {
            display: contents;
        }

        .add-koncept-label {
            background: #f8f8f8;
            color: #8e8e93;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 10px;
            font-weight: 500;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            align-items: center;
            word-break: break-word;
            cursor: pointer;
            transition: all 0.15s ease;
            grid-column: 1 / -1; /* Span all columns like koncept headers */
            min-height: 48px;
        }

        .add-koncept-label:hover {
            background: #a8b5a0;
            color: #ffffff;
            transform: none;
            box-shadow: none;
        }

        .add-koncept-empty-box {
            background: #fafafa;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999999;
            font-size: 11px;
            font-weight: 400;
            text-align: center;
            height: 100%;
            min-height: 450px;
        }

        /* Right Section - Generation Results (header spans all columns, images below) */
        .grid-koncept-label-0 { grid-column: 1 / -1; grid-row: 1; }
        .grid-result-0-0 { grid-column: 1; grid-row: 2; }
        .grid-result-0-1 { grid-column: 2; grid-row: 2; }
        .grid-result-0-2 { grid-column: 3; grid-row: 2; }
        .grid-result-0-3 { grid-column: 4; grid-row: 2; }
        
        .grid-koncept-label-1 { grid-column: 1 / -1; grid-row: 3; }
        .grid-result-1-0 { grid-column: 1; grid-row: 4; }
        .grid-result-1-1 { grid-column: 2; grid-row: 4; }
        .grid-result-1-2 { grid-column: 3; grid-row: 4; }
        .grid-result-1-3 { grid-column: 4; grid-row: 4; }
        
        .grid-koncept-label-2 { grid-column: 1 / -1; grid-row: 5; }
        .grid-result-2-0 { grid-column: 1; grid-row: 6; }
        .grid-result-2-1 { grid-column: 2; grid-row: 6; }
        .grid-result-2-2 { grid-column: 3; grid-row: 6; }
        .grid-result-2-3 { grid-column: 4; grid-row: 6; }

        /* Element Header - Clean Minimal */
        .element-header {
            padding: 0;
            background: transparent;
            font-weight: 600;
            font-size: 24px;
            color: #1d1d1f;
            text-transform: none;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            border: none;
            margin-bottom: 12px;
            font-family: inherit;
            text-align: left;
        }
        
        /* For title headers with buttons, use space-between */
        .title-box .element-header {
            justify-content: flex-start;
            gap: 12px;
        }
        
        /* Mobile element headers */
        @media (max-width: 768px) {
            .element-header {
                padding: 6px 10px;
                font-size: 9px;
                border-bottom-width: 1px;
            }
        }

        .element-content {
            padding: 20px;
            text-align: left;
            position: relative !important;
        }
        
        .upload-box .element-content {
            padding: 12px;
            height: calc(100% - 48px);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 120px;
            overflow: hidden;
        }
        
        .start-button, .change-button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        
        .start-button {
            background: #2d2d2d;
            color: #ffffff;
            box-shadow: none;
        }
        
        .start-button:hover {
            background: #1a1a1a;
            transform: none;
            box-shadow: none;
        }
        
        .change-button {
            background: #f5f5f7;
            color: #1c1c1e;
            border: 1px solid #e5e5e7;
        }
        
        .change-button:hover {
            background: #e5e5e7;
        }

        /* Upload Box */
        .upload-box {
            width: 100%;
            height: auto;
            min-height: 200px;
        }

        .upload-zone {
            padding: 16px;
            text-align: center;
            color: #8e8e93;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.1s ease;
            width: 100%;
            aspect-ratio: 1 / 1;
            min-width: 180px;
            max-width: 340px;
            min-height: unset;
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            opacity: 1;
            border: 1px solid #c0c0c0;
            border-radius: 0;
            font-family: inherit;
        }

        .upload-zone:hover {
            background: #ffffff;
            border-color: #d2d2d7;
        }

        .upload-zone.dragover {
            background: #f0f0f0;
            border-color: #d2d2d7;
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 12px;
            font-weight: 300;
            color: inherit;
        }

        /* Image Preview */
        .image-preview {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        /* Image Container */
        .image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        
        .image-container .image-preview {
            margin-bottom: 0;
        }
        
        
        /* Start Button */
        .start-button {
            width: 100%;
            background: #2d2d2d;
            color: #ffffff;
            padding: 16px 24px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 20px;
            flex-shrink: 0;
            border-radius: 4px;
            border: 1px solid #404040;
            box-shadow: none;
            text-transform: none;
            letter-spacing: 0;
        }
        
        .start-button:hover {
            background: #1a1a1a;
            border-color: #505050;
            transform: none;
            box-shadow: none;
        }
        
        .start-button:active {
            background: #0d0d0d;
            border-color: #606060;
            transform: none;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        /* Change Button */
        .change-button {
            width: 100%;
            background: #FFFFFF;
            color: #1c1c1e;
            padding: 14px 18px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 16px;
            flex-shrink: 0;
            opacity: 0.8;
        }
        
        .change-button:hover {
            opacity: 1;
            background: #f2f2f7;
            color: #FFFFFF;
        }

        /* Caption Box */
        .caption-box {
            width: 100%;
            height: 100%;
            min-height: 200px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .caption-box .element-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .caption-text {
            font-size: 14px;
            line-height: 1.5;
            color: #1c1c1e;
            padding: 0;
            font-weight: 400;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .vibe-text {
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 0.8px;
            color: #fff;
        }

        /* Vibe Node */
        .vibe-node {
            width: 100%;
            height: 80px;
            background: #f2f2f7;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .vibe-node:hover {
            background: #FFFFFF;
            color: #1c1c1e;
        }

        .vibe-node.selected {
            opacity: 0.8;
        }


        /* Image Result Box */
        .result-box {
            width: 100%;
            height: 100%;
            min-height: 300px;
            position: relative !important;
        }

        .result-image {
            width: 100%;
            height: calc(100% - 80px);
            min-height: 220px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }
        
        /* Duplicate definition removed - handled above with !important */
        
        .image-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 2;
        }
        

        .result-prompt {
            font-size: 12px;
            color: #1c1c1e;
            line-height: 1.4;
            max-height: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
            opacity: 0.7;
        }

        /* Remove connection styling - using grid layout instead */

        
        /* Enhanced entrance animations */
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-100px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes pulseGeneration {
            0%, 100% {
                background: #FFFFFF;
                opacity: 1;
            }
            50% {
                background: #f2f2f7;
                opacity: 0.8;
            }
        }
        
        .generating {
            animation: pulseGeneration 2s ease-in-out infinite;
        }

        /* Controls */
        .canvas-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .control-btn {
            background: #f2f2f7;
            padding: 12px 18px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            color: #FFFFFF;
        }

        .control-btn:hover {
            background: #FFFFFF;
            color: #1c1c1e;
        }
        
        /* Inline home button styling in title header */
        .home-btn-inline {
            background: #f5f5f7;
            border: 1px solid #e5e5e7;
            border-radius: 6px;
            color: #aeaeb2;
            font-size: 11px;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.1s ease;
            margin-left: auto;
            outline: none;
            font-weight: 500;
        }
        
        .home-btn-inline::before {
            content: "RESET";
            font-size: 8px;
            font-weight: 600;
        }
        
        .home-btn-inline:hover {
            background: #0071e3;
            color: #fff;
            border-color: #0071e3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 113, 227, 0.3);
        }
        
        .home-btn-inline:active {
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Mobile home button */
        @media (max-width: 768px) {
            .home-btn-inline {
                padding: 3px 5px;
                font-size: 10px;
                box-shadow: 1px 1px 0px #fff;
                border-width: 1px;
            }
            
            .home-btn-inline::before {
                font-size: 8px;
            }
            
            .home-btn-inline:hover {
                transform: none;
                box-shadow: 1px 1px 0px #fff;
            }
        }


        /* Teenage Engineering Progress States */
        .progress-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 80px;
        }

        .progress-bar {
            width: 80%;
            height: 4px;
            background: rgba(242, 242, 247, 0.8);
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: #f2f2f7;
            animation: progressSlide 2s infinite;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            background: #f2f2f7;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .progress-text {
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            color: #1c1c1e;
            opacity: 0.7;
        }

        .blank-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        .blank-image {
            width: 100%;
            height: 160px;
            background: #FFFFFF;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            opacity: 0.5;
        }

        .blank-image::after {
            content: '□';
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 24px;
            color: #1c1c1e;
            transform: translate(-50%, -50%);
            opacity: 0.3;
        }

        @keyframes progressSlide {
            0% { left: -100%; }
            100% { left: 100%; }
        }


        /* Loading States */
        .loading {
            opacity: 0.8;
        }
        
        /* Image Cards for responsive grid */
        .image-card {
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            min-height: 300px;
        }
        
        
        .image-card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .loading-cards {
            display: contents;
        }
        
        .loading-card {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            animation: pulseLoading 2s ease-in-out infinite;
        }
        
        .loading-card::after {
            content: 'Loading...';
            color: #666;
            font-weight: 500;
        }
        
        @keyframes pulseLoading {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.8; }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #d2d2d7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-text {
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        
        .error-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #d32f2f;
            font-weight: 500;
        }

        /* Hide original canvas section */
        .canvas-section { display: none; }

        /* Image Modal Styles */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: zoom-out;
        }

        .image-modal.show {
            opacity: 1;
        }

        .modal-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .image-modal.show .modal-image {
            transform: scale(1);
        }

        .modal-close {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            transition: all 0.1s ease;
            backdrop-filter: blur(10px);
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .modal-info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 24px;
            color: #fff;
            font-family: inherit;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-info h3 {
            margin: 0 0 12px 0;
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #0071e3;
        }

        .modal-info p {
            margin: 0;
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.95;
            max-height: 140px;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        /* Modal Navigation */
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            cursor: pointer;
            transition: all 0.1s ease;
            backdrop-filter: blur(15px);
            user-select: none;
        }

        .modal-nav:hover {
            background: rgba(0, 113, 227, 0.8);
            border-color: #0071e3;
            transform: translateY(-50%) scale(1.05);
        }

        .modal-nav.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav.disabled:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1);
        }

        .modal-nav-left {
            left: 30px;
        }

        .modal-nav-right {
            right: 30px;
        }

        .modal-counter {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 8px 16px;
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .whiteboard-container {
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }
            
            /* Improve touch interaction */
            .image-card {
                cursor: pointer;
                transition: transform 0.2s ease;
            }
            
            .image-card:active {
                transform: scale(0.98);
            }
            
            .canvas-surface {
                position: static;
                height: 100vh;
                grid-template-rows: 70% 30%;
            }
            
            .generations-section {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
            
            /* Mobile koncept grid - single column with koncept above each row */
            .mobile-koncept-row {
                display: grid;
                grid-template-columns: 1fr;
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .mobile-results-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .canvas-element {
                min-height: 120px;
            }
            
            .result-box {
                min-height: 250px;
            }
            
            .result-image {
                height: 180px;
                min-height: 160px;
            }
            
            .element-content {
                padding: 8px;
            }
            
            /* Mobile controls */
            .canvas-controls {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                flex-wrap: wrap;
                justify-content: center;
                max-width: 90vw;
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 9px;
                margin: 2px;
            }
            
            .zoom-indicator {
                bottom: 60px;
                left: 10px;
                font-size: 10px;
                padding: 4px 8px;
            }
            
            /* Mobile upload zone */
            .upload-zone {
                min-height: 100px;
                padding: 15px;
            }
            
            .upload-icon {
                font-size: 20px;
            }
            
            /* Mobile caption box */
            .caption-text {
                font-size: 11px;
                padding: 8px;
            }
            
            /* Touch-friendly sizing */
            .koncept-text {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Mobile editing pane improvements */
        @media (max-width: 768px) {
            .editing-chain-section {
                padding: 16px;
                min-height: 200px;
                max-height: 40vh;
            }
            
            .editing-chain-section.collapsed {
                padding: 8px 16px;
                min-height: 70px;
            }
            
            .editing-chain-header {
                padding: 8px 12px;
            }
            
            .upload-container-inline {
                flex: 0 0 auto;
                margin-bottom: 12px;
            }
            
            .editing-chain-content {
                gap: 8px;
            }
            
            .chain-image {
                width: 60px;
                height: 60px;
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .canvas-surface {
                padding: 0;
                gap: 0;
            }
            
            .right-section-container {
                padding: 0;
            }
            
            .editing-chain-section {
                padding: 12px;
                min-height: 180px;
                max-height: 35vh;
                border-top: 2px solid #5A7A70;
            }
            
            .editing-chain-section.collapsed {
                padding: 6px 12px;
                min-height: 60px;
            }
            
            .editing-chain-header {
                padding: 6px 10px;
            }
            
            .resize-handle {
                height: 6px;
                background: #5A7A70;
            }
            
            .upload-container-inline {
                flex: 0 0 auto;
                border-radius: 4px;
                margin-bottom: 8px;
            }
            
            .chain-image {
                width: 50px;
                height: 50px;
            }
            
            .export-sequence-btn {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            /* Better touch targets */
            .use-as-input-icon {
                min-height: 44px !important;
                font-size: 12px !important;
            }
            
            .use-as-input-icon::after {
                font-size: 12px;
            }
            
            /* Responsive button styling */
            .cta-button {
                padding: 12px 24px;
                font-size: 14px;
                min-height: 44px;
            }
            
            .mobile-results-grid {
                grid-template-columns: 1fr;
            }
            
            .control-btn {
                padding: 6px 10px;
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="whiteboard-container" id="whiteboardContainer">
        
        <div class="canvas-surface" id="canvasSurface">
            <!-- Left Section - Hidden Sidebar -->
            <div class="left-section" id="leftSection">
                <!-- Title Box -->
                <div class="title-container">
                    <div class="canvas-element title-box">
                        <div class="element-header">
                            KOMPOSER
                            <button class="home-btn-inline" onclick="resetApp()" title="Reset App"></button>
                        </div>
                        <div class="element-content">
                            <div class="subtitle-text">Let AI do the prompting for you</div>
                            <div class="attribution">A <a href="https://bfl.ai/" target="_blank">BFL Kontext</a> experiment</div>
                        </div>
                    </div>
                </div>
                
                <!-- Upload Box -->
                <div class="upload-container">
                    <div class="canvas-element upload-box" id="uploadElement">
                        <div class="element-content">
                            <div class="upload-zone" id="uploadZone">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8e8e93" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="margin-bottom: 16px;">
                                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                </svg>
                                <div style="font-size: 18px; font-weight: 600; color: #8e8e93; margin-bottom: 6px;">Upload Image</div>
                                <div style="font-size: 14px; color: #666; line-height: 1.4;">Drop, click, or paste to start generating</div>
                                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <!-- Caption Box Container -->
                <div class="caption-container">
                    <!-- Caption will be added dynamically -->
                </div>
            </div>
            
            <!-- Right Section - Now just generations -->
            <div class="right-section-container">
                <div class="generations-section" id="rightSection">
                    <!-- Empty state -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-content">
                            <div class="empty-state-icon">
                                <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="#B8C5C0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                </svg>
                            </div>
                            <h2 class="empty-state-title">Create Your Edit Tree</h2>
                            <p class="empty-state-description">
                                Upload an image to start creating your sequence of iterative edits. 
                                AI will generate multiple creative edits, and you can branch from any result to explore new directions.
                            </p>
                            <div class="empty-state-steps">
                                <div class="step">
                                    <span class="step-number">1</span>
                                    <span class="step-text">Upload an image below</span>
                                </div>
                                <div class="step">
                                    <span class="step-number">2</span>
                                    <span class="step-text">AI automatically generates 12 creative variations</span>
                                </div>
                                <div class="step">
                                    <span class="step-number">3</span>
                                    <span class="step-text">Click "BRANCH FROM HERE" on any result</span>
                                </div>
                            </div>
                            <div class="empty-state-cta">
                                <button class="cta-button" onclick="document.getElementById('fileInputInline').click()">
                                    GET STARTED
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Docked - Resizable Editing Chain -->
            <div class="editing-chain-section" id="editingChainSection">
                <div class="resize-handle" id="resizeHandle"></div>
                <div class="editing-chain-header" onclick="toggleEditingPane()">
                    <div class="chain-title-row">
                        <h3>KOMPOSER<span class="collapse-indicator">▲</span></h3>
                        <div class="header-controls">
                            <button class="export-sequence-btn" onclick="openComicStripModal()" title="Export sequence">
                                EXPORT
                            </button>
                            <button class="reset-btn" onclick="resetApp()" title="Reset">
                                RESET
                            </button>
                        </div>
                    </div>
                    <p class="subtitle">Let AI do the prompting for you — A <a href="https://bfl.ai/" target="_blank">BFL Kontext</a> experiment</p>
                </div>
                <div class="workflow-row">
                    <div class="upload-container-inline" id="uploadContainerInline">
                        <div class="upload-zone-inline" id="uploadZoneInline">
                            <div class="upload-text">Drop, click, or paste to start generating</div>
                            <input type="file" id="fileInputInline" accept="image/*" style="display: none;">
                        </div>
                    </div>
                    <div class="num-images-container" style="display: none;">
                        <label class="num-images-label"># IMAGES</label>
                        <input type="number" id="numImagesInputInline" class="num-images-input" min="1" max="48" value="12">
                    </div>
                    <div class="editing-chain-sequence" id="editingChainSequence">
                        <div class="chain-placeholder">
                            Upload an image to begin your editing chain
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Image Modal -->
    <div class="image-modal" id="imageModal" style="display: none;">
        <div class="modal-counter" id="modalCounter">1 / 12</div>
        <div class="modal-close" onclick="closeImageModal()">×</div>
        <div class="modal-nav modal-nav-left" id="modalPrev" onclick="navigateModal(-1)">‹</div>
        <div class="modal-nav modal-nav-right" id="modalNext" onclick="navigateModal(1)">›</div>
        <img class="modal-image" id="modalImage" src="" alt="Expanded view">
        <div class="modal-info" id="modalInfo">
            <h3 id="modalTitle">Generation Result</h3>
            <p id="modalPrompt">Prompt will appear here</p>
        </div>
    </div>

    <script>
        // Global state
        let currentImageBase64 = null;
        
        // Modal navigation state
        let modalImages = [];
        let currentModalIndex = 0;
        let modalPrompts = {}; // Store prompts by unique ID
        let promptIdCounter = 0;
        
        // Generate unique prompt ID and store prompt
        function storePrompt(promptText) {
            const promptId = `prompt_${promptIdCounter++}`;
            modalPrompts[promptId] = promptText || 'AI generated transformation';
            return promptId;
        }
        
        // Custom koncept state
        let customKonceptCount = 0;
        let totalKonceptRows = 3; // Start with 3 default koncepts
        
        // Polling function for async generation
        async function pollForCompletion(requestId, imageIndex) {
            const maxAttempts = 60; // 60 attempts × 3 seconds = 3 minutes max
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                try {
                    console.log(`🔍 Polling attempt ${attempts + 1} for image ${imageIndex}, requestId: ${requestId}`);
                    
                    const statusResponse = await fetch(`/api/check-generation/${requestId}`);
                    if (!statusResponse.ok) {
                        throw new Error(`Status check failed: ${statusResponse.status}`);
                    }
                    
                    const statusResult = await statusResponse.json();
                    console.log(`📊 Status for image ${imageIndex}:`, statusResult.status);
                    
                    if (statusResult.status === 'completed') {
                        console.log(`✅ Image ${imageIndex} generation completed!`);
                        return statusResult;
                    } else if (statusResult.status === 'error') {
                        throw new Error(statusResult.error || 'Generation failed');
                    }
                    
                    // Still processing, wait and try again
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    attempts++;
                    
                } catch (error) {
                    console.error(`❌ Polling error for image ${imageIndex}:`, error);
                    if (attempts >= 5) { // Give up after 5 failed polling attempts
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    attempts++;
                }
            }
            
            throw new Error('Generation timeout - exceeded maximum polling time');
        }
        
        // Session management
        let currentSessionId = null;
        let sessionResults = [];
        let seedHistory = []; // Track iteration history
        
        // Seed history management functions
        function addToSeedHistory(imageUrl, title, isOriginal = false) {
            const seedData = {
                imageUrl: imageUrl,
                title: title,
                timestamp: Date.now(),
                isOriginal: isOriginal
            };
            
            seedHistory.push(seedData);
            updateSeedHistoryDisplay();
            console.log('📜 Added to seed history:', title);
        }
        
        function updateSeedHistoryDisplay() {
            const chainSequence = document.getElementById('editingChainSequence');
            
            // Update bottom editing chain
            if (chainSequence) {
                // Clear existing chain
                chainSequence.innerHTML = '';
                
                if (seedHistory.length === 0) {
                    chainSequence.innerHTML = '<div class="chain-placeholder">Upload an image to begin your editing chain</div>';
                } else {
                    // Add each seed to the chain
                    seedHistory.forEach((seed, index) => {
                        // Add arrow between images (except before first)
                        if (index > 0) {
                            const arrow = document.createElement('div');
                            arrow.className = 'chain-arrow';
                            arrow.innerHTML = '→';
                            chainSequence.appendChild(arrow);
                        }
                        
                        // Add image
                        const chainImage = document.createElement('div');
                        chainImage.className = 'chain-image';
                        chainImage.innerHTML = `
                            <img src="${seed.imageUrl}" alt="${seed.title}">
                            <div class="chain-image-label">${seed.title}</div>
                        `;
                        
                        // Add click handler to view in modal
                        chainImage.onclick = () => {
                            const promptId = storePrompt(`${seed.title} (iteration ${index + 1})`);
                            openImageModal(seed.imageUrl, seed.title, promptId);
                        };
                        
                        chainSequence.appendChild(chainImage);
                    });
                }
            }
        }
        
        function clearSeedHistory() {
            seedHistory = [];
            
            // Clear the editing chain
            const chainSequence = document.getElementById('editingChainSequence');
            if (chainSequence) {
                chainSequence.innerHTML = '<div class="chain-placeholder">Upload an image to begin your editing chain</div>';
            }
            
            console.log('🗑️ Cleared seed history');
        }
        
        // Comic Strip Modal Functions
        function openComicStripModal() {
            console.log('🎬 Opening comic strip modal');
            
            if (seedHistory.length === 0) {
                alert('No iteration history available to display.');
                return;
            }
            
            const modal = document.getElementById('comicStripModal');
            const sequence = document.getElementById('comicStripSequence');
            
            // Clear existing panels
            sequence.innerHTML = '';
            
            // Generate comic panels for each iteration
            seedHistory.forEach((seed, index) => {
                const panel = document.createElement('div');
                panel.className = 'comic-panel';
                
                panel.innerHTML = `
                    <img src="${seed.imageUrl}" alt="Iteration ${index + 1}" class="comic-panel-image">
                `;
                
                sequence.appendChild(panel);
            });
            
            // Show modal with animation
            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('show'), 10);
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // Add escape key listener
            document.addEventListener('keydown', handleComicStripEscape);
        }
        
        function closeComicStripModal() {
            console.log('🎬 Closing comic strip modal');
            
            const modal = document.getElementById('comicStripModal');
            
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
            
            // Remove escape key listener
            document.removeEventListener('keydown', handleComicStripEscape);
        }
        
        function downloadComicStrip() {
            console.log('📸 Downloading comic strip with branding');
            
            const sequence = document.getElementById('comicStripSequence');
            
            // Create a temporary container with padding and branding
            const exportContainer = document.createElement('div');
            exportContainer.style.cssText = `
                background: #f8f8f8;
                padding: 40px 60px;
                font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
                position: fixed;
                top: -10000px;
                left: -10000px;
                z-index: -1;
                border-radius: 0;
                box-shadow: none;
                width: max-content;
                white-space: nowrap;
            `;
            
            // Add title and branding to match web header
            const brandingHeader = document.createElement('div');
            brandingHeader.style.cssText = `
                text-align: center;
                margin-bottom: 16px;
            `;
            brandingHeader.innerHTML = `
                <h3 style="
                    font-size: 18px;
                    font-weight: 600;
                    color: #2d2d2d;
                    margin: 0 0 4px 0;
                    letter-spacing: -0.02em;
                ">FLUX.1 Kontext Editing Chain</h3>
                <p style="
                    font-size: 14px;
                    color: #666;
                    margin: 0;
                    font-weight: 300;
                ">Learn more at <a href="https://bfl.ai/models/flux-kontext" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">https://bfl.ai/models/flux-kontext</a></p>
            `;
            
            // Clone the sequence content
            const sequenceClone = sequence.cloneNode(true);
            sequenceClone.style.cssText = `
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: flex-start;
                flex-wrap: nowrap;
                width: max-content;
                padding: 16px 0;
                overflow: visible;
            `;
            
            // Style the cloned chain images to match web exactly
            const chainImages = sequenceClone.querySelectorAll('.chain-image');
            chainImages.forEach(chainImage => {
                chainImage.style.cssText = `
                    flex-shrink: 0;
                    width: 120px;
                    height: auto;
                    max-height: 200px;
                    border-radius: 8px;
                    overflow: visible;
                    position: relative;
                    border: 2px solid #ddd;
                    background: #f5f5f5;
                `;
                
                // Style the image inside
                const img = chainImage.querySelector('img');
                if (img) {
                    img.style.cssText = `
                        width: 100%;
                        height: auto;
                        object-fit: contain;
                        display: block;
                    `;
                }
                
                // Style the label
                const label = chainImage.querySelector('.chain-image-label');
                if (label) {
                    label.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.8) 100%);
                        color: white;
                        font-size: 10px;
                        font-weight: 500;
                        padding: 4px 6px;
                        text-align: center;
                    `;
                }
            });
            
            // Style the arrows to match web exactly
            const arrows = sequenceClone.querySelectorAll('.chain-arrow');
            arrows.forEach(arrow => {
                arrow.style.cssText = `
                    flex-shrink: 0;
                    color: #999;
                    font-size: 16px;
                    font-weight: bold;
                `;
            });
            
            // Assemble the export container
            exportContainer.appendChild(brandingHeader);
            exportContainer.appendChild(sequenceClone);
            
            // Remove from DOM first since we'll add it back temporarily for measurement
            
            // Add to document temporarily
            document.body.appendChild(exportContainer);
            
            // Wait for layout and get accurate dimensions
            setTimeout(() => {
                const actualWidth = Math.max(exportContainer.scrollWidth, exportContainer.offsetWidth);
                const actualHeight = Math.max(exportContainer.scrollHeight, exportContainer.offsetHeight);
                
                console.log(`📏 Export dimensions: ${actualWidth}x${actualHeight}`);
                
                // Use html2canvas to capture the branded sequence
                if (typeof html2canvas !== 'undefined') {
                    html2canvas(exportContainer, {
                        backgroundColor: '#ffffff',
                        scale: 2, // Higher resolution
                        useCORS: true,
                        allowTaint: true,
                        width: actualWidth,
                        height: actualHeight,
                        scrollX: 0,
                        scrollY: 0
                    }).then(canvas => {
                    // Clean up temporary container
                    document.body.removeChild(exportContainer);
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.download = `flux-kontext-sequence-${Date.now()}.png`;
                    link.href = canvas.toDataURL();
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                        console.log('✅ Branded comic strip downloaded successfully');
                    }).catch(error => {
                        console.error('❌ Error capturing comic strip:', error);
                        // Clean up on error
                        if (document.body.contains(exportContainer)) {
                            document.body.removeChild(exportContainer);
                        }
                        alert('Download failed. Try taking a screenshot of the sequence instead.');
                    });
                } else {
                    // Clean up and show fallback
                    document.body.removeChild(exportContainer);
                    alert('To download, please take a screenshot of this sequence. We recommend using your browser\'s screenshot feature or a screenshot tool.');
                }
            }, 100);
        }
        
        function handleComicStripEscape(e) {
            if (e.key === 'Escape') {
                closeComicStripModal();
            }
        }
        
        // Individual image sharing function
        function shareIndividualImage(event, konceptIndex, resultIndex) {
            event.stopPropagation(); // Prevent image modal from opening
            
            if (!currentSessionId) {
                alert('Session not available for sharing');
                return;
            }
            
            const shareUrl = `${window.location.origin}/image/${currentSessionId}/${konceptIndex}/${resultIndex}`;
            
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✅ Copied!';
                button.style.background = '#4CAF50';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback - show URL in prompt
                prompt('Copy this share URL:', shareUrl);
            });
            
            console.log('🔗 Individual image share URL:', shareUrl);
        }
        let isSharedSession = false;


        // DOM elements
        const container = document.getElementById('whiteboardContainer');
        const surface = document.getElementById('canvasSurface');
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');

        // Initialize the app
        function initWhiteboard() {
            setupEventListeners();
            
            // Check if this is a shared session
            checkForSharedSession();
            
            // Handle mobile layout
            handleMobileLayout();
        }
        
        // Handle mobile-specific layout adjustments
        function handleMobileLayout() {
            if (window.innerWidth <= 768) {
                // Mobile-specific adjustments if needed
                const controls = document.querySelector('.canvas-controls');
                if (controls) {
                    controls.style.display = 'none';
                }
                // Zoom indicator functionality removed
            }
        }
        
        // Handle window resize for mobile responsiveness
        window.addEventListener('resize', () => {
            handleMobileLayout();
        });
        
        // Check if we're loading a shared session
        function checkForSharedSession() {
            const path = window.location.pathname;
            const sessionMatch = path.match(/^\/session\/([a-f0-9]+)$/);
            
            if (sessionMatch) {
                const sessionId = sessionMatch[1];
                console.log('🔗 Loading shared session:', sessionId);
                loadSharedSession(sessionId);
            } else {
                // Generate new session ID for new sessions
                currentSessionId = generateSessionId();
                console.log('🆕 New session created:', currentSessionId);
                
                // Update URL immediately for new sessions
                window.history.replaceState({}, '', `/session/${currentSessionId}`);
            }
        }
        
        // Generate a random session ID
        function generateSessionId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(8)))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // Load a shared session from the server
        async function loadSharedSession(sessionId) {
            try {
                isSharedSession = true;
                currentSessionId = sessionId;
                
                console.log('📥 Fetching session data...');
                const response = await fetch(`/api/session/${sessionId}`);
                
                if (!response.ok) {
                    throw new Error('Session not found');
                }
                
                const sessionData = await response.json();
                console.log('✅ Session data loaded:', sessionData);
                
                // Load the original image
                if (sessionData.originalImage) {
                    const imageBlob = await fetch(`data:image/jpeg;base64,${sessionData.originalImage}`).then(r => r.blob());
                    const file = new File([imageBlob], 'shared-image.jpg', { type: 'image/jpeg' });
                    await processImageFile(file);
                    
                    // Set the base64 for future operations
                    currentImageBase64 = sessionData.originalImage;
                }
                
                // Load the results
                loadSessionResults(sessionData.results);
                
                // Load the caption if it exists
                if (sessionData.caption) {
                    console.log('🔄 Loading session caption:', sessionData.caption);
                    fillCaptionBox(sessionData.caption);
                }
                
                // Load the koncept names if they exist
                if (sessionData.konceptNames && Array.isArray(sessionData.konceptNames)) {
                    console.log('🔄 Loading session koncept names:', sessionData.konceptNames);
                    fillKonceptLabels(sessionData.konceptNames);
                }
                
                // Disable upload for shared sessions
                disableUploadForSharedSession();
                
            } catch (error) {
                console.log('📝 Session not found in database, treating as new session:', sessionId);
                
                // Don't show error alert - this is normal for new sessions
                // Keep the session ID from the URL and treat as a new session
                currentSessionId = sessionId;
                isSharedSession = false;
                
                // No need to update URL since it's already correct
                console.log('✅ New session initialized with ID:', currentSessionId);
            }
        }
        
        // Load session results into the interface
        function loadSessionResults(results) {
            console.log('🔄 Loading session results:', results);
            
            // Create the layout structure
            createBlankLayout();
            
            // Group results by concept (assuming 4 results per concept)
            const concepts = [];
            for (let i = 0; i < results.length; i += 4) {
                concepts.push(results.slice(i, i + 4));
            }
            
            concepts.forEach((conceptResults, conceptIndex) => {
                if (conceptIndex < 3) { // First 3 are the default concepts
                    const konceptLabel = document.getElementById(`koncept-label-${conceptIndex}`);
                    if (konceptLabel) {
                        konceptLabel.innerHTML = `KONCEPT ${conceptIndex + 1}`;
                    }
                    
                    // Fill in the results
                    conceptResults.forEach((result, resultIndex) => {
                        if (result.image) {
                            displaySharedResult(conceptIndex, resultIndex, result);
                        }
                    });
                }
            });
        }
        
        // Display a shared session result
        function displaySharedResult(conceptIndex, resultIndex, result) {
            const resultBoxId = `result-${conceptIndex}-${resultIndex}`;
            const resultBox = document.getElementById(resultBoxId);
            
            if (resultBox && result.image) {
                const content = resultBox.querySelector('.element-content');
                const imageUrl = `data:image/jpeg;base64,${result.image}`;
                const promptId = storePrompt(result.prompt);
                
                content.innerHTML = `
                    <img src="${imageUrl}" class="result-image" data-prompt-id="${promptId}" style="
                        cursor: zoom-in;
                        position: relative;
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                    " onclick="openImageModal('${imageUrl}', 'KONCEPT ${conceptIndex + 1} #${resultIndex + 1}', '${promptId}')">
                    <div class="use-as-input-icon" 
                         onclick="event.stopPropagation(); useAsInput('${imageUrl}', 'KONCEPT ${conceptIndex + 1} #${resultIndex + 1}', '${promptId}')"
                         title="Use this image to start a new generation">
                    </div>
                `;
                
                // Success visual feedback
                resultBox.style.background = '#fff';
                resultBox.style.color = '#000';
            }
        }
        
        // Disable upload functionality for shared sessions
        function disableUploadForSharedSession() {
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = 'none';
                uploadZone.style.opacity = '0.5';
                uploadZone.innerHTML = '<div style="color: #666;">Viewing shared session</div>';
            }
        }

        function setupEventListeners() {
            // Original upload functionality (if sidebar still exists)
            if (uploadZone) {
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', handleDragOver);
                uploadZone.addEventListener('drop', handleDrop);
            }
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
            }

            // Inline upload functionality
            const uploadZoneInline = document.getElementById('uploadZoneInline');
            const fileInputInline = document.getElementById('fileInputInline');
            if (uploadZoneInline && fileInputInline) {
                uploadZoneInline.addEventListener('click', () => fileInputInline.click());
                uploadZoneInline.addEventListener('dragover', handleDragOver);
                uploadZoneInline.addEventListener('drop', handleDrop);
                fileInputInline.addEventListener('change', handleFileSelect);
            }

            // Clipboard paste functionality
            document.addEventListener('paste', handlePaste);

            // Prevent default drag behavior
            document.addEventListener('dragover', e => e.preventDefault());
            document.addEventListener('drop', e => e.preventDefault());
            
            // Handle window resize to auto-reposition
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only auto-reposition if we have content on screen
                    const rightSection = document.querySelector('.generations-section');
                    if (rightSection && rightSection.children.length > 0) {
                        autoPositionCamera();
                    }
                }, 300); // Debounce resize events
            });
            
        }
        
        // Initialize sidebar state based on screen size
        function initializeSidebarState() {
            const leftSection = document.getElementById('leftSection');
            const toggleButton = document.getElementById('sidebarToggle');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // Start closed on mobile
                leftSection.classList.add('closed');
                toggleButton.classList.add('sidebar-closed');
                toggleButton.innerHTML = '☰';
            } else {
                // Start open on desktop
                leftSection.classList.remove('closed');
                toggleButton.classList.remove('sidebar-closed');
                toggleButton.innerHTML = '✕';
            }
        }
        
        // Call on load and resize
        window.addEventListener('load', initializeSidebarState);
        window.addEventListener('resize', initializeSidebarState);
        
        // Force REMIX button visibility and proper positioning
        function ensureRemixButtonsVisible() {
            const remixButtons = document.querySelectorAll('.use-as-input-icon');
            console.log(`🔧 Ensuring ${remixButtons.length} REMIX buttons are visible and positioned...`);
            
            remixButtons.forEach((button, index) => {
                console.log(`🔧 Processing button ${index + 1}:`, {
                    display: button.style.display,
                    visibility: button.style.visibility,
                    opacity: button.style.opacity,
                    computed: window.getComputedStyle(button).display
                });
                
                // Force style recalculation with aggressive overrides for bar design
                button.style.setProperty('display', 'flex', 'important');
                button.style.setProperty('visibility', 'visible', 'important');
                button.style.setProperty('opacity', '1', 'important');
                button.style.setProperty('z-index', '50', 'important');
                button.style.setProperty('position', 'absolute', 'important');
                button.style.setProperty('pointer-events', 'auto', 'important');
                button.style.setProperty('bottom', '0', 'important');
                button.style.setProperty('left', '0', 'important');
                button.style.setProperty('right', '0', 'important');
                button.style.setProperty('width', '100%', 'important');
                button.style.setProperty('height', '10%', 'important');
                button.style.setProperty('min-height', '32px', 'important');
                button.style.setProperty('max-height', '50px', 'important');
                button.style.setProperty('transform', 'none', 'important');
                button.style.setProperty('top', 'auto', 'important');
                
                // Find the associated image in the simplified structure
                const elementContent = button.closest('.element-content');
                const img = elementContent ? elementContent.querySelector('.result-image, img') : null;
                
                // REMIX button uses CSS-only positioning now - no JavaScript needed
                
                // Remove any hiding attributes
                button.removeAttribute('hidden');
                button.classList.remove('hidden');
                
                // Force reflow to ensure browser applies styles
                button.offsetHeight;
                
                // Firefox-specific handling
                if (navigator.userAgent.includes('Firefox')) {
                    button.style.setProperty('isolation', 'isolate', 'important');
                    button.style.setProperty('-moz-user-select', 'none', 'important');
                    button.style.setProperty('-moz-appearance', 'none', 'important');
                    // Ensure Firefox uses bottom positioning, not transform
                    button.style.setProperty('bottom', '0', 'important');
                    button.style.setProperty('transform', 'none', 'important');
                    button.style.setProperty('contain', 'none', 'important');
                }
                
                console.log(`✅ Button ${index + 1} processed and positioned`);
            });
        }
        
        // Run visibility check after images load and periodically
        window.addEventListener('load', () => {
            setTimeout(ensureRemixButtonsVisible, 500);
            setTimeout(ensureRemixButtonsVisible, 2000);
            setInterval(ensureRemixButtonsVisible, 5000);
            
            // Start mutation observer to catch when buttons get hidden
            startRemixButtonObserver();
        });
        
        // Aggressive mutation observer to detect and fix hidden REMIX buttons
        function startRemixButtonObserver() {
            console.log('🔍 Starting REMIX button mutation observer for Firefox...');
            
            const observer = new MutationObserver((mutations) => {
                let buttonsNeedFix = false;
                
                mutations.forEach((mutation) => {
                    // Check if any nodes were added (new images with buttons)
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1) { // Element node
                                const hasButton = node.querySelector && node.querySelector('.use-as-input-icon');
                                const isButton = node.classList && node.classList.contains('use-as-input-icon');
                                if (hasButton || isButton) {
                                    buttonsNeedFix = true;
                                }
                            }
                        });
                    }
                    
                    // Check if any attributes changed on REMIX buttons
                    if (mutation.type === 'attributes' && mutation.target.classList.contains('use-as-input-icon')) {
                        const button = mutation.target;
                        const computedStyle = window.getComputedStyle(button);
                        
                        // Check if button got hidden
                        if (computedStyle.display === 'none' || 
                            computedStyle.visibility === 'hidden' || 
                            computedStyle.opacity === '0' ||
                            button.style.display === 'none' ||
                            button.style.visibility === 'hidden' ||
                            button.style.opacity === '0') {
                            
                            console.log('🚨 REMIX button was hidden, restoring immediately!');
                            buttonsNeedFix = true;
                        }
                    }
                });
                
                if (buttonsNeedFix) {
                    // Use RAF to ensure we run after current render cycle
                    requestAnimationFrame(() => {
                        setTimeout(ensureRemixButtonsVisible, 0);
                    });
                }
            });
            
            // Observe the entire document for changes
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['style', 'class', 'hidden']
            });
            
            console.log('✅ REMIX button observer started');
        }
        
        // Debug function for REMIX button issues (can be called from console)
        window.debugRemixButtons = function() {
            console.log('🔍 DEBUGGING REMIX BUTTONS');
            const buttons = document.querySelectorAll('.use-as-input-icon');
            console.log(`Found ${buttons.length} REMIX buttons`);
            
            buttons.forEach((button, i) => {
                const computed = window.getComputedStyle(button);
                const rect = button.getBoundingClientRect();
                
                console.log(`Button ${i + 1}:`, {
                    element: button,
                    inlineStyles: {
                        display: button.style.display,
                        visibility: button.style.visibility,
                        opacity: button.style.opacity,
                        position: button.style.position,
                        zIndex: button.style.zIndex
                    },
                    computedStyles: {
                        display: computed.display,
                        visibility: computed.visibility,
                        opacity: computed.opacity,
                        position: computed.position,
                        zIndex: computed.zIndex
                    },
                    dimensions: {
                        width: rect.width,
                        height: rect.height,
                        top: rect.top,
                        left: rect.left
                    },
                    isVisible: rect.width > 0 && rect.height > 0,
                    classes: Array.from(button.classList),
                    parent: button.parentElement.className
                });
            });
            
            // Force fix all buttons
            ensureRemixButtonsVisible();
            console.log('🔧 Applied fixes, check buttons again!');
        };
        
        // Editing Pane Collapse/Expand Functionality
        function toggleEditingPane() {
            const editingSection = document.querySelector('.editing-chain-section');
            const canvasSurface = document.getElementById('canvasSurface');
            
            editingSection.classList.toggle('collapsed');
            
            if (editingSection.classList.contains('collapsed')) {
                // When collapsed, change to 90% / 10% split
                canvasSurface.style.gridTemplateRows = '90% 10%';
            } else {
                // When expanded, restore original 70% / 30% split
                canvasSurface.style.gridTemplateRows = '70% 30%';
            }
        }

        // Bottom Pane Resize Functionality
        let isResizing = false;
        let startY = 0;
        let startHeight = 0;
        let currentMainHeight = 70; // Start at 70% (30% for editing chain)
        
        function initializeResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const canvasSurface = document.querySelector('.canvas-surface');
            
            if (!resizeHandle || !canvasSurface) return;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startHeight = currentMainHeight;
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = window.innerHeight;
                const deltaPercent = (deltaY / containerHeight) * 100;
                
                // Calculate new heights (constrain between 10% and 90%)
                let newMainHeight = Math.max(10, Math.min(90, startHeight + deltaPercent));
                let newEditingHeight = 100 - newMainHeight;
                
                // Update the grid template
                canvasSurface.style.gridTemplateRows = `${newMainHeight}% ${newEditingHeight}%`;
                currentMainHeight = newMainHeight;
                
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
            
            // Handle touch events for mobile
            resizeHandle.addEventListener('touchstart', (e) => {
                isResizing = true;
                startY = e.touches[0].clientY;
                startHeight = currentMainHeight;
                resizeHandle.classList.add('dragging');
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.touches[0].clientY - startY;
                const containerHeight = window.innerHeight;
                const deltaPercent = (deltaY / containerHeight) * 100;
                
                let newMainHeight = Math.max(10, Math.min(90, startHeight + deltaPercent));
                let newEditingHeight = 100 - newMainHeight;
                
                canvasSurface.style.gridTemplateRows = `${newMainHeight}% ${newEditingHeight}%`;
                currentMainHeight = newMainHeight;
                
                e.preventDefault();
            });
            
            document.addEventListener('touchend', () => {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                }
            });
        }
        
        // REMIX buttons now use simple CSS positioning - no complex JavaScript needed
        
        // Initialize resize functionality when page loads
        window.addEventListener('load', initializeResize);
        
        // Force REMIX button check after layout changes
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('🔍 Post-load REMIX button check...');
                const buttons = document.querySelectorAll('.use-as-input-icon');
                const visibleButtons = Array.from(buttons).filter(btn => {
                    const rect = btn.getBoundingClientRect();
                    const computed = window.getComputedStyle(btn);
                    return rect.width > 0 && rect.height > 0 && computed.display !== 'none' && computed.visibility !== 'hidden';
                });
                
                console.log(`Found ${buttons.length} total buttons, ${visibleButtons.length} visible`);
                
                if (buttons.length > 0 && visibleButtons.length === 0) {
                    console.log('🚨 No REMIX buttons visible - running diagnostics and fixes...');
                    if (window.debugRemixButtons) {
                        window.debugRemixButtons();
                    }
                    setTimeout(() => {
                        if (window.nukeAndRecreateRemixButtons) {
                            window.nukeAndRecreateRemixButtons();
                        }
                    }, 1000);
                }
            }, 2000);
        });
        
        // Manual REMIX button fix function - can be called from console
        window.fixRemixButtons = function() {
            console.log('🔧 Manual REMIX button fix triggered...');
            
            // First try repositioning all buttons
            const buttons = document.querySelectorAll('.use-as-input-icon');
            console.log(`Found ${buttons.length} REMIX buttons to fix`);
            
            buttons.forEach((button, i) => {
                const elementContent = button.closest('.element-content');
                const img = elementContent ? elementContent.querySelector('.result-image, img') : null;
                
                // REMIX button uses CSS-only positioning now
            });
            
            // Then try the aggressive visibility function
            if (window.ensureRemixButtonsVisible) {
                ensureRemixButtonsVisible();
            }
            
            // Wait a moment then check if it worked
            setTimeout(() => {
                const visibleButtons = Array.from(buttons).filter(btn => {
                    const rect = btn.getBoundingClientRect();
                    return rect.width > 0 && rect.height > 0;
                });
                
                console.log(`After fix: ${visibleButtons.length}/${buttons.length} buttons visible`);
                
                if (buttons.length > 0 && visibleButtons.length === 0) {
                    console.log('💥 All fixes failed - trying nuclear option...');
                    if (window.nukeAndRecreateRemixButtons) {
                        nukeAndRecreateRemixButtons();
                    }
                }
            }, 500);
        };
        
        // Force all REMIX buttons to be visible with correct bar styling
        window.forceRemixBarsVisible = function() {
            console.log('🔧 FORCING ALL REMIX BARS VISIBLE');
            const buttons = document.querySelectorAll('.use-as-input-icon');
            
            buttons.forEach((button, i) => {
                console.log(`🔧 Forcing button ${i + 1} visible...`);
                
                // Remove any conflicting inline styles first
                button.style.cssText = '';
                
                // Apply bar styling with highest specificity
                button.style.setProperty('position', 'absolute', 'important');
                button.style.setProperty('bottom', '0', 'important');
                button.style.setProperty('left', '0', 'important');
                button.style.setProperty('right', '0', 'important');
                button.style.setProperty('width', '100%', 'important');
                button.style.setProperty('height', '10%', 'important');
                button.style.setProperty('min-height', '32px', 'important');
                button.style.setProperty('max-height', '50px', 'important');
                button.style.setProperty('display', 'flex', 'important');
                button.style.setProperty('visibility', 'visible', 'important');
                button.style.setProperty('opacity', '1', 'important');
                button.style.setProperty('z-index', '50', 'important');
                button.style.setProperty('background', 'rgba(0, 0, 0, 0.85)', 'important');
                button.style.setProperty('color', 'white', 'important');
                button.style.setProperty('border', 'none', 'important');
                button.style.setProperty('border-top', '1px solid rgba(255, 255, 255, 0.2)', 'important');
                button.style.setProperty('border-radius', '0', 'important');
                button.style.setProperty('transform', 'none', 'important');
                button.style.setProperty('top', 'auto', 'important');
                
                // Remove any hidden attributes
                button.removeAttribute('hidden');
                button.classList.remove('hidden');
            });
            
            console.log(`✅ Forced ${buttons.length} REMIX bars visible`);
        };
        
        // Call on page load
        window.addEventListener('load', () => {
            setTimeout(window.forceRemixBarsVisible, 1000);
        });

        // Removed zoom/pan functionality for simpler scrolling interface

        function handleMouseUp(e) {
            if (isDragging && dragElement) {
                dragElement.classList.remove('dragging');
                dragElement = null;
                isDragging = false;
            }
            
            if (isPanning) {
                isPanning = false;
                container.classList.remove('grabbing');
                
                // Start inertia animation if there's enough velocity
                if (panHistory.length > 1) {
                    // Calculate average velocity from recent history
                    const avgVelocity = panHistory.reduce((acc, entry) => {
                        acc.x += entry.velocity.x;
                        acc.y += entry.velocity.y;
                        return acc;
                    }, { x: 0, y: 0 });
                    
                    avgVelocity.x /= panHistory.length;
                    avgVelocity.y /= panHistory.length;
                    
                    // Only start inertia if velocity is significant
                    const velocityMagnitude = Math.sqrt(avgVelocity.x * avgVelocity.x + avgVelocity.y * avgVelocity.y);
                    if (velocityMagnitude > 0.5) {
                        startInertiaAnimation(avgVelocity);
                    }
                }
            }
        }

        function startInertiaAnimation(initialVelocity) {
            let currentVelocity = { ...initialVelocity };
            const friction = 0.92; // Deceleration factor
            const minVelocity = 0.1; // Stop threshold
            
            function animate() {
                // Apply velocity to position
                panX += currentVelocity.x * 0.8; // Reduce sensitivity for inertia too
                panY += currentVelocity.y * 0.8;
                
                // Apply friction
                currentVelocity.x *= friction;
                currentVelocity.y *= friction;
                
                updateTransform();
                
                // Continue animation if velocity is still significant
                const velocityMagnitude = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);
                if (velocityMagnitude > minVelocity) {
                    inertiaAnimation = requestAnimationFrame(animate);
                } else {
                    inertiaAnimation = null;
                }
            }
            
            animate();
        }

        let isUpdating = false;
        
        function handleWheel(e) {
            e.preventDefault();
            
            // Throttle updates for performance
            if (isUpdating) return;
            isUpdating = true;
            
            // Stop inertia when user starts zooming
            if (inertiaAnimation) {
                cancelAnimationFrame(inertiaAnimation);
                inertiaAnimation = null;
            }
            
            // Smooth zoom with smaller increments
            const zoomSensitivity = 0.05; // Slightly increased for responsiveness
            const delta = e.deltaY > 0 ? -zoomSensitivity : zoomSensitivity;
            const newZoom = Math.max(0.1, Math.min(5, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // Zoom towards mouse position
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scaleChange = newZoom / currentZoom;
                panX = mouseX - (mouseX - panX) * scaleChange;
                panY = mouseY - (mouseY - panY) * scaleChange;
                
                currentZoom = newZoom;
                updateTransform();
                updateZoomIndicator();
            }
            
            // Reset throttle after frame
            requestAnimationFrame(() => {
                isUpdating = false;
            });
        }

        function updateTransform() {
            requestAnimationFrame(() => {
                const transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
                surface.style.transform = transform;
            });
        }

        function updateZoomIndicator() {
            // Zoom indicator functionality removed for simplicity
        }

        // Auto-position camera for normal view
        function autoPositionCamera() {
            // Set to normal 100% zoom, centered
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            currentZoom = 1.0; // Always normal zoom
            panX = 0; // Always centered
            panY = 0; // Always centered
            
            // Apply transform
            updateTransform();
            
            console.log(`📐 Camera positioned: normal view (100% zoom)`);
        }

        function resetZoom() {
            // Always reset to normal view
            autoPositionCamera();
        }

        function zoomIn() {
            // Zoom functionality disabled - always keep normal view
            autoPositionCamera();
        }

        function zoomOut() {
            // Zoom functionality disabled - always keep normal view
            autoPositionCamera();
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                processImageFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                processImageFile(file);
            }
        }

        function handlePaste(e) {
            // Only handle paste if we're not in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            const clipboardData = e.clipboardData || window.clipboardData;
            const items = clipboardData.items;

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                
                // Check if the item is an image
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault(); // Prevent default paste behavior
                    
                    const file = item.getAsFile();
                    if (file) {
                        console.log('📋 Image pasted from clipboard:', file.name || 'clipboard-image', file.type);
                        processImageFile(file);
                    }
                    break;
                }
            }
        }

        async function processImageFile(file) {
            // Find the upload container - prioritize inline container
            let uploadContainer = document.getElementById('uploadContainerInline');
            let isInlineUpload = true;
            
            // Fallback to original containers if inline doesn't exist
            if (!uploadContainer) {
                uploadContainer = document.getElementById('uploadZone');
                isInlineUpload = false;
            }
            
            if (!uploadContainer) {
                uploadContainer = document.querySelector('.upload-box .element-content');
                isInlineUpload = false;
            }
            
            if (!uploadContainer) {
                console.error('Could not find upload container');
                return;
            }
            
            console.log('📤 Processing image file, inline upload:', isInlineUpload);
            
            // Show loading state
            if (isInlineUpload) {
                uploadContainer.style.opacity = '0.7';
            } else {
                // Add loading state to the upload box
                const uploadBox = uploadContainer.closest('.upload-box');
                if (uploadBox) uploadBox.classList.add('loading');
            }
            
            try {
                // Hide empty state on first upload
                if (isFirstUpload) {
                    const emptyState = document.getElementById('emptyState');
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                }
                
                // Clear previous session state when loading new image
                sessionResults = [];
                totalKonceptRows = 3;
                customKonceptCount = 0;
                
                // If this was a shared session, create a new session for the new image
                if (isSharedSession) {
                    isSharedSession = false;
                    currentSessionId = generateSessionId();
                    window.history.pushState({}, '', `/session/${currentSessionId}`);
                    console.log('🔄 New session created for image change:', currentSessionId);
                }
                
                // Reset any ongoing operations
                // (Add any cleanup for running processes here if needed)
                console.log('🔄 Resetting session state for new image');
                
                // Clear existing results from the grid (but preserve structure)
                const rightSection = document.getElementById('rightSection');
                if (rightSection) {
                    // Only clear result elements, not the entire section
                    const resultElements = rightSection.querySelectorAll('.canvas-element:not(.upload-box)');
                    resultElements.forEach(element => element.remove());
                }
                
                // Clear caption container
                const captionContainer = document.querySelector('.caption-container');
                if (captionContainer) {
                    captionContainer.innerHTML = '';
                }
                
                
                // Store the base64 data for later use
                currentImageBase64 = await fileToBase64(file);
                
                // Start instant upload to server for better responsiveness
                console.log('⬆️ Starting instant image upload...');
                if (isInlineUpload) {
                    uploadContainer.style.opacity = '0.5';
                } else {
                    const uploadBox = uploadContainer.closest('.upload-box');
                    if (uploadBox) uploadBox.classList.add('upload-loading');
                }
                
                try {
                    // Removed pre-upload - not needed for current implementation
                    console.log('✅ Image processing ready');
                    
                    // Add success indicator
                    setTimeout(() => {
                        if (isInlineUpload) {
                            uploadContainer.style.opacity = '1';
                        } else {
                            const uploadBox = uploadContainer.closest('.upload-box');
                            if (uploadBox) {
                                uploadBox.classList.remove('upload-loading');
                                uploadBox.classList.add('upload-success');
                            }
                        }
                    }, 500);
                    
                } catch (error) {
                    // Silently handle pre-upload failures - this is expected since the endpoint doesn't exist yet
                    // Remove loading state but continue - fallback to original behavior
                    if (isInlineUpload) {
                        uploadContainer.style.opacity = '1';
                    } else {
                        const uploadBox = uploadContainer.closest('.upload-box');
                        if (uploadBox) uploadBox.classList.remove('upload-loading');
                    }
                }
                
                // Create image preview in upload box
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    
                    // Show image at natural size within fixed upload box
                    img.onload = () => {
                        // Style the image to fit within the fixed upload box
                        img.className = 'image-preview';
                        img.style.cursor = 'zoom-in';
                        
                        // Add click handler for image expansion
                        img.onclick = (e) => {
                            e.stopPropagation();
                            const promptId = storePrompt('Source image for AI transformation');
                            openImageModal(img.src, 'Original Upload', promptId);
                        };
                        
                        if (isInlineUpload) {
                            // For inline upload, update the upload zone to show the image and add generate button
                            const uploadZoneInline = uploadContainer.querySelector('.upload-zone-inline');
                            if (uploadZoneInline) {
                                uploadZoneInline.innerHTML = '';
                                
                                // Create compact image preview
                                const imagePreview = document.createElement('div');
                                imagePreview.className = 'inline-image-preview';
                                imagePreview.style.cssText = `
                                    display: flex;
                                    align-items: center;
                                    gap: 12px;
                                    padding: 8px;
                                `;
                                
                                // Smaller image thumbnail
                                const imgThumb = img.cloneNode();
                                imgThumb.style.cssText = `
                                    width: 40px;
                                    height: 40px;
                                    object-fit: cover;
                                    border-radius: 2px;
                                    border: 1px solid #5A7A70;
                                `;
                                
                                // Generate button
                                const generateBtn = document.createElement('button');
                                generateBtn.className = 'generate-btn-inline';
                                generateBtn.innerHTML = 'GENERATE';
                                generateBtn.style.cssText = `
                                    background: #5A7A70;
                                    color: #FFFFFF;
                                    border: 1px solid #B8C5C0;
                                    padding: 8px 16px;
                                    border-radius: 2px;
                                    font-size: 11px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    text-transform: uppercase;
                                    letter-spacing: 0.1em;
                                    font-family: inherit;
                                    flex: 1;
                                `;
                                
                                generateBtn.onclick = (e) => {
                                    e.stopPropagation();
                                    const numImagesInput = document.getElementById('numImagesInputInline');
                                    const numImages = 12;
                                    console.log('🎯 Inline GENERATE clicked, starting autoplay with', numImages, 'images...');
                                    
                                    generateBtn.innerHTML = 'GENERATING...';
                                    generateBtn.disabled = true;
                                    
                                    setTimeout(() => {
                                        autoplaySequence(numImages);
                                    }, 300);
                                };
                                
                                // Auto-start generation on first upload
                                if (isFirstUpload) {
                                    console.log('🎯 First upload detected, auto-starting generation...');
                                    generateBtn.innerHTML = 'GENERATING...';
                                    generateBtn.disabled = true;
                                    isFirstUpload = false;
                                    
                                    setTimeout(() => {
                                        autoplaySequence(12);
                                    }, 500);
                                }
                                
                                imagePreview.appendChild(imgThumb);
                                imagePreview.appendChild(generateBtn);
                                uploadZoneInline.appendChild(imagePreview);
                            }
                        } else {
                            // Original upload container logic
                            uploadContainer.innerHTML = '';
                            
                            // Create image container
                            const imageContainer = document.createElement('div');
                            imageContainer.className = 'image-container';
                            imageContainer.appendChild(img);
                            
                            // Create start button outside of clickable area
                            const startButton = document.createElement('button');
                            startButton.className = 'start-button';
                            startButton.innerHTML = 'Generate';
                            startButton.onclick = (e) => {
                                e.stopPropagation();
                                const numImagesInput = document.getElementById('numImagesInputInline');
                                const numImages = 12;
                                console.log('🎯 KOMPOSER button clicked, starting autoplay with', numImages, 'images...');
                                
                                // Add immediate loading feedback
                                startButton.classList.add('generating');
                                startButton.innerHTML = 'Generating...';
                                startButton.disabled = true;
                                
                                // Hide button after brief feedback
                                setTimeout(() => {
                                    startButton.style.display = 'none';
                                    autoplaySequence(numImages);
                                }, 300);
                            };
                            
                            // Ensure button is enabled and clickable
                            startButton.disabled = false;
                            startButton.style.pointerEvents = 'auto';
                            console.log('✅ KOMPOSER button created and ready to click');
                            
                            // Create change image button
                            const changeButton = document.createElement('button');
                            changeButton.className = 'change-button';
                            changeButton.innerHTML = '🔄 Change Image';
                            changeButton.onclick = (e) => {
                                e.stopPropagation();
                                const fileInput = document.getElementById('fileInput') || document.getElementById('fileInputInline');
                                if (fileInput) fileInput.click();
                            };
                            
                            // Add elements to upload container
                            uploadContainer.appendChild(imageContainer);
                            uploadContainer.appendChild(startButton);
                            uploadContainer.appendChild(changeButton);
                            
                            // Auto-start generation on first upload
                            if (isFirstUpload) {
                                console.log('🎯 First upload detected, auto-starting generation...');
                                startButton.classList.add('generating');
                                startButton.innerHTML = 'Generating...';
                                startButton.disabled = true;
                                isFirstUpload = false;
                                
                                setTimeout(() => {
                                    startButton.style.display = 'none';
                                    autoplaySequence(12);
                                }, 500);
                            }
                        }
                        
                        // Remove loading state
                        uploadContainer.style.opacity = '1';
                        
                        // Add original image to seed history
                        if (isInlineUpload) {
                            clearSeedHistory(); // Clear any existing history for new uploads
                            addToSeedHistory(img.src, 'Original Upload', true);
                        }
                        
                        console.log(`📏 Upload image loaded: ${img.naturalWidth}x${img.naturalHeight}`);
                    };
                };
                reader.readAsDataURL(file);
                
            } catch (error) {
                console.error('Error processing image:', error);
                
                // Remove loading state on error
                if (isInlineUpload) {
                    uploadContainer.style.opacity = '1';
                } else {
                    const uploadBox = uploadContainer.closest('.upload-box');
                    if (uploadBox) uploadBox.classList.remove('loading');
                }
                
                alert('Error processing image. Please try again.');
            }
        }
        
        async function autoplaySequence(NUM_IMAGES = 8) {
            console.log('🎬 Starting autoplay sequence...');
            
            // Step 1: Create immediate skeleton loading tiles for better UX
            console.log('📏 Creating immediate skeleton tiles...');
            createImmediateSkeletonTiles(NUM_IMAGES);
            
            // Skip createBlankLayout - keep skeleton tiles until images start loading
            
            // Step 2: Start AI analysis
            console.log('🤖 Analyzing image with AI...');
            console.log('Current image base64 length:', currentImageBase64?.length || 'undefined');
            
            try {
                //const analysisResult = await analyzeImageWithMistral(currentImageBase64);
                //console.log('🎯 Analysis result:', analysisResult);
                
                // Step 3: Immediately show caption while generating images
                //fillCaptionBox(analysisResult.caption);
                
                // Step 4: Request prompts for all images at once
                console.log(`📝 Requesting ${NUM_IMAGES} prompts from backend...`);
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        count: NUM_IMAGES
                    })
                });
                let prompts = [];
                if (promptResponse.ok) {
                    const promptData = await promptResponse.json();
                    prompts = promptData.prompts || [];
                }
                if (prompts.length < NUM_IMAGES) {
                    // Fallback: fill with generic prompts if not enough
                    while (prompts.length < NUM_IMAGES) {
                        prompts.push(`Transform the image in a wild, creative way #${prompts.length + 1}.`);
                    }
                }
                console.log(`✅ Received ${prompts.length} prompts, starting image generation...`);
                
                // Step 5: Generate all images in parallel using the prompts
                const promises = [];
                let completedCount = 0;
                // Find both types of generate buttons so we can update them later
                const startButton = document.querySelector('.start-button');
                const inlineGenerateBtn = document.querySelector('.generate-btn-inline');
                for (let i = 0; i < NUM_IMAGES; i++) {
                    updateCardLoading(i + 1, `Generating transformation...`);
                    const promise = generateSingleCardImageWithPrompt(i + 1, prompts[i])
                        .finally(() => {
                            completedCount++;
                            if (completedCount === NUM_IMAGES) {
                                // Update original start button if it exists
                                if (startButton) {
                                    startButton.style.display = '';
                                    startButton.innerHTML = 'Change Image';
                                    startButton.classList.remove('generating');
                                    startButton.disabled = false;
                                    startButton.onclick = (e) => {
                                        e.stopPropagation();
                                        const fileInput = document.getElementById('fileInput') || document.getElementById('fileInputInline');
                                        if (fileInput) fileInput.click();
                                    };
                                    
                                    // Add regenerate button next to change image button
                                    const existingRegenBtn = startButton.parentNode.querySelector('.regenerate-button');
                                    if (!existingRegenBtn) {
                                        const regenerateButton = document.createElement('button');
                                        regenerateButton.className = 'regenerate-button';
                                        regenerateButton.innerHTML = '🔄 Regenerate';
                                        regenerateButton.onclick = (e) => {
                                            e.stopPropagation();
                                            const numImagesInput = document.getElementById('numImagesInputInline');
                                            const numImages = 12;
                                            console.log('🔄 Regenerate clicked, starting new generation with', numImages, 'images...');
                                            
                                            regenerateButton.innerHTML = '🔄 Regenerating...';
                                            regenerateButton.disabled = true;
                                            startButton.style.display = 'none';
                                            
                                            setTimeout(() => {
                                                autoplaySequence(numImages);
                                            }, 300);
                                        };
                                        startButton.parentNode.appendChild(regenerateButton);
                                    }
                                }
                                // Update inline generate button if it exists
                                if (inlineGenerateBtn) {
                                    inlineGenerateBtn.innerHTML = 'CHANGE IMAGE';
                                    inlineGenerateBtn.disabled = false;
                                    inlineGenerateBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        const fileInput = document.getElementById('fileInputInline');
                                        if (fileInput) fileInput.click();
                                    };
                                    
                                    // Add regenerate button next to change image button in inline version
                                    const existingInlineRegenBtn = inlineGenerateBtn.parentNode.querySelector('.regenerate-btn-inline');
                                    if (!existingInlineRegenBtn) {
                                        const regenerateBtnInline = document.createElement('button');
                                        regenerateBtnInline.className = 'regenerate-btn-inline';
                                        regenerateBtnInline.innerHTML = '🔄';
                                        regenerateBtnInline.style.cssText = `
                                            background: #5A7A70;
                                            color: #FFFFFF;
                                            border: 1px solid #B8C5C0;
                                            padding: 8px 12px;
                                            border-radius: 2px;
                                            font-size: 11px;
                                            font-weight: 600;
                                            cursor: pointer;
                                            text-transform: uppercase;
                                            letter-spacing: 0.1em;
                                            font-family: inherit;
                                            margin-left: 8px;
                                        `;
                                        regenerateBtnInline.onclick = (e) => {
                                            e.stopPropagation();
                                            const numImagesInput = document.getElementById('numImagesInputInline');
                                            const numImages = 12;
                                            console.log('🔄 Inline regenerate clicked, starting new generation with', numImages, 'images...');
                                            
                                            regenerateBtnInline.innerHTML = '⏳';
                                            regenerateBtnInline.disabled = true;
                                            inlineGenerateBtn.innerHTML = 'GENERATING...';
                                            inlineGenerateBtn.disabled = true;
                                            
                                            setTimeout(() => {
                                                autoplaySequence(numImages);
                                            }, 300);
                                        };
                                        inlineGenerateBtn.parentNode.appendChild(regenerateBtnInline);
                                    }
                                }
                            }
                        });
                    promises.push(promise);
                    await animatedDelay(25);
                }
                console.log('✨ All image generations started in parallel!');
                // Don't wait for all to complete - let them finish individually
            } catch (error) {
                console.error('❌ Error in autoplay sequence:', error);
                // Show error message
                const rightSection = document.querySelector('.generations-section');
                if (rightSection) {
                    rightSection.innerHTML = `
                        <div class="error-card">
                            <h3>Analysis Failed</h3>
                            <p>Unable to analyze image. Please try again.</p>
                        </div>
                    `;
                }
                // Also show the start button again on error
                const startButton = document.querySelector('.start-button');
                if (startButton) startButton.style.display = '';
            }
        }
        
        async function animatedDelay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createImmediateSkeletonTiles(numImages) {
            console.log(`🏗️ Creating ${numImages} immediate skeleton tiles...`);
            
            const rightSection = document.querySelector('.generations-section');
            if (!rightSection) return;
            
            // Clear existing content
            rightSection.innerHTML = '';
            
            // Create skeleton tiles immediately
            for (let i = 0; i < numImages; i++) {
                const skeletonTile = document.createElement('div');
                skeletonTile.className = 'skeleton-tile';
                skeletonTile.id = `skeleton-${i}`;
                rightSection.appendChild(skeletonTile);
            }
            
            console.log(`✅ Created ${numImages} skeleton loading tiles`);
        }

        function createBlankLayout() {
            console.log('🎨 Creating responsive image card layout...');
            
            const rightSection = document.querySelector('.generations-section');
            if (!rightSection) return;
            
            // Clear skeleton tiles and prepare for actual image cards
            rightSection.innerHTML = '';
            
        }
        
        function createAddKonceptRow(rightSection) {
            // Calculate the next available row (each koncept now takes 2 rows: header + images)
            const nextRow = (totalKonceptRows * 2) + 1;
            
            console.log(`Creating add-koncept row at grid row ${nextRow} (totalKonceptRows: ${totalKonceptRows})`);
            
            // Create the add koncept label (clickable) - spans all columns like other koncept headers
            const addKonceptLabel = document.createElement('div');
            addKonceptLabel.className = 'add-koncept-label';
            addKonceptLabel.id = 'addKonceptLabel';
            addKonceptLabel.style.gridColumn = '1 / -1';
            addKonceptLabel.style.gridRow = nextRow.toString();
            addKonceptLabel.innerHTML = '+ Add Custom Koncept';
            addKonceptLabel.onclick = () => showCustomKonceptInput();
            rightSection.appendChild(addKonceptLabel);
            
            // Create 4 empty boxes for the row below the header
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.createElement('div');
                emptyBox.className = 'add-koncept-empty-box';
                emptyBox.id = `add-koncept-empty-${i}`;
                emptyBox.style.gridColumn = (i + 1).toString();
                emptyBox.style.gridRow = (nextRow + 1).toString();
                emptyBox.innerHTML = '...';
                rightSection.appendChild(emptyBox);
            }
            
            console.log(`✅ Add-koncept row created at rows ${nextRow} and ${nextRow + 1}`);
        }

        function fillCaptionBox(caption) {
            console.log('🔄 Filling caption box with:', caption.substring(0, 50) + '...');
            
            // Always create/recreate caption box to ensure it shows up immediately
            const captionContainer = document.querySelector('.caption-container');
            if (captionContainer) {
                // Clear any existing content first
                captionContainer.innerHTML = '';
                const captionElement = document.createElement('div');
                captionElement.className = 'canvas-element caption-box';
                captionElement.id = 'caption-box';
                captionElement.innerHTML = `
                    <div class="element-header">🔍 AI ANALYSIS</div>
                    <div class="element-content">
                        <div class="caption-text">${caption}</div>
                    </div>
                `;
                captionContainer.appendChild(captionElement);
                console.log('✅ Caption box created and filled immediately');
            } else {
                console.error('❌ Caption container not found');
            }
        }

        function fillKonceptLabels(koncepts) {
            console.log('🔄 Filling koncept labels with:', koncepts);
            for (let i = 0; i < 3; i++) {
                const konceptLabel = document.getElementById(`koncept-label-${i}`);
                
                if (konceptLabel) {
                    const konceptName = koncepts[i] || `creative-${i}`;
                    
                    // Create editable koncept label
                    konceptLabel.innerHTML = `
                        <span class="koncept-text" onclick="editKoncept(${i})">${konceptName.toUpperCase()}</span>
                    `;
                    
                    // Store the current koncept name
                    konceptLabel.dataset.koncept = konceptName;
                    
                    console.log(`✅ Updated koncept ${i}: ${konceptName}`);
                } else {
                    console.error(`❌ Koncept label ${i} not found`);
                }
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Compress if image is too large
                    const maxWidth = 2048;
                    const maxHeight = 2048;
                    const quality = 0.8;
                    
                    let { width, height } = img;
                    
                    // Calculate new dimensions if resizing needed
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width = Math.floor(width * ratio);
                        height = Math.floor(height * ratio);
                        console.log(`📏 Resizing image from ${img.width}x${img.height} to ${width}x${height}`);
                    }
                    
                    // Create canvas and compress
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw and compress
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    const base64 = compressedDataUrl.split(',')[1];
                    
                    console.log(`📦 Compressed image: ${base64.length} characters (${(base64.length/1024/1024*3/4).toFixed(1)}MB)`);
                    resolve(base64);
                };
                img.onerror = reject;
                
                // Load image for compression
                const reader = new FileReader();
                reader.onload = (e) => img.src = e.target.result;
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Hilarious random elements to combine with concepts
        const hilariousElements = [
            'but holding puppies',
            'while eating spaghetti',
            'but made of marshmallows',
            'riding a unicorn',
            'wearing a banana costume',
            'surrounded by rubber ducks',
            'but they\'re actually a cat',
            'made entirely of glitter',
            'but tiny and living in a teacup',
            'while juggling pineapples',
            'wearing rainbow socks',
            'but they\'re secretly a robot',
            'covered in post-it notes',
            'holding a very confused chicken',
            'made of jello',
            'wearing a crown of broccoli',
            'but they\'re floating',
            'surrounded by flying pizza slices',
            'wearing mismatched shoes',
            'but everything is backwards',
            'holding a magic spoon',
            'made of clouds',
            'wearing a cape of lettuce',
            'but they\'re upside down',
            'surrounded by dancing pickles',
            'wearing a hat made of cheese',
            'but they\'re transparent',
            'holding a tiny elephant',
            'made of bubble wrap',
            'wearing polka dot everything'
        ];

        function getRandomHilariousElement() {
            return hilariousElements[Math.floor(Math.random() * hilariousElements.length)];
        }

        async function analyzeImageWithMistral(base64Data) {
            try {
                const response = await fetch('/api/analyze-vibes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64Data })
                });

                if (!response.ok) throw new Error('Analysis failed');

                const data = await response.json();
                
                // Add hilarious elements to each vibe, but clean them first
                const enhancedVibes = (data.vibes || ['creative', 'unique', 'interesting']).map(vibe => {
                    // Clean the vibe by removing numbers, asterisks, and taking first few words
                    const cleanVibe = vibe
                        .replace(/^\d+\.\s*\**/g, '') // Remove "1. **" prefix
                        .replace(/\*\*/g, '') // Remove ** markdown
                        .replace(/[:]/g, '') // Remove colons
                        .split(/[,.\s]+/) // Split on punctuation and spaces
                        .filter(word => word.length > 2) // Keep meaningful words
                        .slice(0, 2) // Take first 2 words max
                        .join('-'); // Join with dashes
                    
                    return `${cleanVibe} ${getRandomHilariousElement()}`;
                });
                
                return {
                    caption: data.description || "Image analyzed successfully",
                    vibes: enhancedVibes
                };
            } catch (error) {
                console.error('Mistral analysis error:', error);
                return {
                    caption: "Could not analyze image with AI",
                    vibes: [
                        `mysterious ${getRandomHilariousElement()}`, 
                        `creative ${getRandomHilariousElement()}`, 
                        `unique ${getRandomHilariousElement()}`
                    ]
                };
            }
        }

        function createCaptionBox(caption, x, y) {
            const captionBox = createElement('caption', `
                <div class="element-header">
                    🤖 AI Analysis
                </div>
                <div class="element-content">
                    <div class="caption-text">${caption}</div>
                </div>
            `, x, y);

            // Add entrance animation
            captionBox.element.style.opacity = '0';
            captionBox.element.style.transform = 'translateX(-50px) scale(0.9)';
            
            // Animate in
            setTimeout(() => {
                captionBox.element.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                captionBox.element.style.opacity = '1';
                captionBox.element.style.transform = 'translateX(0) scale(1)';
            }, 100);

            // Grid layout handles positioning automatically
            
            return captionBox;
        }

        function createVibeNodes(vibes, startX, startY) {
            vibes.forEach((vibe, index) => {
                const x = startX;
                const y = startY + (index * 150);
                
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');

                // Grid layout handles positioning automatically

                // Add click handler for vibe generation
                vibeNode.element.addEventListener('click', () => generateVibeImages(vibe, vibeNode.id));
            });
        }
        
        async function createVibeNodesFan(vibes) {
            // const captionElement = elements.find(el => el.type === 'caption'); // Legacy - elements array no longer used
            const captionX = 500; // Default position
            const captionY = 200; // Default position
            
            const vibeNodes = [];
            const vibeSpacing = 180; // Vertical spacing between vibes  
            const vibeXOffset = 400; // Horizontal distance from caption
            
            for (let i = 0; i < vibes.length; i++) {
                const vibe = vibes[i];
                
                // Calculate clean vertical layout
                const x = captionX + vibeXOffset;
                const y = captionY + (i * vibeSpacing) - ((vibes.length - 1) * vibeSpacing / 2);
                
                // Create vibe node with animation delay
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');
                
                // Store vibe index for result layout
                vibeNode.vibeIndex = i;
                
                // Add entrance animation
                vibeNode.element.style.opacity = '0';
                vibeNode.element.style.transform = 'scale(0.5)';
                
                // Animate in with delay
                setTimeout(() => {
                    vibeNode.element.style.transition = 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    vibeNode.element.style.opacity = '1';
                    vibeNode.element.style.transform = 'scale(1)';
                }, i * 300);
                
                // Grid layout handles positioning automatically
                
                vibeNodes.push(vibeNode);
            }
            
            return vibeNodes;
        }

        function createElement(type, innerHTML, x, y, extraClass = '') {
            elementIdCounter++;
            const id = `element-${elementIdCounter}`;
            
            const element = document.createElement('div');
            element.id = id;
            element.className = `canvas-element ${type}-box ${extraClass}`;
            element.style.left = x + 'px';
            element.style.top = y + 'px';
            element.innerHTML = innerHTML;
            
            surface.appendChild(element);
            registerElement(id, type);
            
            return { id, element };
        }

        async function generateVibeImages(vibe, vibeNodeId) {
            const vibeElement = document.getElementById(vibeNodeId);
            vibeElement.classList.add('selected');
            
            try {
                // Check if we have the stored image data
                if (!currentImageBase64) {
                    throw new Error('No image available for transformation');
                }
                
                console.log(`Generating ${vibe} prompts...`);
                
                // Generate vibe-specific prompts using Mistral
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        vibe: vibe 
                    })
                });
                
                if (!promptResponse.ok) {
                    throw new Error('Failed to generate vibe prompts');
                }
                
                const promptData = await promptResponse.json();
                const prompts = promptData.prompts || [];
                
                console.log(`Generated ${prompts.length} prompts for ${vibe}:`, prompts);
                
                // Create result boxes and generate images
                const baseX = parseInt(vibeElement.style.left) + 300;
                const baseY = parseInt(vibeElement.style.top);
                
                for (let i = 0; i < Math.min(4, prompts.length); i++) {
                    const prompt = prompts[i];
                    
                    const resultBox = createElement('result', `
                        <div class="element-header">
                            🎨 ${vibe.toUpperCase()} #${i + 1}
                        </div>
                        <div class="element-content">
                            <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                                Generating...
                            </div>
                            <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                        </div>
                    `, baseX + (i * 280), baseY + (i * 100));

                    // Grid layout handles positioning automatically
                    
                    // Generate image for this prompt
                    generateSingleVibeImage(prompt, resultBox.id, vibe, i + 1);
                }
                
            } catch (error) {
                console.error('Error generating vibe images:', error);
                alert(`Error generating ${vibe} images: ${error.message}`);
            } finally {
                vibeElement.classList.remove('selected');
            }
        }
        
        // New function to generate a single image for the card layout
        async function generateSingleCardImageWithPrompt(iteration, prompt) {
            try {
                console.log(`🎨 Generating card image ${iteration} with prompt: ${prompt.substring(0, 100)}...`);
                // Start generation and get request ID
                const startResponse = await fetch('/api/start-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        input_image: currentImageBase64,
                        steps: 50,
                        guidance: 3.0
                    })
                });
                if (!startResponse.ok) {
                    throw new Error(`Failed to start generation: ${startResponse.status}`);
                }
                const startResult = await startResponse.json();
                if (!startResult.success || !startResult.requestId) {
                    throw new Error('Failed to get request ID');
                }
                console.log(`⏳ Generation started for card ${iteration}, polling for completion...`);
                // Poll for completion
                const result = await pollForCompletion(startResult.requestId, iteration);
                if (result.success && result.imageUrl) {
                    // Update the card with the completed image
                    updateCardComplete(iteration, result.imageUrl, prompt);
                    console.log(`✅ Card ${iteration} completed successfully`);
                    // Save result to session
                    saveResultToSession(0, iteration - 1, {
                        prompt: prompt,
                        imageUrl: result.imageUrl,
                        status: 'completed'
                    });
                } else if (result.moderated) {
                    updateCardError(iteration, 'Content moderated');
                } else {
                    throw new Error('Generation failed');
                }
            } catch (error) {
                console.error(`❌ Error generating card ${iteration}:`, error);
                updateCardError(iteration, error.message.includes('timeout') ? 'Generation timeout' : 'Generation failed');
            }
        }
        
        // Update card with loading state
        function updateCardLoading(iteration, status) {
            const cardId = `image-card-${iteration}`;
            let card = document.getElementById(cardId);
            
            const rightSection = document.querySelector('.generations-section');
            if (!rightSection) return;
            
            // Check if we can convert a skeleton tile instead
            const skeletonId = `skeleton-${iteration - 1}`; // iteration is 1-based, skeleton is 0-based
            const skeletonTile = document.getElementById(skeletonId);
            
            if (skeletonTile) {
                // Convert skeleton tile to actual image card
                skeletonTile.id = cardId;
                skeletonTile.className = 'image-card';
                skeletonTile.innerHTML = `
                    <div class="image-card-content">
                        <div class="loading-spinner"></div>
                        <p class="status-text">${status}</p>
                    </div>
                `;
                card = skeletonTile;
            } else if (!card) {
                // Fallback: create new card if skeleton doesn't exist
                const cardHTML = `
                    <div class="image-card" id="${cardId}">
                        <div class="image-card-content">
                            <div class="loading-spinner"></div>
                            <p class="status-text">${status}</p>
                        </div>
                    </div>
                `;
                rightSection.insertAdjacentHTML('beforeend', cardHTML);
                card = document.getElementById(cardId);
            } else {
                // Update existing card
                const content = card.querySelector('.image-card-content');
                if (content) {
                    content.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p class="status-text">${status}</p>
                    `;
                }
            }
        }
        
        // Update card with completed image
        function updateCardComplete(iteration, imageUrl, prompt) {
            const cardId = `image-card-${iteration}`;
            const card = document.getElementById(cardId);
            
            if (!card) return;
            
            const promptId = storePrompt(prompt);
            const content = card.querySelector('.image-card-content');
            
            if (content) {
                content.innerHTML = `
                    <img src="${imageUrl}" class="result-image" 
                         data-prompt-id="${promptId}" 
                         onclick="openImageModal('${imageUrl}', 'Edit ${iteration}', '${promptId}')"
                         style="cursor: zoom-in; position: relative; width: 100%; height: 100%; object-fit: contain;"
                         title="Click to view full size">
                    <div class="use-as-input-icon" 
                         onclick="event.stopPropagation(); useAsInput('${imageUrl}', 'Edit ${iteration}', '${promptId}')"
                         title="Use this image to start a new generation">
                    </div>
                `;
                // Dynamically set aspect ratio after image loads
                const img = content.querySelector('.result-image');
                const remixButton = content.querySelector('.use-as-input-icon');
                
                img.onload = function() {
                    const aspect = img.naturalWidth / img.naturalHeight;
                    // Set aspect-ratio on the outer card for grid alignment
                    card.style.aspectRatio = aspect;
                    card.style.height = '';
                    card.style.minHeight = '';
                    // Force reflow to ensure browser applies new aspect
                    card.offsetHeight;
                    
                    // Ensure REMIX button is visible after image loads
                    setTimeout(ensureRemixButtonsVisible, 100);
                };
            }
            
            // Add to modal images array
            modalImages.push({
                url: imageUrl,
                title: `Edit ${iteration}`,
                promptId: promptId
            });
        }
        
        // Update card with error state
        function updateCardError(iteration, errorMessage) {
            const cardId = `image-card-${iteration}`;
            const card = document.getElementById(cardId);
            
            if (!card) return;
            
            const content = card.querySelector('.image-card-content');
            if (content) {
                content.innerHTML = `
                    <div class="error-state">
                        <p>❌ ${errorMessage}</p>
                    </div>
                `;
            }
        }

        function updateResultProgress(resultBoxId, text) {
            const resultBox = document.getElementById(resultBoxId);
            if (resultBox) {
                const content = resultBox.querySelector('.element-content');
                content.innerHTML = `
                    <div class="blank-result">
                        <div class="blank-image"></div>
                        <div class="progress-text">${text}</div>
                    </div>
                `;
            }
        }
        
        async function createResultBoxesFan(vibe, vibeNodeId, prompts, vibeIndex) {
            const vibeElement = document.getElementById(vibeNodeId);
            const vibeX = parseInt(vibeElement.style.left);
            const vibeY = parseInt(vibeElement.style.top);
            
            const resultBoxes = [];
            const resultSpacing = 300; // Horizontal spacing between results
            const resultXOffset = 280; // Distance from vibe node
            const resultStartX = vibeX + resultXOffset;
            
            // Calculate base Y position for this vibe's row - create elegant staggered layout
            const rowBaseY = vibeY - 30; // Slightly above vibe center for better flow
            
            for (let i = 0; i < Math.min(4, prompts.length); i++) {
                const prompt = prompts[i];
                
                // Create elegant branching layout with slight vertical offsets
                const x = resultStartX + (i * resultSpacing);
                const y = rowBaseY + (i * 15); // Subtle stagger for organic flow
                
                const resultBox = createElement('result', `
                    <div class="element-header">
                        🎨 ${vibe.toUpperCase()} #${i + 1}
                    </div>
                    <div class="element-content">
                        <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                            Generating...
                        </div>
                        <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                    </div>
                `, x, y);
                
                // Add entrance animation
                resultBox.element.style.opacity = '0';
                resultBox.element.style.transform = 'scale(0.8) translateY(20px)';
                
                // Animate in with delay
                setTimeout(() => {
                    resultBox.element.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    resultBox.element.style.opacity = '1';
                    resultBox.element.style.transform = 'scale(1) translateY(0)';
                }, i * 200);
                
                // Add connection with delay
                setTimeout(() => {
                    // Grid layout handles positioning automatically
                }, i * 200 + 100);
                
                resultBoxes.push(resultBox);
            }
            
            return resultBoxes;
        }
        
        async function generateSingleKonceptImage(prompt, resultBoxId, koncept, index, konceptIndex) {
            const resultBox = document.getElementById(resultBoxId);
            
            try {
                console.log(`🎨 Generating image ${index} for ${koncept}:`, prompt);
                
                // Add generating animation
                if (resultBox) {
                    resultBox.classList.add('generating');
                }
                
                // Start generation and get request ID
                const startResponse = await fetch('/api/start-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        input_image: currentImageBase64,
                        steps: 50,
                        guidance: 3.0
                    })
                });
                
                if (!startResponse.ok) {
                    throw new Error(`Failed to start generation: ${startResponse.status}`);
                }
                
                const startResult = await startResponse.json();
                if (!startResult.success || !startResult.requestId) {
                    throw new Error('Failed to get request ID');
                }
                
                console.log(`⏳ Generation started for image ${index}, polling for completion...`);
                
                // Poll for completion
                const result = await pollForCompletion(startResult.requestId, index);
                
                if (result.success && result.imageUrl) {
                    // Update the result box with the generated image
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        const promptId = storePrompt(prompt);
                        content.innerHTML = `
                            <img src="${result.imageUrl}" class="result-image" data-prompt-id="${promptId}" style="
                                cursor: zoom-in;
                                position: relative;
                                width: 100%;
                                height: 100%;
                                object-fit: contain;
                            " onclick="openImageModal('${result.imageUrl}', '${koncept.toUpperCase()} #${index}', '${promptId}')">
                            <div class="use-as-input-icon" 
                                 onclick="event.stopPropagation(); useAsInput('${result.imageUrl}', '${koncept.toUpperCase()} #${index}', '${promptId}')"
                                 title="Use this image to start a new generation">
                            </div>
                        `;
                        
                        // Image is now immediately visible
                        
                        // Success visual feedback
                        resultBox.style.background = '#fff';
                        resultBox.style.color = '#000';
                        
                        console.log(`✅ Image ${index} completed for ${koncept}`);
                        
                        // Save result to session
                        saveResultToSession(konceptIndex, index - 1, {
                            prompt: prompt,
                            imageUrl: result.imageUrl,
                            status: 'completed'
                        });
                    }
                } else if (result.moderated) {
                    // Handle moderated content
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="moderated-result">
                                <div class="progress-text">⚠️ MODERATED</div>
                            </div>
                        `;
                        resultBox.style.background = '#ff6600';
                        resultBox.style.color = '#000';
                    }
                } else {
                    throw new Error('Generation failed');
                }
                
            } catch (error) {
                console.error(`❌ Error generating image ${index} for ${koncept}:`, error);
                
                // Update result box to show error
                if (resultBox) {
                    const content = resultBox.querySelector('.element-content');
                    const errorMessage = error.message.includes('timeout') 
                        ? '❌ TIMEOUT' 
                        : '❌ FAILED';
                    content.innerHTML = `
                        <div class="error-result">
                            <div class="progress-text">${errorMessage}</div>
                        </div>
                    `;
                    resultBox.style.background = '#ff6600';
                    resultBox.style.color = '#000';
                }
            } finally {
                // Remove generating animation
                if (resultBox) {
                    resultBox.classList.remove('generating');
                }
            }
        }

        // Connection functions removed - using CSS Grid layout instead

        // Touch event handlers with inertia support
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseDown({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY, 
                    target: e.target 
                });
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseMove({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY 
                });
            }
        }

        function handleTouchEnd(e) {
            // Touch end should trigger inertia like mouse up
            handleMouseUp(e);
        }

        // Image Modal Functions
        function openImageModal(imageSrc, title, promptId) {
            console.log('🖼️ Opening image modal:', title);
            console.log('🖼️ Image source:', imageSrc);
            console.log('🖼️ Prompt ID:', promptId);
            
            // Get actual prompt text from stored prompts
            const promptText = modalPrompts[promptId] || 'AI generated transformation';
            console.log('🖼️ Prompt text:', promptText);
            
            // Collect all available images for navigation
            collectModalImages();
            console.log('🖼️ Collected modal images:', modalImages.length);
            
            // Find the current image index
            currentModalIndex = modalImages.findIndex(img => img.src === imageSrc);
            if (currentModalIndex === -1) {
                // If not found, add current image and set as current
                modalImages.push({ src: imageSrc, title, prompt: promptText });
                currentModalIndex = modalImages.length - 1;
                console.log('🖼️ Added new image to modal collection');
            }
            console.log('🖼️ Current modal index:', currentModalIndex);
            
            showModalImage(currentModalIndex);
            
            const modal = document.getElementById('imageModal');
            console.log('🖼️ Modal element:', modal);
            if (modal) {
                modal.style.display = 'flex';
                console.log('🖼️ Modal display set to flex');
                
                // Trigger animation after display
                setTimeout(() => {
                    modal.classList.add('show');
                    console.log('🖼️ Modal show class added');
                }, 10);
                
                // Prevent body scrolling
                document.body.style.overflow = 'hidden';
                
                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeImageModal();
                    }
                });
                
                // Add event listeners
                document.addEventListener('keydown', handleModalKeydown);
                document.addEventListener('touchstart', handleModalTouchStart);
                document.addEventListener('touchmove', handleModalTouchMove);
                document.addEventListener('touchend', handleModalTouchEnd);
            } else {
                console.error('🖼️ Modal element not found!');
                return;
            }
        }
        
        function collectModalImages() {
            modalImages = [];
            
            // Add upload image if it exists
            const uploadImage = document.querySelector('.image-preview');
            if (uploadImage && uploadImage.src) {
                modalImages.push({
                    src: uploadImage.src,
                    title: 'Original Upload',
                    prompt: 'Source image for AI transformation'
                });
            }
            
            // Add all generated images
            const resultImages = document.querySelectorAll('.result-image');
            resultImages.forEach((img, index) => {
                if (img.src && img.src !== '') {
                    // Extract vibe info from result box
                    const resultBox = img.closest('.result-box');
                    const header = resultBox ? resultBox.querySelector('.element-header') : null;
                    const title = header ? header.textContent.trim() : `Generated Image ${index + 1}`;
                    
                    // Extract prompt from data attribute
                    let promptText = 'AI generated transformation';
                    const promptId = img.getAttribute('data-prompt-id');
                    if (promptId && modalPrompts[promptId]) {
                        promptText = modalPrompts[promptId];
                    }
                    
                    modalImages.push({
                        src: img.src,
                        title: title,
                        prompt: promptText
                    });
                }
            });
        }
        
        function showModalImage(index) {
            console.log('🖼️ showModalImage called with index:', index, 'of', modalImages.length);
            if (index < 0 || index >= modalImages.length) {
                console.error('🖼️ Invalid modal index:', index);
                return;
            }
            
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalPrompt = document.getElementById('modalPrompt');
            const modalCounter = document.getElementById('modalCounter');
            const modalPrev = document.getElementById('modalPrev');
            const modalNext = document.getElementById('modalNext');
            
            console.log('🖼️ Modal elements found:', {
                image: !!modalImage,
                title: !!modalTitle,
                prompt: !!modalPrompt,
                counter: !!modalCounter
            });
            
            const image = modalImages[index];
            console.log('🖼️ Setting modal image:', image);
            
            if (modalImage) modalImage.src = image.src;
            if (modalTitle) modalTitle.textContent = image.title;
            
            // Show full prompt or fallback message
            const promptText = image.prompt && image.prompt !== 'undefined' && image.prompt.trim() 
                ? image.prompt 
                : 'AI generated transformation';
            
            console.log('📝 Full image object:', image);
            console.log('📝 Prompt text to display:', promptText);
            
            if (modalPrompt) {
                modalPrompt.textContent = promptText;
                console.log('📝 Modal prompt element updated');
            } else {
                console.error('📝 Modal prompt element not found!');
            }
            modalCounter.textContent = `${index + 1} / ${modalImages.length}`;
            
            // Update navigation buttons
            modalPrev.classList.toggle('disabled', index === 0);
            modalNext.classList.toggle('disabled', index === modalImages.length - 1);
            
            currentModalIndex = index;
        }
        
        function navigateModal(direction) {
            const newIndex = currentModalIndex + direction;
            if (newIndex >= 0 && newIndex < modalImages.length) {
                showModalImage(newIndex);
            }
        }
        
        function closeImageModal() {
            console.log('🔒 Closing image modal');
            const modal = document.getElementById('imageModal');
            
            modal.classList.remove('show');
            
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
            
            // Remove event listeners
            document.removeEventListener('keydown', handleModalKeydown);
            document.removeEventListener('touchstart', handleModalTouchStart);
            document.removeEventListener('touchmove', handleModalTouchMove);
            document.removeEventListener('touchend', handleModalTouchEnd);
        }
        
        function handleModalKeydown(e) {
            if (e.key === 'Escape') {
                closeImageModal();
            } else if (e.key === 'ArrowLeft') {
                navigateModal(-1);
            } else if (e.key === 'ArrowRight') {
                navigateModal(1);
            }
        }
        
        // Touch handling for mobile swipe navigation
        let modalTouchStartX = 0;
        let modalTouchStartY = 0;
        
        function handleModalTouchStart(e) {
            if (e.touches.length === 1) {
                modalTouchStartX = e.touches[0].clientX;
                modalTouchStartY = e.touches[0].clientY;
            }
        }
        
        function handleModalTouchMove(e) {
            // Prevent default to avoid scrolling while swiping
            if (e.touches.length === 1) {
                e.preventDefault();
            }
        }
        
        function handleModalTouchEnd(e) {
            if (e.changedTouches.length === 1) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const deltaX = touchEndX - modalTouchStartX;
                const deltaY = touchEndY - modalTouchStartY;
                
                // Check if horizontal swipe is more significant than vertical
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        // Swipe right - go to previous image
                        navigateModal(-1);
                    } else {
                        // Swipe left - go to next image
                        navigateModal(1);
                    }
                }
            }
        }

        // Custom Koncept Functions
        function showAddKonceptButton() {
            const addKonceptContainer = document.getElementById('addKonceptContainer');
            addKonceptContainer.style.display = 'block';
            console.log('🎨 Add Koncept button now visible');
        }
        
        function showCustomKonceptInput() {
            const input = prompt('Enter your custom koncept (e.g., cyberpunk-medieval, neon-zen):');
            
            if (input && input.trim().length >= 3) {
                const customKoncept = input.trim();
                console.log(`🎭 Generating custom koncept: ${customKoncept}`);
                
                generateCustomKonceptDirect(customKoncept);
            } else if (input !== null) {
                alert('Please enter a koncept with at least 3 characters');
            }
        }
        
        async function generateCustomKonceptDirect(customKoncept) {
            try {
                // Increment custom koncept count and total rows
                customKonceptCount++;
                const konceptIndex = totalKonceptRows;
                totalKonceptRows++;
                
                // Replace the empty state row with the new koncept
                replaceAddKonceptRowWithResults(konceptIndex, customKoncept);
                
                // Generate images for the custom koncept
                await autoGenerateKonceptImages(customKoncept, `custom-koncept-${customKonceptCount}`, konceptIndex);
                
                // Add a new empty state row below
                const rightSection = document.getElementById('rightSection');
                createAddKonceptRow(rightSection);
                
                console.log(`✅ Custom koncept "${customKoncept}" generation complete!`);
                
            } catch (error) {
                console.error('❌ Error generating custom koncept:', error);
                alert(`Error generating "${customKoncept}" koncept. Please try again.`);
            }
        }
        
        function replaceAddKonceptRowWithResults(konceptIndex, konceptName) {
            const rightSection = document.getElementById('rightSection');
            
            // Remove the current add koncept row
            const addKonceptLabel = document.getElementById('addKonceptLabel');
            if (addKonceptLabel) addKonceptLabel.remove();
            
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.getElementById(`add-koncept-empty-${i}`);
                if (emptyBox) emptyBox.remove();
            }
            
            // Calculate the row numbers (header and images)
            const headerRow = (konceptIndex * 2) + 1;
            const imagesRow = headerRow + 1;
            
            // Add koncept label header (spans all columns)
            const konceptLabel = document.createElement('div');
            konceptLabel.className = 'koncept-label';
            konceptLabel.id = `koncept-label-${konceptIndex}`;
            konceptLabel.style.gridColumn = '1 / -1';
            konceptLabel.style.gridRow = headerRow;
            konceptLabel.innerHTML = `
                <span class="koncept-text" onclick="editKoncept(${konceptIndex})">${konceptName.toUpperCase()}</span>
            `;
            konceptLabel.dataset.koncept = konceptName;
            rightSection.appendChild(konceptLabel);
            
            // Add 4 result boxes in the row below the header
            for (let resultIndex = 0; resultIndex < 4; resultIndex++) {
                const resultElement = document.createElement('div');
                resultElement.className = 'canvas-element result-box';
                resultElement.id = `result-${konceptIndex}-${resultIndex}`;
                resultElement.style.gridColumn = resultIndex + 1;
                resultElement.style.gridRow = imagesRow;
                resultElement.innerHTML = `
                    <div class="element-header">🎨 RESULT ${resultIndex + 1}</div>
                    <div class="element-content">
                        <div class="blank-result">
                            <div class="blank-image"></div>
                            <div class="progress-text">WAITING...</div>
                        </div>
                    </div>
                `;
                rightSection.appendChild(resultElement);
            }
            
            console.log(`✅ Replaced empty state with koncept row for: ${konceptName} (header: row ${headerRow}, images: row ${imagesRow})`);
        }

        // Session management functions
        function saveResultToSession(konceptIndex, resultIndex, result) {
            if (isSharedSession) return; // Don't save results for shared sessions
            
            // Initialize session results structure if needed
            while (sessionResults.length <= konceptIndex) {
                sessionResults.push([]);
            }
            while (sessionResults[konceptIndex].length <= resultIndex) {
                sessionResults[konceptIndex].push(null);
            }
            
            sessionResults[konceptIndex][resultIndex] = result;
            console.log(`💾 Saved result to session: koncept ${konceptIndex}, result ${resultIndex}`);
            
            // Auto-save session periodically
            debounceSessionSave();
        }
        
        let sessionSaveTimeout;
        function debounceSessionSave() {
            clearTimeout(sessionSaveTimeout);
            sessionSaveTimeout = setTimeout(saveCurrentSession, 2000); // Save after 2 seconds of inactivity
        }
        
        async function saveCurrentSession() {
            if (isSharedSession || !currentImageBase64 || sessionResults.length === 0) return;
            
            try {
                console.log('💾 Saving current session...');
                
                // Flatten session results for API
                const flatResults = [];
                sessionResults.forEach((konceptResults, konceptIndex) => {
                    konceptResults.forEach((result, resultIndex) => {
                        if (result) {
                            flatResults.push(result);
                        }
                    });
                });
                
                if (flatResults.length === 0) return;
                
                // Get current caption from caption box
                let currentCaption = null;
                const captionBox = document.getElementById('caption-box');
                if (captionBox) {
                    const captionText = captionBox.querySelector('.caption-text');
                    if (captionText) {
                        currentCaption = captionText.textContent || captionText.innerText;
                    }
                }
                
                // Get current koncept names
                const konceptNames = [];
                for (let i = 0; i < totalKonceptRows; i++) {
                    const konceptLabel = document.getElementById(`koncept-label-${i}`);
                    if (konceptLabel && konceptLabel.dataset.koncept) {
                        konceptNames.push(konceptLabel.dataset.koncept);
                    }
                }
                
                const response = await fetch('/api/save-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        originalImage: currentImageBase64,
                        results: flatResults,
                        sessionId: currentSessionId,
                        caption: currentCaption,
                        konceptNames: konceptNames
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('✅ Session saved:', data.sessionId);
                    
                    // URL is already updated at session creation, no need to update again
                    
                } else {
                    console.error('❌ Failed to save session');
                }
                
            } catch (error) {
                console.error('❌ Error saving session:', error);
            }
        }
        
        
        
        // Koncept editing and regeneration functions
        function editKoncept(konceptIndex) {
            if (isSharedSession) return; // Don't allow editing in shared sessions
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const currentKoncept = konceptLabel.dataset.koncept || '';
            const konceptText = konceptLabel.querySelector('.koncept-text');
            
            // Create input field
            const input = document.createElement('input');
            input.className = 'koncept-input';
            input.value = currentKoncept;
            input.placeholder = 'Enter koncept...';
            
            // Replace text with input
            konceptText.style.display = 'none';
            konceptLabel.classList.add('editing');
            konceptLabel.insertBefore(input, konceptText);
            
            // Focus and select text
            input.focus();
            input.select();
            
            // Handle save on Enter or blur
            const saveKoncept = () => {
                const newKoncept = input.value.trim();
                if (newKoncept && newKoncept !== currentKoncept) {
                    // Update the koncept
                    konceptLabel.dataset.koncept = newKoncept;
                    konceptText.textContent = newKoncept.toUpperCase();
                    
                    console.log(`🔄 Koncept ${konceptIndex} updated to: ${newKoncept}`);
                    
                    // Auto-regenerate the row with new koncept
                    regenerateKonceptRow(konceptIndex);
                } else {
                    // Revert if no change or empty
                    konceptText.textContent = currentKoncept.toUpperCase();
                }
                
                // Cleanup
                input.remove();
                konceptText.style.display = '';
                konceptLabel.classList.remove('editing');
            };
            
            // Save on Enter
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKoncept();
                }
            });
            
            // Save on blur (click outside)
            input.addEventListener('blur', saveKoncept);
        }
        
        async function regenerateKonceptRow(konceptIndex) {
            if (isSharedSession) return; // Don't allow regeneration in shared sessions
            if (!currentImageBase64) {
                alert('Please upload an image first');
                return;
            }
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const koncept = konceptLabel.dataset.koncept || `koncept-${konceptIndex}`;
            
            console.log(`🔄 Regenerating row ${konceptIndex} with koncept: ${koncept}`);
            
            // Clear existing results in this row
            for (let i = 0; i < 4; i++) {
                const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                if (resultBox) {
                    updateResultProgress(`result-${konceptIndex}-${i}`, 'REGENERATING...');
                }
            }
            
            // Visual feedback - dim the label
            konceptLabel.style.opacity = '0.7';
            
            try {
                // Generate new images for this koncept
                await autoGenerateKonceptImages(koncept, `koncept-${konceptIndex}`, konceptIndex);
                
                console.log(`✅ Row ${konceptIndex} regenerated successfully`);
                
            } catch (error) {
                console.error(`❌ Error regenerating row ${konceptIndex}:`, error);
                alert(`Failed to regenerate ${koncept} row. Please try again.`);
                
                // Show error state
                for (let i = 0; i < 4; i++) {
                    const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="error-result">
                                <div class="progress-text">❌ REGENERATION FAILED</div>
                            </div>
                        `;
                    }
                }
            } finally {
                // Remove animation
                konceptLabel.style.animation = '';
            }
        }
        
        // Start new session function
        function resetApp() {
            // Confirm if user wants to start fresh
            const confirmNew = confirm('Reset the app? This will clear everything and start fresh.');
            
            if (confirmNew) {
                // Generate new session ID
                currentSessionId = generateSessionId();
                
                // Update URL immediately
                window.history.pushState({}, '', `/session/${currentSessionId}`);
                
                // Reset session state
                sessionResults = [];
                isSharedSession = false;
                currentImageBase64 = null;
                clearSeedHistory();
                
                // Clear the interface
                clearWorkspace();
                
                // Reset zoom and position
                autoPositionCamera();
                
                
                console.log('🆕 New session started:', currentSessionId);
            }
        }
        
        // Clear the workspace for new session
        function clearWorkspace() {
            // Reset first upload flag
            isFirstUpload = true;
            
            // Clear right section and restore empty state
            const rightSection = document.getElementById('rightSection');
            if (rightSection) {
                rightSection.innerHTML = `
                    <!-- Empty state -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-content">
                            <div class="empty-state-icon">
                                <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="#B8C5C0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                </svg>
                            </div>
                            <h2 class="empty-state-title">Create Your Edit Tree</h2>
                            <p class="empty-state-description">
                                Upload an image to start creating your sequence of iterative edits. 
                                AI will generate multiple creative edits, and you can branch from any result to explore new directions.
                            </p>
                            <div class="empty-state-steps">
                                <div class="step">
                                    <span class="step-number">1</span>
                                    <span class="step-text">Upload an image below</span>
                                </div>
                                <div class="step">
                                    <span class="step-number">2</span>
                                    <span class="step-text">AI automatically generates 12 creative variations</span>
                                </div>
                                <div class="step">
                                    <span class="step-number">3</span>
                                    <span class="step-text">Click "BRANCH FROM HERE" on any result</span>
                                </div>
                            </div>
                            <div class="empty-state-cta">
                                <button class="cta-button" onclick="document.getElementById('fileInputInline').click()">
                                    GET STARTED
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Clear caption container
            const captionContainer = document.querySelector('.caption-container');
            if (captionContainer) {
                captionContainer.innerHTML = '';
            }
            
            // Reset upload zones
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = '';
                uploadZone.style.opacity = '';
                uploadZone.innerHTML = `
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8e8e93" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="margin-bottom: 16px;">
                        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                        <circle cx="12" cy="13" r="3"></circle>
                    </svg>
                    <div style="font-size: 18px; font-weight: 600; color: #8e8e93; margin-bottom: 6px;">Upload Image</div>
                    <div style="font-size: 14px; color: #666; line-height: 1.4;">Drop or click to start generating</div>
                `;
            }
            
            // Reset inline upload zone
            const uploadZoneInline = document.getElementById('uploadZoneInline');
            if (uploadZoneInline) {
                uploadZoneInline.innerHTML = '<div class="upload-text">Drop, click, or paste to start generating</div>';
            }
            
            // Reset counters
            customKonceptCount = 0;
            totalKonceptRows = 3;
            
            console.log('🧹 Workspace cleared');
        }
        
        // Spawn 12 variations from clicked image for maximum exploration
        async function spawnVariationsFromImage(imageUrl, title, promptId) {
            console.log('🚀 Spawning variations from clicked image:', title);
            
            // Clear current grid
            const rightSection = document.querySelector('.generations-section');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Generate analysis vibes for variation prompts
            const variationVibes = [
                'dramatic', 'ethereal', 'vibrant', 'moody', 'cinematic', 'surreal',
                'minimalist', 'bold', 'dreamy', 'intense', 'elegant', 'gritty',
                'futuristic', 'vintage', 'abstract', 'realistic', 'artistic', 'experimental'
            ];
            
            // Generate 12 variations instantly
            const promises = [];
            for (let i = 1; i <= 12; i++) {
                const vibe = variationVibes[(i - 1) % variationVibes.length];
                
                // Create loading card immediately
                updateCardLoading(i, `Spawning ${vibe} variation...`);
                
                // Start generation with variation prompt
                const variationPrompt = `Transform this image with a ${vibe} aesthetic, maintaining the core subject but exploring new ${vibe} interpretations`;
                const promise = generateImageFromSource(imageUrl, variationPrompt, i);
                promises.push(promise);
                
                // Ultra-fast flow
                await animatedDelay(10);
            }
            
            console.log('✨ All 12 variations spawning in parallel!');
        }
        
        // Generate image from source image (for variations)
        async function generateImageFromSource(sourceImageUrl, prompt, iteration) {
            try {
                // Convert source image to base64 for img2img
                const response = await fetch(sourceImageUrl);
                const blob = await response.blob();
                const base64 = await blobToBase64(blob);
                
                // Generate with img2img
                const result = await generateImageFromPrompt(prompt, base64);
                
                if (result?.imageUrl) {
                    updateCardComplete(iteration, result.imageUrl, prompt);
                } else {
                    updateCardError(iteration, 'Generation failed');
                }
                
            } catch (error) {
                console.error(`❌ Error generating variation ${iteration}:`, error);
                updateCardError(iteration, 'Failed to generate');
            }
        }
        
        
        // Spawn 12 text-only variations (no img2img, avoids CORS)
        async function spawnTextOnlyVariations() {
            console.log('🚀 Spawning 12 text-only variations...');
            
            // Clear current grid
            const rightSection = document.querySelector('.generations-section');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Get current analysis for variation prompts
            const analysisResult = window.currentAnalysis;
            if (!analysisResult?.vibes) {
                console.log('❌ No analysis available for variations');
                return;
            }
            
            // Enhanced variation styles for maximum diversity
            const variationStyles = [
                'photorealistic portrait', 'digital art', 'oil painting', 'watercolor', 
                'pencil sketch', 'cyberpunk style', 'steampunk aesthetic', 'vintage photo',
                'neon noir', 'minimalist design', 'abstract art', 'pop art style',
                'renaissance painting', 'anime style', 'comic book art', 'surreal art',
                'black and white photography', 'fantasy illustration'
            ];
            
            // Generate 12 variations instantly
            const promises = [];
            for (let i = 1; i <= 12; i++) {
                const baseVibe = analysisResult.vibes[(i - 1) % analysisResult.vibes.length];
                const style = variationStyles[(i - 1) % variationStyles.length];
                
                // Create loading card immediately
                updateCardLoading(i, `Creating ${style} variation...`);
                
                // Enhanced prompt combining base analysis with style
                const variationPrompt = `${baseVibe}, rendered as ${style}, high quality, detailed`;
                const promise = generateSingleCardImage(variationPrompt, i);
                promises.push(promise);
                
                // Ultra-fast flow
                await animatedDelay(10);
            }
            
            console.log('✨ All 12 text-only variations spawning in parallel!');
        }

        // Convert image URL to base64 using proxy method
        async function urlToBase64(url) {
            console.log('🔄 Converting URL to base64:', url);
            
            return new Promise((resolve, reject) => {
                // First try fetch method (works better with CORS)
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        console.log('📦 Got blob, size:', blob.size);
                        const reader = new FileReader();
                        reader.onload = function() {
                            const base64 = this.result.split(',')[1];
                            console.log('✅ Converted to base64, length:', base64.length);
                            resolve(base64);
                        };
                        reader.onerror = () => {
                            console.error('❌ FileReader error');
                            reject(new Error('FileReader failed'));
                        };
                        reader.readAsDataURL(blob);
                    })
                    .catch(fetchError => {
                        console.log('⚠️ Fetch failed, trying canvas method:', fetchError.message);
                        
                        // Fallback to canvas method
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        
                        img.onload = function() {
                            try {
                                console.log('🎨 Using canvas method, image size:', this.naturalWidth, 'x', this.naturalHeight);
                                
                                // Create canvas
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                // Set canvas size to image size
                                canvas.width = this.naturalWidth;
                                canvas.height = this.naturalHeight;
                                
                                // Draw image to canvas
                                ctx.drawImage(this, 0, 0);
                                
                                // Convert to base64
                                const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                                const base64 = dataURL.split(',')[1];
                                
                                console.log('✅ Canvas conversion successful, length:', base64.length);
                                resolve(base64);
                            } catch (canvasError) {
                                console.error('❌ Canvas conversion failed:', canvasError);
                                reject(canvasError);
                            }
                        };
                        
                        img.onerror = (imgError) => {
                            console.error('❌ Image load failed:', imgError);
                            reject(new Error('Image load failed'));
                        };
                        
                        // Try to load the image
                        img.src = url;
                    });
            });
        }

        // Use generated image as input for next generation
        async function useAsInput(imageUrl, title, promptId) {
            console.log('🔄 Using generated image as new input:', title);
            
            try {
                // Show loading state immediately
                const uploadContainer = document.getElementById('uploadZone') || document.querySelector('.upload-box .element-content');
                if (uploadContainer) {
                    uploadContainer.classList.add('upload-loading');
                }
                
                // Clear previous session state immediately for better UX
                sessionResults = [];
                totalKonceptRows = 3;
                customKonceptCount = 0;
                
                // Create new session
                if (isSharedSession) {
                    isSharedSession = false;
                    currentSessionId = generateSessionId();
                    window.history.pushState({}, '', `/session/${currentSessionId}`);
                    console.log('🔄 New session created for image switch:', currentSessionId);
                }
                
                // Clear existing results immediately for responsiveness
                const rightSection = document.getElementById('rightSection');
                if (rightSection) {
                    const resultElements = rightSection.querySelectorAll('.canvas-element:not(.upload-box)');
                    resultElements.forEach(element => element.remove());
                }
                
                // Clear caption container
                const captionContainer = document.querySelector('.caption-container');
                if (captionContainer) {
                    captionContainer.innerHTML = '';
                }
                
                
                // Use server endpoint to handle image storage and conversion
                console.log('📤 Requesting server to store and convert generated image...');
                try {
                    const response = await fetch('/api/store-generated-image', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            imageUrl: imageUrl,
                            title: title,
                            sessionId: currentSessionId
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    currentImageBase64 = result.base64;
                    const localImageUrl = result.localUrl; // Use this for display instead of external URL
                    
                    console.log('✅ Image stored and converted successfully, length:', currentImageBase64.length);
                    
                    // Update imageUrl to use local stored version
                    imageUrl = localImageUrl;
                    
                } catch (conversionError) {
                    console.error('❌ Server conversion failed:', conversionError);
                    
                    // Fallback: try client-side conversion (will likely fail due to CORS but worth trying)
                    try {
                        console.log('🔄 Attempting client-side fallback conversion...');
                        currentImageBase64 = await urlToBase64(imageUrl);
                        console.log('✅ Fallback conversion successful');
                    } catch (fallbackError) {
                        console.error('❌ Fallback conversion also failed:', fallbackError);
                        throw new Error('Unable to convert image - server storage required');
                    }
                }
                
                // Update upload container with new image immediately
                if (uploadContainer) {
                    uploadContainer.innerHTML = '';
                    
                    // Create image preview using the original URL
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.className = 'image-preview';
                    img.style.cursor = 'zoom-in';
                    img.onclick = (e) => {
                        e.stopPropagation();
                        const newPromptId = storePrompt(`${title} (used as input)`);
                        openImageModal(imageUrl, title, newPromptId);
                    };
                    
                    // Create image container
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'image-container';
                    imageContainer.appendChild(img);
                    
                    // Create generate button (will auto-trigger)
                    const startButton = document.createElement('button');
                    startButton.className = 'start-button generating';
                    startButton.innerHTML = 'Generating...';
                    startButton.disabled = true;
                    
                    // Create change button
                    const changeButton = document.createElement('button');
                    changeButton.className = 'change-button';
                    changeButton.innerHTML = '🔄 Change Image';
                    changeButton.onclick = (e) => {
                        e.stopPropagation();
                        const fileInput = document.getElementById('fileInput');
                        fileInput.click();
                    };
                    
                    // Add elements
                    uploadContainer.appendChild(imageContainer);
                    uploadContainer.appendChild(startButton);
                    uploadContainer.appendChild(changeButton);
                    
                    // Remove loading state and add success
                    uploadContainer.classList.remove('upload-loading');
                    uploadContainer.classList.add('upload-success');
                    
                    // Remove success indicator after a moment
                    setTimeout(() => {
                        uploadContainer.classList.remove('upload-success');
                    }, 1000);
                }
                
                // Automatically start generation after a brief delay
                console.log('🚀 Auto-starting generation with looped input...');
                console.log('📊 Using base64 data length:', currentImageBase64?.length || 'undefined');
                
                setTimeout(() => {
                    // Get number of images to generate
                    const numImagesInput = document.getElementById('numImagesInput');
                    const numImages = 12;
                    console.log('🎯 Auto-generating', numImages, 'images from looped input...');
                    
                    // Hide the generate button and start
                    const startButton = uploadContainer?.querySelector('.start-button');
                    if (startButton) {
                        startButton.style.display = 'none';
                    }
                    
                    // Start the generation sequence
                    autoplaySequence(numImages);
                }, 800); // Brief delay to show the image loaded
                
                console.log('✅ Successfully switched to generated image as input');
                
                // Add this iteration to seed history
                addToSeedHistory(imageUrl, title);
                
            } catch (error) {
                console.error('❌ Error using image as input:', error);
                
                // Remove loading state on error
                const uploadContainer = document.getElementById('uploadZone') || document.querySelector('.upload-box .element-content');
                if (uploadContainer) {
                    uploadContainer.classList.remove('upload-loading');
                }
                
                // Show user-friendly error message
                alert('Unable to use this image as input. This may be due to browser security restrictions.');
            }
        }

        // High-velocity keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ignore if typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // Don't interfere with system shortcuts (Cmd+C, Cmd+V, etc.)
            if (e.metaKey || e.ctrlKey) return;
            
            switch(e.key.toLowerCase()) {
                case 'r':
                    e.preventDefault();
                    // Regenerate all images
                    const autoplayBtn = document.querySelector('button[onclick*="autoplaySequence"]');
                    if (autoplayBtn) autoplayBtn.click();
                    break;
                case 'v':
                    e.preventDefault();
                    // Spawn variations using original image
                    console.log('🎨 Spawning 12 text-only variations...');
                    spawnTextOnlyVariations();
                    break;
                case 'c':
                    e.preventDefault();
                    // Clear all images
                    const rightSection = document.querySelector('.generations-section');
                    if (rightSection) rightSection.innerHTML = '';
                    break;
                case ' ':
                    e.preventDefault();
                    // Spacebar to regenerate
                    const autoplayBtn2 = document.querySelector('button[onclick*="autoplaySequence"]');
                    if (autoplayBtn2) autoplayBtn2.click();
                    break;
            }
        });

        // Track if this is the first image upload
        let isFirstUpload = true;
        
        // Function to check if we should show empty state
        function shouldShowEmptyState() {
            const rightSection = document.querySelector('.generations-section');
            const hasGeneratedContent = rightSection && rightSection.children.length > 1; // More than just the empty state
            return isFirstUpload && !hasGeneratedContent;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initWhiteboard);

        // Add persistent number of images input to left-section after upload box
        document.addEventListener('DOMContentLoaded', function() {
            const leftSection = document.querySelector('.left-section');
            if (leftSection && !document.getElementById('numImagesContainer')) {
                const numImagesContainer = document.createElement('div');
                numImagesContainer.id = 'numImagesContainer';
                numImagesContainer.style.display = 'flex';
                numImagesContainer.style.flexDirection = 'column';
                numImagesContainer.style.alignItems = 'center';
                numImagesContainer.style.justifyContent = 'center';
                numImagesContainer.style.margin = '0 0 10px 0';
                numImagesContainer.style.padding = '8px 0 4px 0';
                numImagesContainer.style.background = 'transparent';
                numImagesContainer.style.borderRadius = '8px';
                numImagesContainer.style.boxShadow = 'none';

                const numImagesLabel = document.createElement('label');
                numImagesLabel.textContent = 'Number of Images';
                numImagesLabel.setAttribute('for', 'numImagesInput');
                numImagesLabel.style.fontSize = '13px';
                numImagesLabel.style.fontWeight = '500';
                numImagesLabel.style.marginBottom = '4px';
                numImagesLabel.style.letterSpacing = '0.2px';
                numImagesLabel.style.color = '#1c1c1e';
                numImagesLabel.style.textAlign = 'center';

                const numImagesInput = document.createElement('input');
                numImagesInput.type = 'number';
                numImagesInput.id = 'numImagesInput';
                numImagesInput.value = 12;
                numImagesInput.min = 1;
                numImagesInput.max = 48;
                numImagesInput.style.width = '60px';
                numImagesInput.style.fontSize = '15px';
                numImagesInput.style.textAlign = 'center';
                numImagesInput.style.padding = '4px 8px';
                numImagesInput.style.borderRadius = '5px';
                numImagesInput.style.border = '1px solid #bbb';
                numImagesInput.style.background = '#fff';
                numImagesInput.style.boxShadow = '0 1px 2px rgba(0,0,0,0.01)';
                numImagesInput.style.marginBottom = '0';

                numImagesContainer.appendChild(numImagesLabel);
                numImagesContainer.appendChild(numImagesInput);

                // Insert under the START HERE header, above the upload zone
                const uploadBox = document.querySelector('.upload-box');
                if (uploadBox) {
                    const header = uploadBox.querySelector('.element-header');
                    if (header && header.nextSibling) {
                        uploadBox.insertBefore(numImagesContainer, header.nextSibling);
                    } else {
                        uploadBox.appendChild(numImagesContainer);
                    }
                } else {
                    leftSection.appendChild(numImagesContainer);
                }
            }
        });
    </script>
    <!-- Comic Strip Modal -->
    <div id="comicStripModal" class="comic-strip-modal">
        <div class="comic-strip-content">
            <button class="comic-close-btn" onclick="closeComicStripModal()">×</button>
            
            <div class="comic-strip-header">
                <h2>FLUX.1 Kontext Editing Chain</h2>
                <p>Learn more at <a href="https://bfl.ai/models/flux-kontext" target="_blank" rel="noopener noreferrer">https://bfl.ai/models/flux-kontext</a></p>
            </div>
            
            <div class="comic-strip-sequence" id="comicStripSequence">
                <!-- Comic panels will be generated here -->
            </div>
            
            <div class="comic-strip-controls">
                <button class="comic-control-btn" onclick="downloadComicStrip()">
                    Export Sequence
                </button>
                <button class="comic-control-btn secondary" onclick="closeComicStripModal()">
                    Close
                </button>
            </div>
        </div>
    </div>

</body>
</html>