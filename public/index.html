<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kontext Lab - AI Image Transformation Studio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: #ff6600;
            overflow: hidden;
            height: 100vh;
            color: #000;
        }

        .whiteboard-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
            touch-action: none;
        }

        .whiteboard-container.grabbing {
            cursor: grabbing;
        }

        .canvas-surface {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #ffffff;
            transform-origin: 0 0;
            will-change: transform;
            display: grid;
            grid-template-columns: 20% 80%;
            grid-template-rows: 100%;
            gap: 2px;
            padding: 8px;
        }
        
        /* Mobile layout adjustments */
        @media (max-width: 768px) {
            .canvas-surface {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: 10px;
                padding: 10px;
                overflow-y: auto;
            }
        }

        /* Left Section - Controls and Analysis */
        .left-section {
            background: #ffffff;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto auto 1fr;
            gap: 20px;
            align-items: start;
        }

        /* Right Section - Generations Grid */
        .right-section {
            background: #ffffff;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-auto-rows: auto minmax(450px, auto);
            gap: 16px;
            align-items: start;
            min-height: 100%;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .left-section {
                padding: 16px;
                gap: 16px;
            }
            
            .right-section {
                grid-template-columns: 1fr;
                grid-auto-rows: auto;
                gap: 12px;
                padding: 16px;
            }
        }

        /* Koncept Label for each row - now horizontal header */
        .koncept-label {
            background: #2d2d2d;
            color: #ffffff;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 500;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            align-items: center;
            word-break: break-word;
            cursor: text;
            position: relative;
            grid-column: 1 / -1; /* Span all columns */
            min-height: 48px;
        }
        
        .koncept-label::after {
            content: "✏️ EDIT";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 7px;
            opacity: 0.6;
            background: rgba(255,255,255,0.2);
            padding: 2px 4px;
            border-radius: 1px;
            text-transform: none;
            letter-spacing: 0;
            font-weight: 400;
        }
        
        .koncept-label:hover {
            background: #ff6600;
            color: #ffffff;
        }
        
        .koncept-label.editing {
            background: #ffffff;
            color: #2d2d2d;
        }
        
        /* Mobile koncept labels */
        @media (max-width: 768px) {
            .koncept-label {
                padding: 12px 8px;
                font-size: 8px;
            }
            
            .koncept-label:hover {
                transform: none;
                box-shadow: 2px 2px 0px #fff;
            }
        }
        
        /* Editable koncept input */
        .koncept-input {
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: center;
            width: 100%;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .koncept-input::placeholder {
            color: #666;
            opacity: 0.7;
        }
        
        /* Regenerate button for each row */
        .regenerate-row-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 16px;
            height: 16px;
            background: #ff6600;
            color: #ffffff;
            border-radius: 2px;
            font-size: 8px;
            font-weight: 500;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        
        .regenerate-row-btn::before {
            content: "↻";
            font-size: 10px;
        }
        
        .koncept-label:hover .regenerate-row-btn {
            display: flex;
        }
        
        .regenerate-row-btn:hover {
            background: #2d2d2d;
            color: #ffffff;
        }
        
        /* Mobile regenerate button */
        @media (max-width: 768px) {
            .regenerate-row-btn {
                width: 16px;
                height: 16px;
                font-size: 9px;
                top: -3px;
                right: -3px;
                box-shadow: 1px 1px 0px rgba(0,0,0,0.3);
            }
            
            .regenerate-row-btn::before {
                font-size: 8px;
            }
            
            .regenerate-row-btn:hover {
                transform: none;
            }
        }

        /* Grid Element Base - Swedish Minimalism */
        .canvas-element {
            background: #ffffff;
            border-radius: 2px;
            cursor: pointer;
            user-select: none;
            color: #2d2d2d;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }

        .canvas-element.selected {
            background: #fff;
            color: #000;
            box-shadow: 3px 3px 0px rgba(255,102,0,0.4);
        }

        .canvas-element.dragging {
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        /* Mobile canvas elements */
        @media (max-width: 768px) {
            .canvas-element {
                box-shadow: 2px 2px 0px #fff;
                border-width: 2px;
            }
            
            .canvas-element:hover {
                box-shadow: 2px 2px 0px #fff;
                transform: none;
            }
        }

        /* Left Section Items */
        .title-container {
            grid-area: 1;
        }
        
        .upload-container {
            grid-area: 2;
        }
        
        .caption-container {
            grid-area: 3;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Title Box */
        .title-box {
            width: 100%;
            height: auto;
        }

        .title-text {
            font-size: 16px;
            line-height: 1.2;
            color: #2d2d2d;
            padding: 12px;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .subtitle-text {
            font-size: 11px;
            line-height: 1.4;
            color: #666666;
            padding: 0 12px 12px 12px;
            font-weight: 400;
            text-align: center;
        }
        
        /* Mobile title and subtitle */
        @media (max-width: 768px) {
            .title-text {
                font-size: 16px;
                padding: 12px;
                letter-spacing: 1px;
            }
            
            .subtitle-text {
                font-size: 9px;
                padding: 0 12px 12px 12px;
            }
        }

        /* Add Koncept Button and Input */
        .add-koncept-btn {
            width: 100%;
            background: #f8f8f8;
            color: #2d2d2d;
            border: none;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .add-koncept-btn:hover {
            background: #ff6600;
            color: #ffffff;
        }

        .custom-koncept-input {
            width: 100%;
            background: #f8f8f8;
            color: #2d2d2d;
            border: none;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 400;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            margin-top: 8px;
            outline: none;
            transition: all 0.15s ease;
        }

        .custom-koncept-input::placeholder {
            color: #999999;
        }

        .custom-koncept-input:focus {
            background: #ffffff;
        }

        .generate-custom-btn {
            width: 100%;
            background: #ff6600;
            color: #ffffff;
            border: none;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .generate-custom-btn:hover {
            background: #2d2d2d;
        }

        .generate-custom-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .generate-custom-btn:disabled:hover {
            background: #ff6600;
        }

        /* Empty State Row for Add Custom Koncept */
        .add-koncept-row {
            display: contents;
        }

        .add-koncept-label {
            background: #f8f8f8;
            color: #666666;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 10px;
            font-weight: 500;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            align-items: center;
            word-break: break-word;
            cursor: pointer;
            transition: all 0.15s ease;
            grid-column: 1 / -1; /* Span all columns like koncept headers */
            min-height: 48px;
        }

        .add-koncept-label:hover {
            background: #ff6600;
            color: #ffffff;
        }

        .add-koncept-empty-box {
            background: #fafafa;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999999;
            font-size: 11px;
            font-weight: 400;
            text-align: center;
            height: 100%;
            min-height: 450px;
        }

        /* Right Section - Generation Results (header spans all columns, images below) */
        .grid-koncept-label-0 { grid-column: 1 / -1; grid-row: 1; }
        .grid-result-0-0 { grid-column: 1; grid-row: 2; }
        .grid-result-0-1 { grid-column: 2; grid-row: 2; }
        .grid-result-0-2 { grid-column: 3; grid-row: 2; }
        .grid-result-0-3 { grid-column: 4; grid-row: 2; }
        
        .grid-koncept-label-1 { grid-column: 1 / -1; grid-row: 3; }
        .grid-result-1-0 { grid-column: 1; grid-row: 4; }
        .grid-result-1-1 { grid-column: 2; grid-row: 4; }
        .grid-result-1-2 { grid-column: 3; grid-row: 4; }
        .grid-result-1-3 { grid-column: 4; grid-row: 4; }
        
        .grid-koncept-label-2 { grid-column: 1 / -1; grid-row: 5; }
        .grid-result-2-0 { grid-column: 1; grid-row: 6; }
        .grid-result-2-1 { grid-column: 2; grid-row: 6; }
        .grid-result-2-2 { grid-column: 3; grid-row: 6; }
        .grid-result-2-3 { grid-column: 4; grid-row: 6; }

        /* Element Header - Swedish Style */
        .element-header {
            padding: 8px 12px;
            background: #f5f5f5;
            font-weight: 500;
            font-size: 10px;
            color: #666666;
            display: flex;
            align-items: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 2px 2px 0 0;
        }
        
        /* Mobile element headers */
        @media (max-width: 768px) {
            .element-header {
                padding: 6px 10px;
                font-size: 9px;
                border-bottom-width: 1px;
            }
        }

        .element-content {
            padding: 6px;
        }
        
        .upload-box .element-content {
            padding: 4px;
            height: calc(100% - 40px);
            display: flex;
            flex-direction: column;
        }

        /* Upload Box */
        .upload-box {
            width: 100%;
            height: auto;
            min-height: 200px;
        }

        .upload-zone {
            border: 2px dashed #D1D5DB;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            color: #6B7280;
            background: #F9FAFB;
            cursor: pointer;
            transition: all 0.2s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-sizing: border-box;
        }

        .upload-zone:hover {
            border-color: #ff6600;
            background: #fff;
        }

        .upload-zone.dragover {
            border-color: #ff6600;
            background: #fff;
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: 300;
            color: #999;
        }

        /* Image Preview */
        .image-preview {
            width: 100%;
            object-fit: contain;
            border-radius: 6px;
            margin-bottom: 8px;
            flex-shrink: 0;
            max-width: 100%;
            height: auto;
            max-height: 500px;
        }
        
        /* Image Container */
        .image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        
        .image-container .image-preview {
            margin-bottom: 0;
        }
        
        .result-image-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }
        
        /* Start Button */
        .start-button {
            width: 100%;
            background: #ff6600;
            color: #ffffff;
            border: 1px solid #ff6600;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 6px;
            flex-shrink: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .start-button:hover {
            background: #2d2d2d;
            border-color: #2d2d2d;
        }
        
        .start-button:active {
            background: #1a1a1a;
        }
        
        /* Change Button */
        .change-button {
            width: 100%;
            background: #f8f8f8;
            color: #666666;
            border: none;
            border-radius: 2px;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 4px;
            flex-shrink: 0;
        }
        
        .change-button:hover {
            background: #f0f0f0;
        }

        /* Caption Box */
        .caption-box {
            width: 100%;
            height: 100%;
            min-height: 450px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .caption-box .element-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .caption-text {
            font-size: 13px;
            line-height: 1.5;
            color: #2d2d2d;
            padding: 0;
            font-weight: 400;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .vibe-text {
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 1px;
            color: #fff;
        }

        /* Vibe Node */
        .vibe-node {
            width: 100%;
            height: 80px;
            border-radius: 0;
            background: #000;
            color: #ff6600;
            border: 3px solid #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 11px;
            text-align: center;
            box-shadow: 4px 4px 0px #fff;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .vibe-node:hover {
            background: #ff6600;
            color: #000;
            transform: translate(-1px, -1px);
            box-shadow: 5px 5px 0px #fff;
        }

        .vibe-node.selected {
            opacity: 0.8;
        }


        /* Image Result Box */
        .result-box {
            width: 100%;
            height: 100%;
            min-height: 300px;
        }

        .result-image {
            width: 100%;
            height: calc(100% - 80px);
            min-height: 220px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .result-image-container {
            width: 100%;
            height: calc(100% - 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .result-prompt {
            font-size: 11px;
            color: #6B7280;
            line-height: 1.3;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
        }

        /* Remove connection styling - using grid layout instead */

        
        /* Enhanced entrance animations */
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-100px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes pulseGeneration {
            0%, 100% {
                box-shadow: 0 6px 20px rgba(255, 102, 0, 0.3);
                border-color: #ff6600;
            }
            50% {
                box-shadow: 0 8px 30px rgba(255, 102, 0, 0.5);
                border-color: #ff6600;
            }
        }
        
        .generating {
            animation: pulseGeneration 2s ease-in-out infinite;
        }

        /* Controls */
        .canvas-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .control-btn {
            background: #ffffff;
            border: none;
            border-radius: 2px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.15s ease;
            color: #666666;
        }

        .control-btn:hover {
            background: #ff6600;
            color: #ffffff;
        }
        
        /* Inline home button styling in title header */
        .home-btn-inline {
            background: #f5f5f5;
            border: none;
            border-radius: 2px;
            color: #666666;
            font-size: 10px;
            padding: 4px 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-left: auto;
            outline: none;
            font-weight: 500;
        }
        
        .home-btn-inline::before {
            content: "🏠";
            font-size: 10px;
        }
        
        .home-btn-inline:hover {
            background: rgba(255,255,255,0.9);
            color: #000;
            transform: translate(-1px, -1px);
            box-shadow: 3px 3px 6px rgba(0,0,0,0.2);
        }
        
        .home-btn-inline:active {
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        /* Mobile home button */
        @media (max-width: 768px) {
            .home-btn-inline {
                padding: 3px 5px;
                font-size: 10px;
                box-shadow: 1px 1px 0px #fff;
                border-width: 1px;
            }
            
            .home-btn-inline::before {
                font-size: 8px;
            }
            
            .home-btn-inline:hover {
                transform: none;
                box-shadow: 1px 1px 0px #fff;
            }
        }

        .zoom-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            color: #6B7280;
        }

        /* Teenage Engineering Progress States */
        .progress-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 80px;
        }

        .progress-bar {
            width: 80%;
            height: 4px;
            background: #333;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: #fff;
            animation: progressSlide 2s infinite;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            background: #fff;
            margin-bottom: 8px;
            opacity: 0.7;
        }

        .progress-text {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .blank-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        .blank-image {
            width: 100%;
            height: 140px;
            background: #333;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        .blank-image::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #666;
            transform: translate(-50%, -50%);
            opacity: 0.5;
        }

        @keyframes progressSlide {
            0% { left: -100%; }
            100% { left: 100%; }
        }


        /* Loading States */
        .loading {
            opacity: 0.8;
        }

        /* Hide original canvas section */
        .canvas-section { display: none; }

        /* Image Modal Styles */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: zoom-out;
        }

        .image-modal.show {
            opacity: 1;
        }

        .modal-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .image-modal.show .modal-image {
            transform: scale(1);
        }

        .modal-close {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .modal-info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            backdrop-filter: blur(10px);
        }

        .modal-info h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #ff6600;
        }

        .modal-info p {
            margin: 0;
            font-size: 14px;
            line-height: 1.4;
            opacity: 0.9;
        }

        /* Modal Navigation */
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            user-select: none;
        }

        .modal-nav:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%) scale(1.1);
        }

        .modal-nav.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav.disabled:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1);
        }

        .modal-nav-left {
            left: 30px;
        }

        .modal-nav-right {
            right: 30px;
        }

        .modal-counter {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 8px 16px;
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .whiteboard-container {
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }
            
            .canvas-surface {
                position: static;
                height: auto;
                min-height: 100vh;
            }
            
            /* Mobile koncept grid - single column with koncept above each row */
            .mobile-koncept-row {
                display: grid;
                grid-template-columns: 1fr;
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .mobile-results-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .canvas-element {
                min-height: 120px;
            }
            
            .result-box {
                min-height: 250px;
            }
            
            .result-image {
                height: 180px;
                min-height: 160px;
            }
            
            .element-content {
                padding: 8px;
            }
            
            /* Mobile controls */
            .canvas-controls {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                flex-wrap: wrap;
                justify-content: center;
                max-width: 90vw;
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 9px;
                margin: 2px;
            }
            
            .zoom-indicator {
                bottom: 60px;
                left: 10px;
                font-size: 10px;
                padding: 4px 8px;
            }
            
            /* Mobile upload zone */
            .upload-zone {
                min-height: 100px;
                padding: 15px;
            }
            
            .upload-icon {
                font-size: 20px;
            }
            
            /* Mobile caption box */
            .caption-text {
                font-size: 11px;
                padding: 8px;
            }
            
            /* Touch-friendly sizing */
            .koncept-text {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .canvas-surface {
                padding: 8px;
                gap: 8px;
            }
            
            .left-section, .right-section {
                padding: 12px;
            }
            
            .mobile-results-grid {
                grid-template-columns: 1fr;
            }
            
            .control-btn {
                padding: 6px 10px;
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="whiteboard-container" id="whiteboardContainer">
        <div class="canvas-surface" id="canvasSurface">
            <!-- Left Section - 30% -->
            <div class="left-section">
                <!-- Title Box -->
                <div class="title-container">
                    <div class="canvas-element title-box">
                        <div class="element-header">
                            🧪 EXPERIMENTAL
                            <button class="home-btn-inline" onclick="startNewSession()" title="Start New Session"></button>
                        </div>
                        <div class="element-content">
                            <div class="title-text">Kontext Lab</div>
                            <div class="subtitle-text">A BFL Kontext experiment</div>
                        </div>
                    </div>
                </div>
                
                <!-- Upload Box -->
                <div class="upload-container">
                    <div class="canvas-element upload-box" id="uploadElement">
                        <div class="element-header">
                            📤 UPLOAD IMAGE
                        </div>
                        <div class="element-content">
                            <div class="upload-zone" id="uploadZone">
                                <div class="upload-icon">+</div>
                                <div>Drop image here or click to upload</div>
                                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Caption Box Container -->
                <div class="caption-container">
                    <!-- Caption will be added dynamically -->
                </div>
            </div>
            
            <!-- Right Section - 70% for Generations -->
            <div class="right-section" id="rightSection">
                <!-- Results will be added dynamically -->
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="canvas-controls">
        <button class="control-btn" onclick="autoPositionCamera()">FIT</button>
        <button class="control-btn" onclick="resetZoom()">RESET</button>
        <button class="control-btn" onclick="zoomIn()">+</button>
        <button class="control-btn" onclick="zoomOut()">-</button>
    </div>

    <div class="zoom-indicator" id="zoomIndicator">100%</div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal" style="display: none;">
        <div class="modal-counter" id="modalCounter">1 / 12</div>
        <div class="modal-close" onclick="closeImageModal()">×</div>
        <div class="modal-nav modal-nav-left" id="modalPrev" onclick="navigateModal(-1)">‹</div>
        <div class="modal-nav modal-nav-right" id="modalNext" onclick="navigateModal(1)">›</div>
        <img class="modal-image" id="modalImage" src="" alt="Expanded view">
        <div class="modal-info" id="modalInfo">
            <h3 id="modalTitle">Generation Result</h3>
            <p id="modalPrompt">Prompt will appear here</p>
        </div>
    </div>

    <script>
        // Global state
        let currentZoom = 0.8;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let dragElement = null;
        let dragOffset = { x: 0, y: 0 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let elements = [];
        let connections = [];
        let elementIdCounter = 0;
        let currentImageBase64 = null;
        
        // Modal navigation state
        let modalImages = [];
        let currentModalIndex = 0;
        
        // Custom koncept state
        let customKonceptCount = 0;
        let totalKonceptRows = 3; // Start with 3 default koncepts
        
        // Session management
        let currentSessionId = null;
        let sessionResults = [];
        let isSharedSession = false;

        // Inertia scrolling state
        let velocity = { x: 0, y: 0 };
        let lastPanTime = 0;
        let lastPanPosition = { x: 0, y: 0 };
        let inertiaAnimation = null;
        let panHistory = [];

        // DOM elements
        const container = document.getElementById('whiteboardContainer');
        const surface = document.getElementById('canvasSurface');
        const svg = document.getElementById('connectionSvg');
        const zoomIndicator = document.getElementById('zoomIndicator');
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');

        // Initialize the whiteboard
        function initWhiteboard() {
            setupEventListeners();
            updateZoomIndicator();
            updateTransform(); // Apply initial zoom
            
            // Check if this is a shared session
            checkForSharedSession();
            
            // Auto-position camera for optimal viewing
            autoPositionCamera();
            
            // Handle mobile layout
            handleMobileLayout();
        }
        
        // Handle mobile-specific layout adjustments
        function handleMobileLayout() {
            if (window.innerWidth <= 768) {
                // Disable zoom/pan on mobile
                container.style.overflow = 'auto';
                surface.style.position = 'static';
                surface.style.transform = 'none';
                
                // Hide zoom controls on mobile
                const controls = document.querySelector('.canvas-controls');
                if (controls) {
                    controls.style.display = 'none';
                }
                
                // Hide zoom indicator on mobile
                const zoomIndicator = document.getElementById('zoomIndicator');
                if (zoomIndicator) {
                    zoomIndicator.style.display = 'none';
                }
            }
        }
        
        // Handle window resize for mobile responsiveness
        window.addEventListener('resize', () => {
            handleMobileLayout();
        });
        
        // Check if we're loading a shared session
        function checkForSharedSession() {
            const path = window.location.pathname;
            const sessionMatch = path.match(/^\/session\/([a-f0-9]+)$/);
            
            if (sessionMatch) {
                const sessionId = sessionMatch[1];
                console.log('🔗 Loading shared session:', sessionId);
                loadSharedSession(sessionId);
            } else {
                // Generate new session ID for new sessions
                currentSessionId = generateSessionId();
                console.log('🆕 New session created:', currentSessionId);
                
                // Update URL immediately for new sessions
                window.history.replaceState({}, '', `/session/${currentSessionId}`);
            }
        }
        
        // Generate a random session ID
        function generateSessionId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(8)))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // Load a shared session from the server
        async function loadSharedSession(sessionId) {
            try {
                isSharedSession = true;
                currentSessionId = sessionId;
                
                console.log('📥 Fetching session data...');
                const response = await fetch(`/api/session/${sessionId}`);
                
                if (!response.ok) {
                    throw new Error('Session not found');
                }
                
                const sessionData = await response.json();
                console.log('✅ Session data loaded:', sessionData);
                
                // Load the original image
                if (sessionData.originalImage) {
                    const imageBlob = await fetch(`data:image/jpeg;base64,${sessionData.originalImage}`).then(r => r.blob());
                    const file = new File([imageBlob], 'shared-image.jpg', { type: 'image/jpeg' });
                    await processImageFile(file);
                    
                    // Set the base64 for future operations
                    currentImageBase64 = sessionData.originalImage;
                }
                
                // Load the results
                loadSessionResults(sessionData.results);
                
                // Disable upload for shared sessions
                disableUploadForSharedSession();
                
            } catch (error) {
                console.error('❌ Error loading shared session:', error);
                alert('Could not load shared session. Starting a new session instead.');
                currentSessionId = generateSessionId();
                isSharedSession = false;
            }
        }
        
        // Load session results into the interface
        function loadSessionResults(results) {
            console.log('🔄 Loading session results:', results);
            
            // Create the layout structure
            createBlankLayout();
            
            // Group results by concept (assuming 4 results per concept)
            const concepts = [];
            for (let i = 0; i < results.length; i += 4) {
                concepts.push(results.slice(i, i + 4));
            }
            
            concepts.forEach((conceptResults, conceptIndex) => {
                if (conceptIndex < 3) { // First 3 are the default concepts
                    const konceptLabel = document.getElementById(`koncept-label-${conceptIndex}`);
                    if (konceptLabel) {
                        konceptLabel.innerHTML = `KONCEPT ${conceptIndex + 1}`;
                    }
                    
                    // Fill in the results
                    conceptResults.forEach((result, resultIndex) => {
                        if (result.image) {
                            displaySharedResult(conceptIndex, resultIndex, result);
                        }
                    });
                }
            });
        }
        
        // Display a shared session result
        function displaySharedResult(conceptIndex, resultIndex, result) {
            const resultBoxId = `result-${conceptIndex}-${resultIndex}`;
            const resultBox = document.getElementById(resultBoxId);
            
            if (resultBox && result.image) {
                const content = resultBox.querySelector('.element-content');
                const imageUrl = `data:image/jpeg;base64,${result.image}`;
                
                content.innerHTML = `
                    <div class="result-image-container">
                        <img src="${imageUrl}" class="result-image" style="
                            cursor: zoom-in;
                        " onclick="openImageModal('${imageUrl}', 'KONCEPT ${conceptIndex + 1} #${resultIndex + 1}', '${(result.prompt || '').replace(/'/g, "\\'")}')">
                    </div>
                `;
                
                // Success visual feedback
                resultBox.style.background = '#fff';
                resultBox.style.color = '#000';
            }
        }
        
        // Disable upload functionality for shared sessions
        function disableUploadForSharedSession() {
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = 'none';
                uploadZone.style.opacity = '0.5';
                uploadZone.innerHTML = '<div style="color: #666;">Viewing shared session</div>';
            }
        }

        function setupEventListeners() {
            // Pan and zoom
            container.addEventListener('mousedown', handleMouseDown);
            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Touch events for mobile
            container.addEventListener('touchstart', handleTouchStart);
            container.addEventListener('touchmove', handleTouchMove);
            container.addEventListener('touchend', handleTouchEnd);

            // Upload functionality
            uploadZone.addEventListener('click', () => fileInput.click());
            uploadZone.addEventListener('dragover', handleDragOver);
            uploadZone.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', handleFileSelect);

            // Prevent default drag behavior
            document.addEventListener('dragover', e => e.preventDefault());
            document.addEventListener('drop', e => e.preventDefault());
            
            // Handle window resize to auto-reposition
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only auto-reposition if we have content on screen
                    if (elements.length > 1) { // More than just upload box
                        autoPositionCamera();
                    }
                }, 300); // Debounce resize events
            });
        }

        function registerElement(elementId, type) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const elementData = {
                id: elementId,
                type: type,
                element: element,
                x: parseInt(element.style.left) || 0,
                y: parseInt(element.style.top) || 0
            };

            elements.push(elementData);

            // Add drag handlers specific to elements
            element.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startDragging(element, e);
            });
        }

        function startDragging(element, e) {
            isDragging = true;
            dragElement = element;
            element.classList.add('dragging');

            const rect = element.getBoundingClientRect();
            const surfaceRect = surface.getBoundingClientRect();
            
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
        }

        function handleMouseDown(e) {
            if (e.target === container || e.target === surface) {
                isPanning = true;
                panStart.x = e.clientX - panX;
                panStart.y = e.clientY - panY;
                container.classList.add('grabbing');
                
                // Stop any ongoing inertia animation
                if (inertiaAnimation) {
                    cancelAnimationFrame(inertiaAnimation);
                    inertiaAnimation = null;
                }
                
                // Reset pan tracking
                velocity = { x: 0, y: 0 };
                panHistory = [];
                lastPanTime = Date.now();
                lastPanPosition = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            if (isDragging && dragElement) {
                const surfaceRect = surface.getBoundingClientRect();
                const x = (e.clientX - surfaceRect.left - dragOffset.x) / currentZoom;
                const y = (e.clientY - surfaceRect.top - dragOffset.y) / currentZoom;
                
                dragElement.style.left = x + 'px';
                dragElement.style.top = y + 'px';
                
                // No connections needed with grid layout
            } else if (isPanning) {
                const currentTime = Date.now();
                const currentPosition = { x: e.clientX, y: e.clientY };
                
                // Calculate movement with reduced sensitivity
                const newPanX = (e.clientX - panStart.x) * 0.8; // 20% less sensitive
                const newPanY = (e.clientY - panStart.y) * 0.8; // 20% less sensitive
                
                // Track velocity for inertia
                if (currentTime - lastPanTime > 0) {
                    velocity.x = (currentPosition.x - lastPanPosition.x) / (currentTime - lastPanTime) * 16; // Normalize to 60fps
                    velocity.y = (currentPosition.y - lastPanPosition.y) / (currentTime - lastPanTime) * 16;
                    
                    // Keep a short history for smoother velocity calculation
                    panHistory.push({ velocity: { ...velocity }, time: currentTime });
                    if (panHistory.length > 5) panHistory.shift();
                }
                
                panX = newPanX;
                panY = newPanY;
                updateTransform();
                
                lastPanTime = currentTime;
                lastPanPosition = currentPosition;
            }
        }

        function handleMouseUp(e) {
            if (isDragging && dragElement) {
                dragElement.classList.remove('dragging');
                dragElement = null;
                isDragging = false;
            }
            
            if (isPanning) {
                isPanning = false;
                container.classList.remove('grabbing');
                
                // Start inertia animation if there's enough velocity
                if (panHistory.length > 1) {
                    // Calculate average velocity from recent history
                    const avgVelocity = panHistory.reduce((acc, entry) => {
                        acc.x += entry.velocity.x;
                        acc.y += entry.velocity.y;
                        return acc;
                    }, { x: 0, y: 0 });
                    
                    avgVelocity.x /= panHistory.length;
                    avgVelocity.y /= panHistory.length;
                    
                    // Only start inertia if velocity is significant
                    const velocityMagnitude = Math.sqrt(avgVelocity.x * avgVelocity.x + avgVelocity.y * avgVelocity.y);
                    if (velocityMagnitude > 0.5) {
                        startInertiaAnimation(avgVelocity);
                    }
                }
            }
        }

        function startInertiaAnimation(initialVelocity) {
            let currentVelocity = { ...initialVelocity };
            const friction = 0.92; // Deceleration factor
            const minVelocity = 0.1; // Stop threshold
            
            function animate() {
                // Apply velocity to position
                panX += currentVelocity.x * 0.8; // Reduce sensitivity for inertia too
                panY += currentVelocity.y * 0.8;
                
                // Apply friction
                currentVelocity.x *= friction;
                currentVelocity.y *= friction;
                
                updateTransform();
                
                // Continue animation if velocity is still significant
                const velocityMagnitude = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);
                if (velocityMagnitude > minVelocity) {
                    inertiaAnimation = requestAnimationFrame(animate);
                } else {
                    inertiaAnimation = null;
                }
            }
            
            animate();
        }

        let isUpdating = false;
        
        function handleWheel(e) {
            e.preventDefault();
            
            // Throttle updates for performance
            if (isUpdating) return;
            isUpdating = true;
            
            // Stop inertia when user starts zooming
            if (inertiaAnimation) {
                cancelAnimationFrame(inertiaAnimation);
                inertiaAnimation = null;
            }
            
            // Smooth zoom with smaller increments
            const zoomSensitivity = 0.05; // Slightly increased for responsiveness
            const delta = e.deltaY > 0 ? -zoomSensitivity : zoomSensitivity;
            const newZoom = Math.max(0.1, Math.min(5, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // Zoom towards mouse position
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scaleChange = newZoom / currentZoom;
                panX = mouseX - (mouseX - panX) * scaleChange;
                panY = mouseY - (mouseY - panY) * scaleChange;
                
                currentZoom = newZoom;
                updateTransform();
                updateZoomIndicator();
            }
            
            // Reset throttle after frame
            requestAnimationFrame(() => {
                isUpdating = false;
            });
        }

        function updateTransform() {
            requestAnimationFrame(() => {
                const transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
                surface.style.transform = transform;
            });
        }

        function updateZoomIndicator() {
            zoomIndicator.textContent = Math.round(currentZoom * 100) + '%';
        }

        // Auto-position camera for two-section layout
        function autoPositionCamera() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            // Set zoom to 80% for better overview
            const optimalZoom = 0.8;
            
            // Center the canvas in the viewport
            // Calculate the center position accounting for the zoom
            const canvasWidth = screenWidth;
            const canvasHeight = screenHeight;
            
            // Center horizontally and vertically
            panX = (screenWidth - canvasWidth * optimalZoom) / 2;
            panY = (screenHeight - canvasHeight * optimalZoom) / 2;
            currentZoom = optimalZoom;
            
            // Apply transform without transition for performance
            updateTransform();
            updateZoomIndicator();
            
            console.log(`📐 Canvas positioned: ${Math.round(optimalZoom * 100)}% zoom, centered`);
        }

        function resetZoom() {
            // Reset to default 80% zoom with centering
            autoPositionCamera();
        }

        function zoomIn() {
            currentZoom = Math.min(3, currentZoom * 1.2);
            updateTransform();
            updateZoomIndicator();
        }

        function zoomOut() {
            currentZoom = Math.max(0.1, currentZoom * 0.8);
            updateTransform();
            updateZoomIndicator();
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                processImageFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                processImageFile(file);
            }
        }

        async function processImageFile(file) {
            // Show loading state
            uploadZone.classList.add('loading');
            
            try {
                // Store the base64 data for later use
                currentImageBase64 = await fileToBase64(file);
                
                // Create image preview in upload box
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    
                    // Show image at natural size within fixed upload box
                    img.onload = () => {
                        // Style the image to fit within the fixed upload box
                        img.className = 'image-preview';
                        img.style.cursor = 'zoom-in';
                        
                        // Add click handler for image expansion
                        img.onclick = (e) => {
                            e.stopPropagation();
                            openImageModal(img.src, 'Original Upload', 'Source image for AI transformation');
                        };
                        
                        // Replace upload zone with image preview
                        const uploadContent = uploadZone.parentElement;
                        uploadContent.innerHTML = '';
                        
                        // Create image container
                        const imageContainer = document.createElement('div');
                        imageContainer.className = 'image-container';
                        imageContainer.appendChild(img);
                        
                        // Create start button outside of clickable area
                        const startButton = document.createElement('button');
                        startButton.className = 'start-button';
                        startButton.innerHTML = 'Explore';
                        startButton.onclick = (e) => {
                            e.stopPropagation();
                            startButton.style.display = 'none';
                            autoplaySequence();
                        };
                        
                        // Create change image button
                        const changeButton = document.createElement('button');
                        changeButton.className = 'change-button';
                        changeButton.innerHTML = '🔄 Change Image';
                        changeButton.onclick = (e) => {
                            e.stopPropagation();
                            fileInput.click();
                        };
                        
                        // Add elements to upload content
                        uploadContent.appendChild(imageContainer);
                        uploadContent.appendChild(startButton);
                        uploadContent.appendChild(changeButton);
                        
                        uploadZone.classList.remove('loading');
                        
                        console.log(`📏 Upload image loaded: ${img.naturalWidth}x${img.naturalHeight}`);
                    };
                };
                reader.readAsDataURL(file);
                
            } catch (error) {
                console.error('Error processing image:', error);
                uploadZone.classList.remove('loading');
                alert('Error processing image. Please try again.');
            }
        }
        
        async function autoplaySequence() {
            console.log('🎬 Starting autoplay sequence...');
            
            // Step 1: Create entire blank layout immediately
            console.log('📐 Creating layout structure...');
            createBlankLayout();
            
            // Auto-position camera to show the complete layout
            setTimeout(() => {
                autoPositionCamera();
            }, 500);
            
            // Step 2: Start AI analysis
            console.log('🤖 Analyzing image with AI...');
            console.log('Current image base64 length:', currentImageBase64?.length || 'undefined');
            
            try {
                const analysisResult = await analyzeImageWithMistral(currentImageBase64);
                console.log('🎯 Analysis result:', analysisResult);
                
                // Step 3: Fill in caption
                await animatedDelay(800);
                fillCaptionBox(analysisResult.caption);
                
                // Step 4: Fill in koncept labels
                await animatedDelay(600);
                fillKonceptLabels(analysisResult.vibes);
                
                // Step 5: Auto-generate images for each koncept in sequence
                console.log('🎨 Starting automatic koncept generation...');
                for (let i = 0; i < 3; i++) {
                    const koncept = analysisResult.vibes[i] || 'creative';
                    console.log(`🎯 Auto-generating for koncept: ${koncept}`);
                    await autoGenerateKonceptImages(koncept, `koncept-${i}`, i);
                    await animatedDelay(500);
                }
                
                console.log('✨ Autoplay sequence complete!');
            } catch (error) {
                console.error('❌ Error in autoplay sequence:', error);
                // Fill with fallback data
                fillCaptionBox('Analysis failed - using fallback data');
                fillKonceptLabels(['creative', 'bold', 'mysterious']);
            }
        }
        
        async function animatedDelay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createBlankLayout() {
            // Get container references
            const captionContainer = document.querySelector('.caption-container');
            const rightSection = document.getElementById('rightSection');
            
            // Create caption box in left section
            const captionElement = document.createElement('div');
            captionElement.className = 'canvas-element caption-box';
            captionElement.id = 'caption-box';
            captionElement.innerHTML = `
                <div class="element-header">🔍 EXPLORING IMAGE SPACE</div>
                <div class="element-content">
                    <div class="progress-state">
                        <div class="progress-bar"></div>
                        <div class="progress-text">ANALYZING...</div>
                    </div>
                </div>
            `;
            captionContainer.appendChild(captionElement);
            
            // Create koncept labels and result boxes for each koncept (3 rows total) in right section
            for (let konceptIndex = 0; konceptIndex < 3; konceptIndex++) {
                // Create koncept label for this row
                const konceptLabel = document.createElement('div');
                konceptLabel.className = `koncept-label grid-koncept-label-${konceptIndex}`;
                konceptLabel.id = `koncept-label-${konceptIndex}`;
                konceptLabel.innerHTML = `
                    <div class="progress-dot"></div>
                    <div class="progress-text">KONCEPT ${konceptIndex + 1}</div>
                `;
                rightSection.appendChild(konceptLabel);
                
                // Create 4 result boxes for this koncept
                for (let resultIndex = 0; resultIndex < 4; resultIndex++) {
                    const resultElement = document.createElement('div');
                    resultElement.className = `canvas-element result-box grid-result-${konceptIndex}-${resultIndex}`;
                    resultElement.id = `result-${konceptIndex}-${resultIndex}`;
                    resultElement.innerHTML = `
                        <div class="element-header">🎨 RESULT ${resultIndex + 1}</div>
                        <div class="element-content">
                            <div class="blank-result">
                                <div class="blank-image"></div>
                                <div class="progress-text">WAITING...</div>
                            </div>
                        </div>
                    `;
                    rightSection.appendChild(resultElement);
                }
            }
            
            // Add the "Add Custom Koncept" empty state row
            createAddKonceptRow(rightSection);
        }
        
        function createAddKonceptRow(rightSection) {
            // Calculate the next available row (each koncept now takes 2 rows: header + images)
            const nextRow = (totalKonceptRows * 2) + 1;
            
            console.log(`Creating add-koncept row at grid row ${nextRow} (totalKonceptRows: ${totalKonceptRows})`);
            
            // Create the add koncept label (clickable) - spans all columns like other koncept headers
            const addKonceptLabel = document.createElement('div');
            addKonceptLabel.className = 'add-koncept-label';
            addKonceptLabel.id = 'addKonceptLabel';
            addKonceptLabel.style.gridColumn = '1 / -1';
            addKonceptLabel.style.gridRow = nextRow.toString();
            addKonceptLabel.innerHTML = '+ Add Custom Koncept';
            addKonceptLabel.onclick = () => showCustomKonceptInput();
            rightSection.appendChild(addKonceptLabel);
            
            // Create 4 empty boxes for the row below the header
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.createElement('div');
                emptyBox.className = 'add-koncept-empty-box';
                emptyBox.id = `add-koncept-empty-${i}`;
                emptyBox.style.gridColumn = (i + 1).toString();
                emptyBox.style.gridRow = (nextRow + 1).toString();
                emptyBox.innerHTML = '...';
                rightSection.appendChild(emptyBox);
            }
            
            console.log(`✅ Add-koncept row created at rows ${nextRow} and ${nextRow + 1}`);
        }

        function fillCaptionBox(caption) {
            console.log('🔄 Filling caption box with:', caption.substring(0, 50) + '...');
            const captionBox = document.getElementById('caption-box');
            console.log('Caption box element:', captionBox);
            if (captionBox) {
                const content = captionBox.querySelector('.element-content');
                console.log('Caption content element:', content);
                if (content) {
                    content.innerHTML = `
                        <div class="caption-text">${caption}</div>
                    `;
                    console.log('✅ Caption box updated');
                } else {
                    console.error('❌ Caption content element not found in existing caption box');
                    // Fallback: replace entire content
                    captionBox.innerHTML = `
                        <div class="element-header">🔍 EXPLORING IMAGE SPACE</div>
                        <div class="element-content">
                            <div class="caption-text">${caption}</div>
                        </div>
                    `;
                    console.log('✅ Caption box content replaced');
                }
            } else {
                console.error('❌ Caption box not found, creating new one');
                // Try to create it if it doesn't exist
                const captionContainer = document.querySelector('.caption-container');
                if (captionContainer) {
                    // Clear any existing content first
                    captionContainer.innerHTML = '';
                    const captionElement = document.createElement('div');
                    captionElement.className = 'canvas-element caption-box';
                    captionElement.id = 'caption-box';
                    captionElement.innerHTML = `
                        <div class="element-header">🔍 EXPLORING IMAGE SPACE</div>
                        <div class="element-content">
                            <div class="caption-text">${caption}</div>
                        </div>
                    `;
                    captionContainer.appendChild(captionElement);
                    console.log('✅ Caption box created and filled');
                } else {
                    console.error('❌ Caption container not found');
                }
            }
        }

        function fillKonceptLabels(koncepts) {
            console.log('🔄 Filling koncept labels with:', koncepts);
            for (let i = 0; i < 3; i++) {
                const konceptLabel = document.getElementById(`koncept-label-${i}`);
                
                if (konceptLabel) {
                    const konceptName = koncepts[i] || `creative-${i}`;
                    
                    // Create editable koncept label with regenerate button
                    konceptLabel.innerHTML = `
                        <span class="koncept-text" onclick="editKoncept(${i})">${konceptName.toUpperCase()}</span>
                        <div class="regenerate-row-btn" onclick="regenerateKonceptRow(${i})" title="Regenerate this row"></div>
                    `;
                    
                    // Store the current koncept name
                    konceptLabel.dataset.koncept = konceptName;
                    
                    console.log(`✅ Updated koncept ${i}: ${konceptName}`);
                } else {
                    console.error(`❌ Koncept label ${i} not found`);
                }
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Hilarious random elements to combine with concepts
        const hilariousElements = [
            'but holding puppies',
            'while eating spaghetti',
            'but made of marshmallows',
            'riding a unicorn',
            'wearing a banana costume',
            'surrounded by rubber ducks',
            'but they\'re actually a cat',
            'made entirely of glitter',
            'but tiny and living in a teacup',
            'while juggling pineapples',
            'wearing rainbow socks',
            'but they\'re secretly a robot',
            'covered in post-it notes',
            'holding a very confused chicken',
            'made of jello',
            'wearing a crown of broccoli',
            'but they\'re floating',
            'surrounded by flying pizza slices',
            'wearing mismatched shoes',
            'but everything is backwards',
            'holding a magic spoon',
            'made of clouds',
            'wearing a cape of lettuce',
            'but they\'re upside down',
            'surrounded by dancing pickles',
            'wearing a hat made of cheese',
            'but they\'re transparent',
            'holding a tiny elephant',
            'made of bubble wrap',
            'wearing polka dot everything'
        ];

        function getRandomHilariousElement() {
            return hilariousElements[Math.floor(Math.random() * hilariousElements.length)];
        }

        async function analyzeImageWithMistral(base64Data) {
            try {
                const response = await fetch('/api/analyze-vibes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64Data })
                });

                if (!response.ok) throw new Error('Analysis failed');

                const data = await response.json();
                
                // Add hilarious elements to each vibe
                const enhancedVibes = (data.vibes || ['creative', 'unique', 'interesting']).map(vibe => {
                    return `${vibe} ${getRandomHilariousElement()}`;
                });
                
                return {
                    caption: data.description || "Image analyzed successfully",
                    vibes: enhancedVibes
                };
            } catch (error) {
                console.error('Mistral analysis error:', error);
                return {
                    caption: "Could not analyze image with AI",
                    vibes: [
                        `mysterious ${getRandomHilariousElement()}`, 
                        `creative ${getRandomHilariousElement()}`, 
                        `unique ${getRandomHilariousElement()}`
                    ]
                };
            }
        }

        function createCaptionBox(caption, x, y) {
            const captionBox = createElement('caption', `
                <div class="element-header">
                    🤖 AI Analysis
                </div>
                <div class="element-content">
                    <div class="caption-text">${caption}</div>
                </div>
            `, x, y);

            // Add entrance animation
            captionBox.element.style.opacity = '0';
            captionBox.element.style.transform = 'translateX(-50px) scale(0.9)';
            
            // Animate in
            setTimeout(() => {
                captionBox.element.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                captionBox.element.style.opacity = '1';
                captionBox.element.style.transform = 'translateX(0) scale(1)';
            }, 100);

            // Grid layout handles positioning automatically
            
            return captionBox;
        }

        function createVibeNodes(vibes, startX, startY) {
            vibes.forEach((vibe, index) => {
                const x = startX;
                const y = startY + (index * 150);
                
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');

                // Grid layout handles positioning automatically

                // Add click handler for vibe generation
                vibeNode.element.addEventListener('click', () => generateVibeImages(vibe, vibeNode.id));
            });
        }
        
        async function createVibeNodesFan(vibes) {
            const captionElement = elements.find(el => el.type === 'caption');
            const captionX = captionElement ? parseInt(captionElement.element.style.left) : 500;
            const captionY = captionElement ? parseInt(captionElement.element.style.top) : 200;
            
            const vibeNodes = [];
            const vibeSpacing = 180; // Vertical spacing between vibes  
            const vibeXOffset = 400; // Horizontal distance from caption
            
            for (let i = 0; i < vibes.length; i++) {
                const vibe = vibes[i];
                
                // Calculate clean vertical layout
                const x = captionX + vibeXOffset;
                const y = captionY + (i * vibeSpacing) - ((vibes.length - 1) * vibeSpacing / 2);
                
                // Create vibe node with animation delay
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');
                
                // Store vibe index for result layout
                vibeNode.vibeIndex = i;
                
                // Add entrance animation
                vibeNode.element.style.opacity = '0';
                vibeNode.element.style.transform = 'scale(0.5)';
                
                // Animate in with delay
                setTimeout(() => {
                    vibeNode.element.style.transition = 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    vibeNode.element.style.opacity = '1';
                    vibeNode.element.style.transform = 'scale(1)';
                }, i * 300);
                
                // Grid layout handles positioning automatically
                
                vibeNodes.push(vibeNode);
            }
            
            return vibeNodes;
        }

        function createElement(type, innerHTML, x, y, extraClass = '') {
            elementIdCounter++;
            const id = `element-${elementIdCounter}`;
            
            const element = document.createElement('div');
            element.id = id;
            element.className = `canvas-element ${type}-box ${extraClass}`;
            element.style.left = x + 'px';
            element.style.top = y + 'px';
            element.innerHTML = innerHTML;
            
            surface.appendChild(element);
            registerElement(id, type);
            
            return { id, element };
        }

        async function generateVibeImages(vibe, vibeNodeId) {
            const vibeElement = document.getElementById(vibeNodeId);
            vibeElement.classList.add('selected');
            
            try {
                // Check if we have the stored image data
                if (!currentImageBase64) {
                    throw new Error('No image available for transformation');
                }
                
                console.log(`Generating ${vibe} prompts...`);
                
                // Generate vibe-specific prompts using Mistral
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        vibe: vibe 
                    })
                });
                
                if (!promptResponse.ok) {
                    throw new Error('Failed to generate vibe prompts');
                }
                
                const promptData = await promptResponse.json();
                const prompts = promptData.prompts || [];
                
                console.log(`Generated ${prompts.length} prompts for ${vibe}:`, prompts);
                
                // Create result boxes and generate images
                const baseX = parseInt(vibeElement.style.left) + 300;
                const baseY = parseInt(vibeElement.style.top);
                
                for (let i = 0; i < Math.min(4, prompts.length); i++) {
                    const prompt = prompts[i];
                    
                    const resultBox = createElement('result', `
                        <div class="element-header">
                            🎨 ${vibe.toUpperCase()} #${i + 1}
                        </div>
                        <div class="element-content">
                            <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                                Generating...
                            </div>
                            <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                        </div>
                    `, baseX + (i * 280), baseY + (i * 100));

                    // Grid layout handles positioning automatically
                    
                    // Generate image for this prompt
                    generateSingleVibeImage(prompt, resultBox.id, vibe, i + 1);
                }
                
            } catch (error) {
                console.error('Error generating vibe images:', error);
                alert(`Error generating ${vibe} images: ${error.message}`);
            } finally {
                vibeElement.classList.remove('selected');
            }
        }
        
        async function autoGenerateKonceptImages(koncept, konceptNodeId, konceptIndex) {
            try {
                console.log(`🎭 Auto-generating prompts for ${koncept}...`);
                
                // Generate koncept-specific prompts using Mistral
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        vibe: koncept 
                    })
                });
                
                if (!promptResponse.ok) {
                    throw new Error('Failed to generate koncept prompts');
                }
                
                const promptData = await promptResponse.json();
                const prompts = promptData.prompts || [];
                
                console.log(`✨ Generated ${prompts.length} prompts for ${koncept}`);
                
                // Generate images for each of the 4 result boxes
                for (let i = 0; i < 4; i++) {
                    const resultBoxId = `result-${konceptIndex}-${i}`;
                    const prompt = prompts[i] || `Transform the image to emphasize ${koncept} qualities`;
                    
                    // Update progress state
                    updateResultProgress(resultBoxId, 'GENERATING...');
                    
                    // Start generation with staggered timing
                    setTimeout(() => {
                        generateSingleKonceptImage(prompt, resultBoxId, koncept, i + 1, konceptIndex);
                    }, i * 500);
                }
                
                await animatedDelay(2000);
                
            } catch (error) {
                console.error('Error in auto-generation:', error);
            }
        }

        function updateResultProgress(resultBoxId, text) {
            const resultBox = document.getElementById(resultBoxId);
            if (resultBox) {
                const content = resultBox.querySelector('.element-content');
                content.innerHTML = `
                    <div class="blank-result">
                        <div class="blank-image"></div>
                        <div class="progress-text">${text}</div>
                    </div>
                `;
            }
        }
        
        async function createResultBoxesFan(vibe, vibeNodeId, prompts, vibeIndex) {
            const vibeElement = document.getElementById(vibeNodeId);
            const vibeX = parseInt(vibeElement.style.left);
            const vibeY = parseInt(vibeElement.style.top);
            
            const resultBoxes = [];
            const resultSpacing = 300; // Horizontal spacing between results
            const resultXOffset = 280; // Distance from vibe node
            const resultStartX = vibeX + resultXOffset;
            
            // Calculate base Y position for this vibe's row - create elegant staggered layout
            const rowBaseY = vibeY - 30; // Slightly above vibe center for better flow
            
            for (let i = 0; i < Math.min(4, prompts.length); i++) {
                const prompt = prompts[i];
                
                // Create elegant branching layout with slight vertical offsets
                const x = resultStartX + (i * resultSpacing);
                const y = rowBaseY + (i * 15); // Subtle stagger for organic flow
                
                const resultBox = createElement('result', `
                    <div class="element-header">
                        🎨 ${vibe.toUpperCase()} #${i + 1}
                    </div>
                    <div class="element-content">
                        <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                            Generating...
                        </div>
                        <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                    </div>
                `, x, y);
                
                // Add entrance animation
                resultBox.element.style.opacity = '0';
                resultBox.element.style.transform = 'scale(0.8) translateY(20px)';
                
                // Animate in with delay
                setTimeout(() => {
                    resultBox.element.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    resultBox.element.style.opacity = '1';
                    resultBox.element.style.transform = 'scale(1) translateY(0)';
                }, i * 200);
                
                // Add connection with delay
                setTimeout(() => {
                    // Grid layout handles positioning automatically
                }, i * 200 + 100);
                
                resultBoxes.push(resultBox);
            }
            
            return resultBoxes;
        }
        
        async function generateSingleKonceptImage(prompt, resultBoxId, koncept, index, konceptIndex) {
            const resultBox = document.getElementById(resultBoxId);
            
            try {
                console.log(`🎨 Generating image ${index} for ${koncept}:`, prompt);
                
                // Add generating animation
                if (resultBox) {
                    resultBox.classList.add('generating');
                }
                
                // Call the edit API endpoint with the vibe-specific prompt
                const response = await fetch('/api/edit-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        input_image: currentImageBase64,
                        steps: 50,
                        guidance: 3.0
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to generate image: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.imageUrl) {
                    // Update the result box with the generated image
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="result-image-container">
                                <img src="${result.imageUrl}" class="result-image" style="
                                    cursor: zoom-in;
                                    width: 100%;
                                    height: auto;
                                    min-height: 400px;
                                    object-fit: contain;
                                " onclick="openImageModal('${result.imageUrl}', '${koncept.toUpperCase()} #${index}', '${prompt.replace(/'/g, "\\'")}')">
                            </div>
                        `;
                        
                        // Image is now immediately visible
                        
                        // Success visual feedback
                        resultBox.style.background = '#fff';
                        resultBox.style.color = '#000';
                        
                        console.log(`✅ Image ${index} completed for ${koncept}`);
                        
                        // Save result to session
                        saveResultToSession(konceptIndex, index - 1, {
                            prompt: prompt,
                            imageUrl: result.imageUrl,
                            status: 'completed'
                        });
                    }
                } else if (result.moderated) {
                    // Handle moderated content
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="moderated-result">
                                <div class="progress-text">⚠️ MODERATED</div>
                            </div>
                        `;
                        resultBox.style.background = '#ff6600';
                        resultBox.style.color = '#000';
                    }
                } else {
                    throw new Error('Generation failed');
                }
                
            } catch (error) {
                console.error(`❌ Error generating image ${index} for ${koncept}:`, error);
                
                // Update result box to show error
                if (resultBox) {
                    const content = resultBox.querySelector('.element-content');
                    content.innerHTML = `
                        <div class="error-result">
                            <div class="progress-text">❌ FAILED</div>
                        </div>
                    `;
                    resultBox.style.background = '#ff6600';
                    resultBox.style.color = '#000';
                }
            } finally {
                // Remove generating animation
                if (resultBox) {
                    resultBox.classList.remove('generating');
                }
            }
        }

        // Connection functions removed - using CSS Grid layout instead

        // Touch event handlers with inertia support
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseDown({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY, 
                    target: e.target 
                });
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseMove({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY 
                });
            }
        }

        function handleTouchEnd(e) {
            // Touch end should trigger inertia like mouse up
            handleMouseUp(e);
        }

        // Image Modal Functions
        function openImageModal(imageSrc, title, prompt) {
            // Collect all available images for navigation
            collectModalImages();
            
            // Find the current image index
            currentModalIndex = modalImages.findIndex(img => img.src === imageSrc);
            if (currentModalIndex === -1) {
                // If not found, add current image and set as current
                modalImages.push({ src: imageSrc, title, prompt });
                currentModalIndex = modalImages.length - 1;
            }
            
            showModalImage(currentModalIndex);
            
            const modal = document.getElementById('imageModal');
            modal.style.display = 'flex';
            
            // Trigger animation after display
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
            
            // Prevent body scrolling
            document.body.style.overflow = 'hidden';
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeImageModal();
                }
            });
            
            // Add event listeners
            document.addEventListener('keydown', handleModalKeydown);
            document.addEventListener('touchstart', handleModalTouchStart);
            document.addEventListener('touchmove', handleModalTouchMove);
            document.addEventListener('touchend', handleModalTouchEnd);
        }
        
        function collectModalImages() {
            modalImages = [];
            
            // Add upload image if it exists
            const uploadImage = document.querySelector('.image-preview');
            if (uploadImage && uploadImage.src) {
                modalImages.push({
                    src: uploadImage.src,
                    title: 'Original Upload',
                    prompt: 'Source image for AI transformation'
                });
            }
            
            // Add all generated images
            const resultImages = document.querySelectorAll('.result-image');
            resultImages.forEach((img, index) => {
                if (img.src && img.src !== '') {
                    // Extract vibe info from result box
                    const resultBox = img.closest('.result-box');
                    const header = resultBox ? resultBox.querySelector('.element-header') : null;
                    const title = header ? header.textContent.trim() : `Generated Image ${index + 1}`;
                    
                    modalImages.push({
                        src: img.src,
                        title: title,
                        prompt: 'AI generated transformation'
                    });
                }
            });
        }
        
        function showModalImage(index) {
            if (index < 0 || index >= modalImages.length) return;
            
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalPrompt = document.getElementById('modalPrompt');
            const modalCounter = document.getElementById('modalCounter');
            const modalPrev = document.getElementById('modalPrev');
            const modalNext = document.getElementById('modalNext');
            
            const image = modalImages[index];
            modalImage.src = image.src;
            modalTitle.textContent = image.title;
            modalPrompt.textContent = image.prompt;
            modalCounter.textContent = `${index + 1} / ${modalImages.length}`;
            
            // Update navigation buttons
            modalPrev.classList.toggle('disabled', index === 0);
            modalNext.classList.toggle('disabled', index === modalImages.length - 1);
            
            currentModalIndex = index;
        }
        
        function navigateModal(direction) {
            const newIndex = currentModalIndex + direction;
            if (newIndex >= 0 && newIndex < modalImages.length) {
                showModalImage(newIndex);
            }
        }
        
        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            
            modal.classList.remove('show');
            
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
            
            // Remove event listeners
            document.removeEventListener('keydown', handleModalKeydown);
            document.removeEventListener('touchstart', handleModalTouchStart);
            document.removeEventListener('touchmove', handleModalTouchMove);
            document.removeEventListener('touchend', handleModalTouchEnd);
        }
        
        function handleModalKeydown(e) {
            if (e.key === 'Escape') {
                closeImageModal();
            } else if (e.key === 'ArrowLeft') {
                navigateModal(-1);
            } else if (e.key === 'ArrowRight') {
                navigateModal(1);
            }
        }
        
        // Touch handling for mobile swipe navigation
        let modalTouchStartX = 0;
        let modalTouchStartY = 0;
        
        function handleModalTouchStart(e) {
            if (e.touches.length === 1) {
                modalTouchStartX = e.touches[0].clientX;
                modalTouchStartY = e.touches[0].clientY;
            }
        }
        
        function handleModalTouchMove(e) {
            // Prevent default to avoid scrolling while swiping
            if (e.touches.length === 1) {
                e.preventDefault();
            }
        }
        
        function handleModalTouchEnd(e) {
            if (e.changedTouches.length === 1) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const deltaX = touchEndX - modalTouchStartX;
                const deltaY = touchEndY - modalTouchStartY;
                
                // Check if horizontal swipe is more significant than vertical
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        // Swipe right - go to previous image
                        navigateModal(-1);
                    } else {
                        // Swipe left - go to next image
                        navigateModal(1);
                    }
                }
            }
        }

        // Custom Koncept Functions
        function showAddKonceptButton() {
            const addKonceptContainer = document.getElementById('addKonceptContainer');
            addKonceptContainer.style.display = 'block';
            console.log('🎨 Add Koncept button now visible');
        }
        
        function showCustomKonceptInput() {
            const input = prompt('Enter your custom koncept (e.g., cyberpunk-medieval, neon-zen):');
            
            if (input && input.trim().length >= 3) {
                const customKoncept = input.trim();
                console.log(`🎭 Generating custom koncept: ${customKoncept}`);
                
                generateCustomKonceptDirect(customKoncept);
            } else if (input !== null) {
                alert('Please enter a koncept with at least 3 characters');
            }
        }
        
        async function generateCustomKonceptDirect(customKoncept) {
            try {
                // Increment custom koncept count and total rows
                customKonceptCount++;
                const konceptIndex = totalKonceptRows;
                totalKonceptRows++;
                
                // Replace the empty state row with the new koncept
                replaceAddKonceptRowWithResults(konceptIndex, customKoncept);
                
                // Generate images for the custom koncept
                await autoGenerateKonceptImages(customKoncept, `custom-koncept-${customKonceptCount}`, konceptIndex);
                
                // Add a new empty state row below
                const rightSection = document.getElementById('rightSection');
                createAddKonceptRow(rightSection);
                
                console.log(`✅ Custom koncept "${customKoncept}" generation complete!`);
                
            } catch (error) {
                console.error('❌ Error generating custom koncept:', error);
                alert(`Error generating "${customKoncept}" koncept. Please try again.`);
            }
        }
        
        function replaceAddKonceptRowWithResults(konceptIndex, konceptName) {
            const rightSection = document.getElementById('rightSection');
            
            // Remove the current add koncept row
            const addKonceptLabel = document.getElementById('addKonceptLabel');
            if (addKonceptLabel) addKonceptLabel.remove();
            
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.getElementById(`add-koncept-empty-${i}`);
                if (emptyBox) emptyBox.remove();
            }
            
            // Calculate the row numbers (header and images)
            const headerRow = (konceptIndex * 2) + 1;
            const imagesRow = headerRow + 1;
            
            // Add koncept label header (spans all columns)
            const konceptLabel = document.createElement('div');
            konceptLabel.className = 'koncept-label';
            konceptLabel.id = `koncept-label-${konceptIndex}`;
            konceptLabel.style.gridColumn = '1 / -1';
            konceptLabel.style.gridRow = headerRow;
            konceptLabel.innerHTML = `
                <span class="koncept-text" onclick="editKoncept(${konceptIndex})">${konceptName.toUpperCase()}</span>
                <div class="regenerate-row-btn" onclick="regenerateKonceptRow(${konceptIndex})" title="Regenerate this row"></div>
            `;
            konceptLabel.dataset.koncept = konceptName;
            rightSection.appendChild(konceptLabel);
            
            // Add 4 result boxes in the row below the header
            for (let resultIndex = 0; resultIndex < 4; resultIndex++) {
                const resultElement = document.createElement('div');
                resultElement.className = 'canvas-element result-box';
                resultElement.id = `result-${konceptIndex}-${resultIndex}`;
                resultElement.style.gridColumn = resultIndex + 1;
                resultElement.style.gridRow = imagesRow;
                resultElement.innerHTML = `
                    <div class="element-header">🎨 RESULT ${resultIndex + 1}</div>
                    <div class="element-content">
                        <div class="blank-result">
                            <div class="blank-image"></div>
                            <div class="progress-text">WAITING...</div>
                        </div>
                    </div>
                `;
                rightSection.appendChild(resultElement);
            }
            
            console.log(`✅ Replaced empty state with koncept row for: ${konceptName} (header: row ${headerRow}, images: row ${imagesRow})`);
        }

        // Session management functions
        function saveResultToSession(konceptIndex, resultIndex, result) {
            if (isSharedSession) return; // Don't save results for shared sessions
            
            // Initialize session results structure if needed
            while (sessionResults.length <= konceptIndex) {
                sessionResults.push([]);
            }
            while (sessionResults[konceptIndex].length <= resultIndex) {
                sessionResults[konceptIndex].push(null);
            }
            
            sessionResults[konceptIndex][resultIndex] = result;
            console.log(`💾 Saved result to session: koncept ${konceptIndex}, result ${resultIndex}`);
            
            // Auto-save session periodically
            debounceSessionSave();
        }
        
        let sessionSaveTimeout;
        function debounceSessionSave() {
            clearTimeout(sessionSaveTimeout);
            sessionSaveTimeout = setTimeout(saveCurrentSession, 2000); // Save after 2 seconds of inactivity
        }
        
        async function saveCurrentSession() {
            if (isSharedSession || !currentImageBase64 || sessionResults.length === 0) return;
            
            try {
                console.log('💾 Saving current session...');
                
                // Flatten session results for API
                const flatResults = [];
                sessionResults.forEach((konceptResults, konceptIndex) => {
                    konceptResults.forEach((result, resultIndex) => {
                        if (result) {
                            flatResults.push(result);
                        }
                    });
                });
                
                if (flatResults.length === 0) return;
                
                const response = await fetch('/api/save-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        originalImage: currentImageBase64,
                        results: flatResults,
                        sessionId: currentSessionId
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('✅ Session saved:', data.sessionId);
                    
                    // URL is already updated at session creation, no need to update again
                    
                    // Show share button once session is saved
                    showShareButton(data.shareUrl);
                } else {
                    console.error('❌ Failed to save session');
                }
                
            } catch (error) {
                console.error('❌ Error saving session:', error);
            }
        }
        
        function showShareButton(shareUrl) {
            // Check if share button already exists
            if (document.getElementById('shareButton')) return;
            
            const controlsContainer = document.querySelector('.canvas-controls');
            const shareButton = document.createElement('button');
            shareButton.id = 'shareButton';
            shareButton.className = 'control-btn';
            shareButton.innerHTML = 'SHARE';
            shareButton.onclick = () => shareSession(shareUrl);
            
            controlsContainer.appendChild(shareButton);
        }
        
        function shareSession(shareUrl) {
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show temporary success message
                const shareButton = document.getElementById('shareButton');
                const originalText = shareButton.innerHTML;
                shareButton.innerHTML = '✅ Copied!';
                shareButton.style.background = '#00ff00';
                shareButton.style.color = '#000';
                
                setTimeout(() => {
                    shareButton.innerHTML = originalText;
                    shareButton.style.background = '';
                    shareButton.style.color = '';
                }, 2000);
            }).catch(() => {
                // Fallback: show URL in prompt
                prompt('Share this URL:', shareUrl);
            });
        }
        
        // Koncept editing and regeneration functions
        function editKoncept(konceptIndex) {
            if (isSharedSession) return; // Don't allow editing in shared sessions
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const currentKoncept = konceptLabel.dataset.koncept || '';
            const konceptText = konceptLabel.querySelector('.koncept-text');
            
            // Create input field
            const input = document.createElement('input');
            input.className = 'koncept-input';
            input.value = currentKoncept;
            input.placeholder = 'Enter koncept...';
            
            // Replace text with input
            konceptText.style.display = 'none';
            konceptLabel.classList.add('editing');
            konceptLabel.insertBefore(input, konceptText);
            
            // Focus and select text
            input.focus();
            input.select();
            
            // Handle save on Enter or blur
            const saveKoncept = () => {
                const newKoncept = input.value.trim();
                if (newKoncept && newKoncept !== currentKoncept) {
                    // Update the koncept
                    konceptLabel.dataset.koncept = newKoncept;
                    konceptText.textContent = newKoncept.toUpperCase();
                    
                    console.log(`🔄 Koncept ${konceptIndex} updated to: ${newKoncept}`);
                    
                    // Auto-regenerate the row with new koncept
                    regenerateKonceptRow(konceptIndex);
                } else {
                    // Revert if no change or empty
                    konceptText.textContent = currentKoncept.toUpperCase();
                }
                
                // Cleanup
                input.remove();
                konceptText.style.display = '';
                konceptLabel.classList.remove('editing');
            };
            
            // Save on Enter
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKoncept();
                }
            });
            
            // Save on blur (click outside)
            input.addEventListener('blur', saveKoncept);
        }
        
        async function regenerateKonceptRow(konceptIndex) {
            if (isSharedSession) return; // Don't allow regeneration in shared sessions
            if (!currentImageBase64) {
                alert('Please upload an image first');
                return;
            }
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const koncept = konceptLabel.dataset.koncept || `koncept-${konceptIndex}`;
            
            console.log(`🔄 Regenerating row ${konceptIndex} with koncept: ${koncept}`);
            
            // Clear existing results in this row
            for (let i = 0; i < 4; i++) {
                const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                if (resultBox) {
                    updateResultProgress(`result-${konceptIndex}-${i}`, 'REGENERATING...');
                }
            }
            
            // Visual feedback - dim the label
            konceptLabel.style.opacity = '0.7';
            
            try {
                // Generate new images for this koncept
                await autoGenerateKonceptImages(koncept, `koncept-${konceptIndex}`, konceptIndex);
                
                console.log(`✅ Row ${konceptIndex} regenerated successfully`);
                
            } catch (error) {
                console.error(`❌ Error regenerating row ${konceptIndex}:`, error);
                alert(`Failed to regenerate ${koncept} row. Please try again.`);
                
                // Show error state
                for (let i = 0; i < 4; i++) {
                    const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="error-result">
                                <div class="progress-text">❌ REGENERATION FAILED</div>
                            </div>
                        `;
                    }
                }
            } finally {
                // Remove animation
                konceptLabel.style.animation = '';
            }
        }
        
        // Start new session function
        function startNewSession() {
            // Confirm if user wants to start fresh
            const confirmNew = confirm('Start a new session? This will clear the current workspace and create a fresh session.');
            
            if (confirmNew) {
                // Generate new session ID
                currentSessionId = generateSessionId();
                
                // Update URL immediately
                window.history.pushState({}, '', `/session/${currentSessionId}`);
                
                // Reset session state
                sessionResults = [];
                isSharedSession = false;
                currentImageBase64 = null;
                
                // Clear the interface
                clearWorkspace();
                
                // Reset zoom and position
                autoPositionCamera();
                
                // Remove share button if it exists
                const shareButton = document.getElementById('shareButton');
                if (shareButton) {
                    shareButton.remove();
                }
                
                console.log('🆕 New session started:', currentSessionId);
            }
        }
        
        // Clear the workspace for new session
        function clearWorkspace() {
            // Clear right section
            const rightSection = document.getElementById('rightSection');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Clear caption container
            const captionContainer = document.querySelector('.caption-container');
            if (captionContainer) {
                captionContainer.innerHTML = '';
            }
            
            // Reset upload zone
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = '';
                uploadZone.style.opacity = '';
                uploadZone.innerHTML = `
                    <div class="upload-icon">+</div>
                    <div>Drop image here or click to upload</div>
                `;
            }
            
            // Reset counters
            customKonceptCount = 0;
            totalKonceptRows = 3;
            
            console.log('🧹 Workspace cleared');
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initWhiteboard);
    </script>
</body>
</html>