<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE-KONTEXT - Let AI do the prompting for you | BFL Kontext</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #ffffff;
            overflow: hidden;
            height: 100vh;
            color: #1d1d1f;
            font-size: 17px;
            line-height: 1.47;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-weight: 400;
        }

        /* Musical Animations */
        @keyframes audioWave {
            0%, 100% { transform: scaleY(1); }
            25% { transform: scaleY(1.2); }
            50% { transform: scaleY(0.8); }
            75% { transform: scaleY(1.4); }
        }

        @keyframes gentlePulse {
            0%, 100% { border-color: #a8b5a0; }
            50% { border-color: #8fa085; }
        }

        .generating {
            animation: gentlePulse 2s ease-in-out infinite;
        }

        /* Loading animations */
        @keyframes uploadPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-loading {
            animation: uploadPulse 1.5s ease-in-out infinite;
            position: relative;
        }

        .upload-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid #a8b5a0;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .upload-success {
            position: relative;
        }

        .upload-success::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: #a8b5a0;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        /* Loop button overlay - always visible on top */
        .use-as-input-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 80px;
            height: 32px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
            opacity: 1;
            z-index: 20;
            border-radius: 16px;
            backdrop-filter: blur(4px);
        }

        .use-as-input-icon:hover {
            background: rgba(168, 181, 160, 0.9);
            transform: scale(1.05);
        }

        .use-as-input-icon:active {
            transform: scale(0.95);
            background: rgba(168, 181, 160, 1);
        }

        .use-as-input-icon::before {
            content: 'REMIX';
            margin-right: 8px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0.9;
        }

        /* Skeleton loading states */
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }

        .skeleton-tile {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200px 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .skeleton-tile::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #d0d0d0;
            border-top: 2px solid #a8b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .empty-grid-tile {
            background: #fafafa;
            border: 1px dashed #e0e0e0;
            border-radius: 4px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c0c0c0;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            position: relative;
        }

        /* Loading spinner for image cards */
        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #f0f0f0;
            border-top: 3px solid #a8b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px auto;
        }

        .status-text {
            color: #8e8e93;
            font-size: 13px;
            text-align: center;
            margin: 0;
        }

        .image-card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        /* Seed History in Sidebar */
        .seed-history-container {
            background: #ffffff;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: 1px solid #e5e5ea;
        }

        .seed-history-title {
            font-size: 11px;
            font-weight: 600;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            text-align: center;
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .seed-history-title:hover {
            color: #a8b5a0;
            background: rgba(168, 181, 160, 0.1);
        }

        .seed-history-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .seed-thumbnail {
            aspect-ratio: 1;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #e5e5ea;
            position: relative;
        }

        .seed-thumbnail:hover {
            transform: scale(1.05);
            border-color: #a8b5a0;
            box-shadow: 0 2px 8px rgba(168, 181, 160, 0.3);
        }

        .seed-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .seed-thumbnail-number {
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(45, 45, 45, 0.8);
            color: white;
            font-size: 8px;
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
            min-width: 12px;
            text-align: center;
        }

        .seed-thumbnail.current {
            border-color: #a8b5a0;
            border-width: 2px;
            box-shadow: 0 0 0 1px rgba(168, 181, 160, 0.3);
        }

        /* Tufte-inspired Iteration Sequence Modal */
        .comic-strip-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .comic-strip-modal.show {
            opacity: 1;
        }

        .comic-strip-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 40px;
            box-sizing: border-box;
        }

        .comic-strip-header {
            text-align: center;
            margin-bottom: 48px;
            max-width: 600px;
        }

        .comic-strip-header h2 {
            font-size: 24px;
            font-weight: 400;
            margin: 0 0 8px 0;
            color: #2d2d2d;
            letter-spacing: -0.02em;
        }

        .comic-strip-header p {
            font-size: 16px;
            color: #666;
            margin: 0;
            font-weight: 300;
            line-height: 1.4;
        }

        .comic-strip-sequence {
            display: flex;
            gap: 1px;
            max-width: 95vw;
            overflow-x: auto;
            padding: 0;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            margin-bottom: 48px;
            border: 1px solid #e0e0e0;
        }

        .comic-panel {
            flex-shrink: 0;
            width: 240px;
            background: white;
            border-radius: 0;
            overflow: hidden;
            border: none;
            border-right: 1px solid #e0e0e0;
            box-shadow: none;
            position: relative;
        }

        .comic-panel:last-child {
            border-right: none;
        }

        .comic-panel:first-child::before {
            content: '1';
            position: absolute;
            top: 12px;
            left: 12px;
            background: transparent;
            color: #999;
            padding: 0;
            border-radius: 0;
            font-size: 14px;
            font-weight: 300;
            z-index: 2;
            font-family: 'Georgia', serif;
        }

        .comic-panel:last-child::after {
            content: attr(data-step);
            position: absolute;
            top: 12px;
            right: 12px;
            background: transparent;
            color: #333;
            padding: 0;
            border-radius: 0;
            font-size: 14px;
            font-weight: 400;
            z-index: 2;
            font-family: 'Georgia', serif;
        }

        .comic-panel-header {
            background: transparent;
            padding: 0;
            border-bottom: none;
            text-align: left;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(255,255,255,0.95) 60%);
            z-index: 1;
        }

        .comic-panel-number {
            font-size: 11px;
            font-weight: 400;
            color: #666;
            margin: 0;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comic-panel-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
        }

        .comic-panel-title {
            padding: 8px 12px 12px 12px;
            background: transparent;
            border-top: none;
            text-align: left;
            font-size: 12px;
            font-weight: 300;
            color: #333;
            margin: 0;
            line-height: 1.3;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .comic-strip-controls {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .comic-control-btn {
            background: transparent;
            color: #333;
            border: 1px solid #ddd;
            padding: 12px 24px;
            border-radius: 0;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.02em;
        }

        .comic-control-btn:hover {
            background: #f5f5f5;
            border-color: #999;
            transform: none;
        }

        .comic-control-btn.secondary {
            background: transparent;
            border-color: #ccc;
            color: #666;
        }

        .comic-control-btn.secondary:hover {
            background: #f9f9f9;
            border-color: #999;
            color: #333;
        }

        .comic-close-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
            font-size: 16px;
            width: 32px;
            height: 32px;
            border-radius: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .comic-close-btn:hover {
            background: #f5f5f5;
            border-color: #999;
            color: #333;
        }

        /* Minimal responsive adjustments */
        @media (max-width: 768px) {
            .comic-strip-content {
                padding: 40px 20px;
            }
            
            .comic-strip-sequence {
                gap: 0;
            }
            
            .comic-panel {
                width: 200px;
            }
            
            .comic-panel-image {
                height: 250px;
            }
            
            .comic-strip-header h2 {
                font-size: 20px;
            }
        }

        .whiteboard-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: auto;
            cursor: default;
        }


        .canvas-surface {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: 100vh;
            gap: 0;
            padding: 0;
        }
        
        /* Mobile layout adjustments */
        @media (max-width: 768px) {
            .canvas-surface {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: 8px;
                padding: 8px;
            }
            
            .left-section {
                padding: 16px;
                max-height: 40vh;
            }
            
            .right-section {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 12px;
                padding: 16px;
            }
            
            .image-card {
                min-height: 300px;
            }
        }

        /* Left Section - Controls and Analysis */
        .left-section {
            background: linear-gradient(180deg, #f8f8f8 0%, #f2f2f2 100%);
            padding: 40px 32px;
            display: flex;
            flex-direction: column;
            gap: 32px;
            overflow: hidden;
            height: 100vh;
            border-right: 2px solid #a8b5a0;
        }

        /* Right Section - High Velocity Grid */
        .right-section {
            background: #ffffff;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            grid-auto-rows: max-content;
            gap: 4px;
            align-content: start;
            overflow-y: auto;
        }
        

        /* Individual Image Card - Maximum Image Space */
        .image-card {
            background: #ffffff;
            display: block;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            overflow: hidden;
            width: 100%;
            height: auto;
            box-sizing: border-box;
            border: none;
        }
        
        .image-card:hover {
            transform: scale(1.01);
            z-index: 10;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.05);
        }
        
        
        .image-card-header {
            display: none;
        }
        
        .image-card-content {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            position: relative;
        }
        
        .image-card img {
            width: 100%;
            height: auto;
            object-fit: none;
            cursor: pointer;
            border-radius: 0;
            display: block;
        }
        
        /* Mobile koncept labels */
        @media (max-width: 768px) {
            .koncept-label {
                padding: 12px 8px;
                font-size: 8px;
            }
            
            .koncept-label:hover {
                transform: none;
                box-shadow: 2px 2px 0px #fff;
            }
        }
        
        /* Editable koncept input */
        .koncept-input {
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: center;
            width: 100%;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .koncept-input::placeholder {
            color: #666;
            opacity: 0.7;
        }
        

        /* Upload Area Styling */
        .upload-container {
            margin-bottom: 12px;
        }

        .upload-preview {
            margin-bottom: 20px;
        }

        .canvas-element.dragging {
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        /* Mobile canvas elements */
        @media (max-width: 768px) {
            .canvas-element {
                box-shadow: 2px 2px 0px #fff;
                border-width: 2px;
            }
            
            .canvas-element:hover {
                box-shadow: 2px 2px 0px #fff;
                transform: none;
            }
        }

        /* Left Section Items */
        .title-container {
            grid-area: 1;
        }
        
        .upload-container {
            grid-area: 2;
        }
        
        .caption-container {
            grid-area: 3;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Title Box */
        .title-box {
            width: 100%;
            height: auto;
        }

        .title-text {
            font-size: 24px;
            line-height: 1.2;
            color: #1c1c1e;
            padding: 0 0 8px 0;
            font-weight: 700;
            text-align: left;
            margin-bottom: 12px;
        }

        .subtitle-text {
            font-size: 14px;
            line-height: 1.4;
            color: #1c1c1e;
            padding: 0 0 8px 0;
            font-weight: 400;
            text-align: left;
            opacity: 0.7;
            margin-bottom: 8px;
        }
        
        
        .attribution {
            font-size: 12px;
            line-height: 1.4;
            color: #1c1c1e;
            padding: 16px 0 0 0;
            font-weight: 400;
            text-align: left;
            opacity: 0.6;
            margin-top: auto;
        }
        
        .attribution a {
            color: #1c1c1e;
            text-decoration: none;
            font-weight: 500;
        }
        
        .attribution a:hover {
            text-decoration: underline;
        }
        
        /* Mobile title and subtitle */
        @media (max-width: 768px) {
            .title-text {
                font-size: 16px;
                padding: 12px;
                letter-spacing: 1px;
            }
            
            .subtitle-text {
                font-size: 9px;
                padding: 0 12px 6px 12px;
            }
            
            .value-prop {
                font-size: 8px;
                padding: 0 12px 6px 12px;
            }
            
            .attribution {
                font-size: 7px;
                padding: 0 12px 12px 12px;
            }
        }

        /* Add Koncept Button and Input */
        .add-koncept-btn {
            width: 100%;
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #e5e5e7;
            border-radius: 8px;
            padding: 16px 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-family: inherit;
        }

        .add-koncept-btn:hover {
            background: #a8b5a0;
            color: #ffffff;
            border-color: #a8b5a0;
            transform: none;
            box-shadow: none;
        }

        .custom-koncept-input {
            width: 100%;
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #e5e5e7;
            border-radius: 8px;
            padding: 16px 20px;
            font-size: 14px;
            font-weight: 400;
            font-family: inherit;
            margin-top: 12px;
            outline: none;
            transition: all 0.1s ease;
        }

        .custom-koncept-input::placeholder {
            color: #aeaeb2;
        }

        .custom-koncept-input:focus {
            background: #ffffff;
            border-color: #a8b5a0;
            box-shadow: 0 0 0 2px rgba(168, 181, 160, 0.2);
        }

        .generate-custom-btn {
            width: 100%;
            background: #2d2d2d;
            color: #ffffff;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 14px 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: inherit;
            box-shadow: none;
        }

        .generate-custom-btn:hover {
            background: #1a1a1a;
            border-color: #505050;
            transform: none;
            box-shadow: none;
        }

        .generate-custom-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .generate-custom-btn:disabled:hover {
            background: #2d2d2d;
            border-color: #404040;
            transform: none;
            box-shadow: none;
        }

        /* Empty State Row for Add Custom Koncept */
        .add-koncept-row {
            display: contents;
        }

        .add-koncept-label {
            background: #f8f8f8;
            color: #8e8e93;
            border-radius: 2px;
            padding: 12px 16px;
            font-size: 10px;
            font-weight: 500;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            align-items: center;
            word-break: break-word;
            cursor: pointer;
            transition: all 0.15s ease;
            grid-column: 1 / -1; /* Span all columns like koncept headers */
            min-height: 48px;
        }

        .add-koncept-label:hover {
            background: #a8b5a0;
            color: #ffffff;
            transform: none;
            box-shadow: none;
        }

        .add-koncept-empty-box {
            background: #fafafa;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999999;
            font-size: 11px;
            font-weight: 400;
            text-align: center;
            height: 100%;
            min-height: 450px;
        }

        /* Right Section - Generation Results (header spans all columns, images below) */
        .grid-koncept-label-0 { grid-column: 1 / -1; grid-row: 1; }
        .grid-result-0-0 { grid-column: 1; grid-row: 2; }
        .grid-result-0-1 { grid-column: 2; grid-row: 2; }
        .grid-result-0-2 { grid-column: 3; grid-row: 2; }
        .grid-result-0-3 { grid-column: 4; grid-row: 2; }
        
        .grid-koncept-label-1 { grid-column: 1 / -1; grid-row: 3; }
        .grid-result-1-0 { grid-column: 1; grid-row: 4; }
        .grid-result-1-1 { grid-column: 2; grid-row: 4; }
        .grid-result-1-2 { grid-column: 3; grid-row: 4; }
        .grid-result-1-3 { grid-column: 4; grid-row: 4; }
        
        .grid-koncept-label-2 { grid-column: 1 / -1; grid-row: 5; }
        .grid-result-2-0 { grid-column: 1; grid-row: 6; }
        .grid-result-2-1 { grid-column: 2; grid-row: 6; }
        .grid-result-2-2 { grid-column: 3; grid-row: 6; }
        .grid-result-2-3 { grid-column: 4; grid-row: 6; }

        /* Element Header - Clean Minimal */
        .element-header {
            padding: 0;
            background: transparent;
            font-weight: 600;
            font-size: 24px;
            color: #1d1d1f;
            text-transform: none;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: none;
            margin-bottom: 12px;
            font-family: inherit;
        }
        
        /* Mobile element headers */
        @media (max-width: 768px) {
            .element-header {
                padding: 6px 10px;
                font-size: 9px;
                border-bottom-width: 1px;
            }
        }

        .element-content {
            padding: 20px;
        }
        
        .upload-box .element-content {
            padding: 12px;
            height: calc(100% - 48px);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 120px;
            overflow: hidden;
        }
        
        .start-button, .change-button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        
        .start-button {
            background: #2d2d2d;
            color: #ffffff;
            box-shadow: none;
        }
        
        .start-button:hover {
            background: #1a1a1a;
            transform: none;
            box-shadow: none;
        }
        
        .change-button {
            background: #f5f5f7;
            color: #1c1c1e;
            border: 1px solid #e5e5e7;
        }
        
        .change-button:hover {
            background: #e5e5e7;
        }

        /* Upload Box */
        .upload-box {
            width: 100%;
            height: auto;
            min-height: 200px;
        }

        .upload-zone {
            padding: 16px;
            text-align: center;
            color: #8e8e93;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.1s ease;
            width: 100%;
            aspect-ratio: 1 / 1;
            min-width: 180px;
            max-width: 340px;
            min-height: unset;
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            opacity: 1;
            border: 1px solid #c0c0c0;
            border-radius: 0;
            font-family: inherit;
        }

        .upload-zone:hover {
            background: #ffffff;
            border-color: #d2d2d7;
        }

        .upload-zone.dragover {
            background: #f0f0f0;
            border-color: #d2d2d7;
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 12px;
            font-weight: 300;
            color: inherit;
        }

        /* Image Preview */
        .image-preview {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        /* Image Container */
        .image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        
        .image-container .image-preview {
            margin-bottom: 0;
        }
        
        .result-image-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }
        
        /* Start Button */
        .start-button {
            width: 100%;
            background: #2d2d2d;
            color: #ffffff;
            padding: 16px 24px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 20px;
            flex-shrink: 0;
            border-radius: 4px;
            border: 1px solid #404040;
            box-shadow: none;
            text-transform: none;
            letter-spacing: 0;
        }
        
        .start-button:hover {
            background: #1a1a1a;
            border-color: #505050;
            transform: none;
            box-shadow: none;
        }
        
        .start-button:active {
            background: #0d0d0d;
            border-color: #606060;
            transform: none;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        /* Change Button */
        .change-button {
            width: 100%;
            background: #FFFFFF;
            color: #1c1c1e;
            padding: 14px 18px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-top: 16px;
            flex-shrink: 0;
            opacity: 0.8;
        }
        
        .change-button:hover {
            opacity: 1;
            background: #f2f2f7;
            color: #FFFFFF;
        }

        /* Caption Box */
        .caption-box {
            width: 100%;
            height: 100%;
            min-height: 200px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .caption-box .element-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .caption-text {
            font-size: 14px;
            line-height: 1.5;
            color: #1c1c1e;
            padding: 0;
            font-weight: 400;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .vibe-text {
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 0.8px;
            color: #fff;
        }

        /* Vibe Node */
        .vibe-node {
            width: 100%;
            height: 80px;
            background: #f2f2f7;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .vibe-node:hover {
            background: #FFFFFF;
            color: #1c1c1e;
        }

        .vibe-node.selected {
            opacity: 0.8;
        }


        /* Image Result Box */
        .result-box {
            width: 100%;
            height: 100%;
            min-height: 300px;
        }

        .result-image {
            width: 100%;
            height: calc(100% - 80px);
            min-height: 220px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }
        
        .result-image-container {
            position: relative;
            width: 100%;
            height: calc(100% - 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .image-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 2;
        }
        

        .result-prompt {
            font-size: 12px;
            color: #1c1c1e;
            line-height: 1.4;
            max-height: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
            opacity: 0.7;
        }

        /* Remove connection styling - using grid layout instead */

        
        /* Enhanced entrance animations */
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-100px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes pulseGeneration {
            0%, 100% {
                background: #FFFFFF;
                opacity: 1;
            }
            50% {
                background: #f2f2f7;
                opacity: 0.8;
            }
        }
        
        .generating {
            animation: pulseGeneration 2s ease-in-out infinite;
        }

        /* Controls */
        .canvas-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .control-btn {
            background: #f2f2f7;
            padding: 12px 18px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            color: #FFFFFF;
        }

        .control-btn:hover {
            background: #FFFFFF;
            color: #1c1c1e;
        }
        
        /* Inline home button styling in title header */
        .home-btn-inline {
            background: #f5f5f7;
            border: 1px solid #e5e5e7;
            border-radius: 6px;
            color: #aeaeb2;
            font-size: 11px;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.1s ease;
            margin-left: auto;
            outline: none;
            font-weight: 500;
        }
        
        .home-btn-inline::before {
            content: "RESET";
            font-size: 8px;
            font-weight: 600;
        }
        
        .home-btn-inline:hover {
            background: #0071e3;
            color: #fff;
            border-color: #0071e3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 113, 227, 0.3);
        }
        
        .home-btn-inline:active {
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Mobile home button */
        @media (max-width: 768px) {
            .home-btn-inline {
                padding: 3px 5px;
                font-size: 10px;
                box-shadow: 1px 1px 0px #fff;
                border-width: 1px;
            }
            
            .home-btn-inline::before {
                font-size: 8px;
            }
            
            .home-btn-inline:hover {
                transform: none;
                box-shadow: 1px 1px 0px #fff;
            }
        }


        /* Teenage Engineering Progress States */
        .progress-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 80px;
        }

        .progress-bar {
            width: 80%;
            height: 4px;
            background: rgba(242, 242, 247, 0.8);
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: #f2f2f7;
            animation: progressSlide 2s infinite;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            background: #f2f2f7;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .progress-text {
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            color: #1c1c1e;
            opacity: 0.7;
        }

        .blank-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        .blank-image {
            width: 100%;
            height: 160px;
            background: #FFFFFF;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            opacity: 0.5;
        }

        .blank-image::after {
            content: '□';
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 24px;
            color: #1c1c1e;
            transform: translate(-50%, -50%);
            opacity: 0.3;
        }

        @keyframes progressSlide {
            0% { left: -100%; }
            100% { left: 100%; }
        }


        /* Loading States */
        .loading {
            opacity: 0.8;
        }
        
        /* Image Cards for responsive grid */
        .image-card {
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            min-height: 300px;
        }
        
        
        .image-card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .loading-cards {
            display: contents;
        }
        
        .loading-card {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            animation: pulseLoading 2s ease-in-out infinite;
        }
        
        .loading-card::after {
            content: 'Loading...';
            color: #666;
            font-weight: 500;
        }
        
        @keyframes pulseLoading {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.8; }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #d2d2d7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-text {
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        
        .error-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #d32f2f;
            font-weight: 500;
        }

        /* Hide original canvas section */
        .canvas-section { display: none; }

        /* Image Modal Styles */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: zoom-out;
        }

        .image-modal.show {
            opacity: 1;
        }

        .modal-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .image-modal.show .modal-image {
            transform: scale(1);
        }

        .modal-close {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            transition: all 0.1s ease;
            backdrop-filter: blur(10px);
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .modal-info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 24px;
            color: #fff;
            font-family: inherit;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-info h3 {
            margin: 0 0 12px 0;
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #0071e3;
        }

        .modal-info p {
            margin: 0;
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.95;
            max-height: 140px;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        /* Modal Navigation */
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            cursor: pointer;
            transition: all 0.1s ease;
            backdrop-filter: blur(15px);
            user-select: none;
        }

        .modal-nav:hover {
            background: rgba(0, 113, 227, 0.8);
            border-color: #0071e3;
            transform: translateY(-50%) scale(1.05);
        }

        .modal-nav.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav.disabled:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1);
        }

        .modal-nav-left {
            left: 30px;
        }

        .modal-nav-right {
            right: 30px;
        }

        .modal-counter {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 8px 16px;
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .whiteboard-container {
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }
            
            .canvas-surface {
                position: static;
                height: auto;
                min-height: 100vh;
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .right-section {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
            
            /* Mobile koncept grid - single column with koncept above each row */
            .mobile-koncept-row {
                display: grid;
                grid-template-columns: 1fr;
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .mobile-results-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .canvas-element {
                min-height: 120px;
            }
            
            .result-box {
                min-height: 250px;
            }
            
            .result-image {
                height: 180px;
                min-height: 160px;
            }
            
            .element-content {
                padding: 8px;
            }
            
            /* Mobile controls */
            .canvas-controls {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                flex-wrap: wrap;
                justify-content: center;
                max-width: 90vw;
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 9px;
                margin: 2px;
            }
            
            .zoom-indicator {
                bottom: 60px;
                left: 10px;
                font-size: 10px;
                padding: 4px 8px;
            }
            
            /* Mobile upload zone */
            .upload-zone {
                min-height: 100px;
                padding: 15px;
            }
            
            .upload-icon {
                font-size: 20px;
            }
            
            /* Mobile caption box */
            .caption-text {
                font-size: 11px;
                padding: 8px;
            }
            
            /* Touch-friendly sizing */
            .koncept-text {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .canvas-surface {
                padding: 8px;
                gap: 8px;
            }
            
            .left-section, .right-section {
                padding: 12px;
            }
            
            .right-section {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(8, 1fr);
            }
            
            .mobile-results-grid {
                grid-template-columns: 1fr;
            }
            
            .control-btn {
                padding: 6px 10px;
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="whiteboard-container" id="whiteboardContainer">
        <div class="canvas-surface" id="canvasSurface">
            <!-- Left Section - 30% -->
            <div class="left-section">
                <!-- Title Box -->
                <div class="title-container">
                    <div class="canvas-element title-box">
                        <div class="element-header">
                            RE-KONTEXT
                            <button class="home-btn-inline" onclick="resetApp()" title="Reset App"></button>
                        </div>
                        <div class="element-content">
                            <div class="subtitle-text">Let AI do the prompting for you</div>
                            <div class="attribution">A <a href="https://bfl.ai/" target="_blank">BFL Kontext</a> experiment</div>
                        </div>
                    </div>
                </div>
                
                <!-- Upload Box -->
                <div class="upload-container">
                    <div class="canvas-element upload-box" id="uploadElement">
                        <div class="element-content">
                            <div class="upload-zone" id="uploadZone">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8e8e93" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="margin-bottom: 16px;">
                                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                </svg>
                                <div style="font-size: 18px; font-weight: 600; color: #8e8e93; margin-bottom: 6px;">Upload Image</div>
                                <div style="font-size: 14px; color: #666; line-height: 1.4;">Drop or click to start generating</div>
                                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Seed History Container -->
                <div class="seed-history-container" id="seedHistoryContainer" style="display: none;">
                    <div class="seed-history-title" onclick="openComicStripModal()" title="Click to view as comic strip">
                        Iteration History 🎬
                    </div>
                    <div class="seed-history-grid" id="seedHistoryGrid">
                        <!-- Seed thumbnails will be added dynamically -->
                    </div>
                </div>
                
                <!-- Caption Box Container -->
                <div class="caption-container">
                    <!-- Caption will be added dynamically -->
                </div>
            </div>
            
            <!-- Right Section - 70% for Generations -->
            <div class="right-section" id="rightSection">
                <!-- Results will be added dynamically -->
            </div>
        </div>
    </div>


    <!-- Image Modal -->
    <div class="image-modal" id="imageModal" style="display: none;">
        <div class="modal-counter" id="modalCounter">1 / 12</div>
        <div class="modal-close" onclick="closeImageModal()">×</div>
        <div class="modal-nav modal-nav-left" id="modalPrev" onclick="navigateModal(-1)">‹</div>
        <div class="modal-nav modal-nav-right" id="modalNext" onclick="navigateModal(1)">›</div>
        <img class="modal-image" id="modalImage" src="" alt="Expanded view">
        <div class="modal-info" id="modalInfo">
            <h3 id="modalTitle">Generation Result</h3>
            <p id="modalPrompt">Prompt will appear here</p>
        </div>
    </div>

    <script>
        // Global state
        let currentImageBase64 = null;
        
        // Modal navigation state
        let modalImages = [];
        let currentModalIndex = 0;
        let modalPrompts = {}; // Store prompts by unique ID
        let promptIdCounter = 0;
        
        // Generate unique prompt ID and store prompt
        function storePrompt(promptText) {
            const promptId = `prompt_${promptIdCounter++}`;
            modalPrompts[promptId] = promptText || 'AI generated transformation';
            return promptId;
        }
        
        // Custom koncept state
        let customKonceptCount = 0;
        let totalKonceptRows = 3; // Start with 3 default koncepts
        
        // Polling function for async generation
        async function pollForCompletion(requestId, imageIndex) {
            const maxAttempts = 60; // 60 attempts × 3 seconds = 3 minutes max
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                try {
                    console.log(`🔍 Polling attempt ${attempts + 1} for image ${imageIndex}, requestId: ${requestId}`);
                    
                    const statusResponse = await fetch(`/api/check-generation/${requestId}`);
                    if (!statusResponse.ok) {
                        throw new Error(`Status check failed: ${statusResponse.status}`);
                    }
                    
                    const statusResult = await statusResponse.json();
                    console.log(`📊 Status for image ${imageIndex}:`, statusResult.status);
                    
                    if (statusResult.status === 'completed') {
                        console.log(`✅ Image ${imageIndex} generation completed!`);
                        return statusResult;
                    } else if (statusResult.status === 'error') {
                        throw new Error(statusResult.error || 'Generation failed');
                    }
                    
                    // Still processing, wait and try again
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    attempts++;
                    
                } catch (error) {
                    console.error(`❌ Polling error for image ${imageIndex}:`, error);
                    if (attempts >= 5) { // Give up after 5 failed polling attempts
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    attempts++;
                }
            }
            
            throw new Error('Generation timeout - exceeded maximum polling time');
        }
        
        // Session management
        let currentSessionId = null;
        let sessionResults = [];
        let seedHistory = []; // Track iteration history
        
        // Seed history management functions
        function addToSeedHistory(imageUrl, title, isOriginal = false) {
            const seedData = {
                imageUrl: imageUrl,
                title: title,
                timestamp: Date.now(),
                isOriginal: isOriginal
            };
            
            seedHistory.push(seedData);
            updateSeedHistoryDisplay();
            console.log('📜 Added to seed history:', title);
        }
        
        function updateSeedHistoryDisplay() {
            const container = document.getElementById('seedHistoryContainer');
            const grid = document.getElementById('seedHistoryGrid');
            
            if (!container || !grid) return;
            
            // Show container if we have history
            if (seedHistory.length > 0) {
                container.style.display = 'block';
            }
            
            // Clear existing thumbnails
            grid.innerHTML = '';
            
            // Add thumbnails for each seed
            seedHistory.forEach((seed, index) => {
                const thumbnail = document.createElement('div');
                thumbnail.className = 'seed-thumbnail';
                if (index === seedHistory.length - 1) {
                    thumbnail.classList.add('current');
                }
                
                thumbnail.innerHTML = `
                    <img src="${seed.imageUrl}" alt="${seed.title}">
                    <div class="seed-thumbnail-number">${index + 1}</div>
                `;
                
                // Add click handler to view in modal
                thumbnail.onclick = () => {
                    const promptId = storePrompt(`${seed.title} (iteration ${index + 1})`);
                    openImageModal(seed.imageUrl, seed.title, promptId);
                };
                
                grid.appendChild(thumbnail);
            });
        }
        
        function clearSeedHistory() {
            seedHistory = [];
            const container = document.getElementById('seedHistoryContainer');
            if (container) {
                container.style.display = 'none';
            }
            console.log('🗑️ Cleared seed history');
        }
        
        // Comic Strip Modal Functions
        function openComicStripModal() {
            console.log('🎬 Opening comic strip modal');
            
            if (seedHistory.length === 0) {
                alert('No iteration history available to display.');
                return;
            }
            
            const modal = document.getElementById('comicStripModal');
            const sequence = document.getElementById('comicStripSequence');
            
            // Clear existing panels
            sequence.innerHTML = '';
            
            // Generate comic panels for each iteration
            seedHistory.forEach((seed, index) => {
                const panel = document.createElement('div');
                panel.className = 'comic-panel';
                panel.setAttribute('data-step', index + 1);
                
                panel.innerHTML = `
                    <img src="${seed.imageUrl}" alt="${seed.title}" class="comic-panel-image">
                    <div class="comic-panel-header">
                        <p class="comic-panel-number">Step ${index + 1}</p>
                        <div class="comic-panel-title">${seed.title}</div>
                    </div>
                `;
                
                sequence.appendChild(panel);
            });
            
            // Show modal with animation
            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('show'), 10);
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // Add escape key listener
            document.addEventListener('keydown', handleComicStripEscape);
        }
        
        function closeComicStripModal() {
            console.log('🎬 Closing comic strip modal');
            
            const modal = document.getElementById('comicStripModal');
            
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
            
            // Remove escape key listener
            document.removeEventListener('keydown', handleComicStripEscape);
        }
        
        function downloadComicStrip() {
            console.log('📸 Downloading comic strip');
            
            const sequence = document.getElementById('comicStripSequence');
            
            // Use html2canvas to capture the sequence
            if (typeof html2canvas !== 'undefined') {
                html2canvas(sequence, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Higher resolution
                    useCORS: true,
                    allowTaint: true
                }).then(canvas => {
                    // Create download link
                    const link = document.createElement('a');
                    link.download = `re-kontext-sequence-${Date.now()}.png`;
                    link.href = canvas.toDataURL();
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    console.log('✅ Comic strip downloaded successfully');
                }).catch(error => {
                    console.error('❌ Error capturing comic strip:', error);
                    // Fallback: copy sequence as image to clipboard or show sharing options
                    alert('Download failed. Try taking a screenshot of the sequence instead.');
                });
            } else {
                // Fallback without html2canvas
                alert('To download, please take a screenshot of this sequence. We recommend using your browser\'s screenshot feature or a screenshot tool.');
            }
        }
        
        function handleComicStripEscape(e) {
            if (e.key === 'Escape') {
                closeComicStripModal();
            }
        }
        
        // Individual image sharing function
        function shareIndividualImage(event, konceptIndex, resultIndex) {
            event.stopPropagation(); // Prevent image modal from opening
            
            if (!currentSessionId) {
                alert('Session not available for sharing');
                return;
            }
            
            const shareUrl = `${window.location.origin}/image/${currentSessionId}/${konceptIndex}/${resultIndex}`;
            
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✅ Copied!';
                button.style.background = '#4CAF50';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback - show URL in prompt
                prompt('Copy this share URL:', shareUrl);
            });
            
            console.log('🔗 Individual image share URL:', shareUrl);
        }
        let isSharedSession = false;


        // DOM elements
        const container = document.getElementById('whiteboardContainer');
        const surface = document.getElementById('canvasSurface');
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');

        // Initialize the app
        function initWhiteboard() {
            setupEventListeners();
            
            // Check if this is a shared session
            checkForSharedSession();
            
            // Handle mobile layout
            handleMobileLayout();
        }
        
        // Handle mobile-specific layout adjustments
        function handleMobileLayout() {
            if (window.innerWidth <= 768) {
                // Mobile-specific adjustments if needed
                const controls = document.querySelector('.canvas-controls');
                if (controls) {
                    controls.style.display = 'none';
                }
                // Zoom indicator functionality removed
            }
        }
        
        // Handle window resize for mobile responsiveness
        window.addEventListener('resize', () => {
            handleMobileLayout();
        });
        
        // Check if we're loading a shared session
        function checkForSharedSession() {
            const path = window.location.pathname;
            const sessionMatch = path.match(/^\/session\/([a-f0-9]+)$/);
            
            if (sessionMatch) {
                const sessionId = sessionMatch[1];
                console.log('🔗 Loading shared session:', sessionId);
                loadSharedSession(sessionId);
            } else {
                // Generate new session ID for new sessions
                currentSessionId = generateSessionId();
                console.log('🆕 New session created:', currentSessionId);
                
                // Update URL immediately for new sessions
                window.history.replaceState({}, '', `/session/${currentSessionId}`);
            }
        }
        
        // Generate a random session ID
        function generateSessionId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(8)))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // Load a shared session from the server
        async function loadSharedSession(sessionId) {
            try {
                isSharedSession = true;
                currentSessionId = sessionId;
                
                console.log('📥 Fetching session data...');
                const response = await fetch(`/api/session/${sessionId}`);
                
                if (!response.ok) {
                    throw new Error('Session not found');
                }
                
                const sessionData = await response.json();
                console.log('✅ Session data loaded:', sessionData);
                
                // Load the original image
                if (sessionData.originalImage) {
                    const imageBlob = await fetch(`data:image/jpeg;base64,${sessionData.originalImage}`).then(r => r.blob());
                    const file = new File([imageBlob], 'shared-image.jpg', { type: 'image/jpeg' });
                    await processImageFile(file);
                    
                    // Set the base64 for future operations
                    currentImageBase64 = sessionData.originalImage;
                }
                
                // Load the results
                loadSessionResults(sessionData.results);
                
                // Load the caption if it exists
                if (sessionData.caption) {
                    console.log('🔄 Loading session caption:', sessionData.caption);
                    fillCaptionBox(sessionData.caption);
                }
                
                // Load the koncept names if they exist
                if (sessionData.konceptNames && Array.isArray(sessionData.konceptNames)) {
                    console.log('🔄 Loading session koncept names:', sessionData.konceptNames);
                    fillKonceptLabels(sessionData.konceptNames);
                }
                
                // Disable upload for shared sessions
                disableUploadForSharedSession();
                
            } catch (error) {
                console.log('📝 Session not found in database, treating as new session:', sessionId);
                
                // Don't show error alert - this is normal for new sessions
                // Keep the session ID from the URL and treat as a new session
                currentSessionId = sessionId;
                isSharedSession = false;
                
                // No need to update URL since it's already correct
                console.log('✅ New session initialized with ID:', currentSessionId);
            }
        }
        
        // Load session results into the interface
        function loadSessionResults(results) {
            console.log('🔄 Loading session results:', results);
            
            // Create the layout structure
            createBlankLayout();
            
            // Group results by concept (assuming 4 results per concept)
            const concepts = [];
            for (let i = 0; i < results.length; i += 4) {
                concepts.push(results.slice(i, i + 4));
            }
            
            concepts.forEach((conceptResults, conceptIndex) => {
                if (conceptIndex < 3) { // First 3 are the default concepts
                    const konceptLabel = document.getElementById(`koncept-label-${conceptIndex}`);
                    if (konceptLabel) {
                        konceptLabel.innerHTML = `KONCEPT ${conceptIndex + 1}`;
                    }
                    
                    // Fill in the results
                    conceptResults.forEach((result, resultIndex) => {
                        if (result.image) {
                            displaySharedResult(conceptIndex, resultIndex, result);
                        }
                    });
                }
            });
        }
        
        // Display a shared session result
        function displaySharedResult(conceptIndex, resultIndex, result) {
            const resultBoxId = `result-${conceptIndex}-${resultIndex}`;
            const resultBox = document.getElementById(resultBoxId);
            
            if (resultBox && result.image) {
                const content = resultBox.querySelector('.element-content');
                const imageUrl = `data:image/jpeg;base64,${result.image}`;
                const promptId = storePrompt(result.prompt);
                
                content.innerHTML = `
                    <div class="result-image-container">
                        <img src="${imageUrl}" class="result-image" data-prompt-id="${promptId}" style="
                            cursor: zoom-in;
                        " onclick="openImageModal('${imageUrl}', 'KONCEPT ${conceptIndex + 1} #${resultIndex + 1}', '${promptId}')">
                    </div>
                `;
                
                // Success visual feedback
                resultBox.style.background = '#fff';
                resultBox.style.color = '#000';
            }
        }
        
        // Disable upload functionality for shared sessions
        function disableUploadForSharedSession() {
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = 'none';
                uploadZone.style.opacity = '0.5';
                uploadZone.innerHTML = '<div style="color: #666;">Viewing shared session</div>';
            }
        }

        function setupEventListeners() {
            // Upload functionality
            uploadZone.addEventListener('click', () => fileInput.click());
            uploadZone.addEventListener('dragover', handleDragOver);
            uploadZone.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', handleFileSelect);

            // Prevent default drag behavior
            document.addEventListener('dragover', e => e.preventDefault());
            document.addEventListener('drop', e => e.preventDefault());
            
            // Handle window resize to auto-reposition
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only auto-reposition if we have content on screen
                    const rightSection = document.querySelector('.right-section');
                    if (rightSection && rightSection.children.length > 0) {
                        autoPositionCamera();
                    }
                }, 300); // Debounce resize events
            });
        }

        // Removed zoom/pan functionality for simpler scrolling interface

        function handleMouseUp(e) {
            if (isDragging && dragElement) {
                dragElement.classList.remove('dragging');
                dragElement = null;
                isDragging = false;
            }
            
            if (isPanning) {
                isPanning = false;
                container.classList.remove('grabbing');
                
                // Start inertia animation if there's enough velocity
                if (panHistory.length > 1) {
                    // Calculate average velocity from recent history
                    const avgVelocity = panHistory.reduce((acc, entry) => {
                        acc.x += entry.velocity.x;
                        acc.y += entry.velocity.y;
                        return acc;
                    }, { x: 0, y: 0 });
                    
                    avgVelocity.x /= panHistory.length;
                    avgVelocity.y /= panHistory.length;
                    
                    // Only start inertia if velocity is significant
                    const velocityMagnitude = Math.sqrt(avgVelocity.x * avgVelocity.x + avgVelocity.y * avgVelocity.y);
                    if (velocityMagnitude > 0.5) {
                        startInertiaAnimation(avgVelocity);
                    }
                }
            }
        }

        function startInertiaAnimation(initialVelocity) {
            let currentVelocity = { ...initialVelocity };
            const friction = 0.92; // Deceleration factor
            const minVelocity = 0.1; // Stop threshold
            
            function animate() {
                // Apply velocity to position
                panX += currentVelocity.x * 0.8; // Reduce sensitivity for inertia too
                panY += currentVelocity.y * 0.8;
                
                // Apply friction
                currentVelocity.x *= friction;
                currentVelocity.y *= friction;
                
                updateTransform();
                
                // Continue animation if velocity is still significant
                const velocityMagnitude = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);
                if (velocityMagnitude > minVelocity) {
                    inertiaAnimation = requestAnimationFrame(animate);
                } else {
                    inertiaAnimation = null;
                }
            }
            
            animate();
        }

        let isUpdating = false;
        
        function handleWheel(e) {
            e.preventDefault();
            
            // Throttle updates for performance
            if (isUpdating) return;
            isUpdating = true;
            
            // Stop inertia when user starts zooming
            if (inertiaAnimation) {
                cancelAnimationFrame(inertiaAnimation);
                inertiaAnimation = null;
            }
            
            // Smooth zoom with smaller increments
            const zoomSensitivity = 0.05; // Slightly increased for responsiveness
            const delta = e.deltaY > 0 ? -zoomSensitivity : zoomSensitivity;
            const newZoom = Math.max(0.1, Math.min(5, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // Zoom towards mouse position
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scaleChange = newZoom / currentZoom;
                panX = mouseX - (mouseX - panX) * scaleChange;
                panY = mouseY - (mouseY - panY) * scaleChange;
                
                currentZoom = newZoom;
                updateTransform();
                updateZoomIndicator();
            }
            
            // Reset throttle after frame
            requestAnimationFrame(() => {
                isUpdating = false;
            });
        }

        function updateTransform() {
            requestAnimationFrame(() => {
                const transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
                surface.style.transform = transform;
            });
        }

        function updateZoomIndicator() {
            // Zoom indicator functionality removed for simplicity
        }

        // Auto-position camera for normal view
        function autoPositionCamera() {
            // Set to normal 100% zoom, centered
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            currentZoom = 1.0; // Always normal zoom
            panX = 0; // Always centered
            panY = 0; // Always centered
            
            // Apply transform
            updateTransform();
            
            console.log(`📐 Camera positioned: normal view (100% zoom)`);
        }

        function resetZoom() {
            // Always reset to normal view
            autoPositionCamera();
        }

        function zoomIn() {
            // Zoom functionality disabled - always keep normal view
            autoPositionCamera();
        }

        function zoomOut() {
            // Zoom functionality disabled - always keep normal view
            autoPositionCamera();
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                processImageFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                processImageFile(file);
            }
        }

        async function processImageFile(file) {
            // Find the upload container - could be original uploadZone or modified structure
            let uploadContainer = document.getElementById('uploadZone');
            let isFirstUpload = true;
            
            // If uploadZone doesn't exist, look for the upload box container
            if (!uploadContainer) {
                uploadContainer = document.querySelector('.upload-box .element-content');
                isFirstUpload = false;
            }
            
            if (!uploadContainer) {
                console.error('Could not find upload container');
                return;
            }
            
            console.log('📤 Processing image file, first upload:', isFirstUpload);
            
            // Show loading state
            if (isFirstUpload) {
                uploadContainer.classList.add('loading');
            } else {
                // Add loading state to the upload box
                const uploadBox = uploadContainer.closest('.upload-box');
                if (uploadBox) uploadBox.classList.add('loading');
            }
            
            try {
                // Clear previous session state when loading new image
                sessionResults = [];
                totalKonceptRows = 3;
                customKonceptCount = 0;
                
                // If this was a shared session, create a new session for the new image
                if (isSharedSession) {
                    isSharedSession = false;
                    currentSessionId = generateSessionId();
                    window.history.pushState({}, '', `/session/${currentSessionId}`);
                    console.log('🔄 New session created for image change:', currentSessionId);
                }
                
                // Reset any ongoing operations
                // (Add any cleanup for running processes here if needed)
                console.log('🔄 Resetting session state for new image');
                
                // Clear existing results from the grid (but preserve structure)
                const rightSection = document.getElementById('rightSection');
                if (rightSection) {
                    // Only clear result elements, not the entire section
                    const resultElements = rightSection.querySelectorAll('.canvas-element:not(.upload-box)');
                    resultElements.forEach(element => element.remove());
                }
                
                // Clear caption container
                const captionContainer = document.querySelector('.caption-container');
                if (captionContainer) {
                    captionContainer.innerHTML = '';
                }
                
                // Remove share button since this is a new session
                const shareButton = document.getElementById('shareButton');
                if (shareButton) {
                    shareButton.remove();
                }
                
                // Store the base64 data for later use
                currentImageBase64 = await fileToBase64(file);
                
                // Start instant upload to server for better responsiveness
                console.log('⬆️ Starting instant image upload...');
                if (isFirstUpload) {
                    uploadContainer.classList.add('upload-loading');
                } else {
                    const uploadBox = uploadContainer.closest('.upload-box');
                    if (uploadBox) uploadBox.classList.add('upload-loading');
                }
                
                try {
                    // Removed pre-upload - not needed for current implementation
                    console.log('✅ Image processing ready');
                    
                    // Add success indicator
                    setTimeout(() => {
                        if (isFirstUpload) {
                            uploadContainer.classList.remove('upload-loading');
                            uploadContainer.classList.add('upload-success');
                        } else {
                            const uploadBox = uploadContainer.closest('.upload-box');
                            if (uploadBox) {
                                uploadBox.classList.remove('upload-loading');
                                uploadBox.classList.add('upload-success');
                            }
                        }
                    }, 500);
                    
                } catch (error) {
                    // Silently handle pre-upload failures - this is expected since the endpoint doesn't exist yet
                    // Remove loading state but continue - fallback to original behavior
                    if (isFirstUpload) {
                        uploadContainer.classList.remove('upload-loading');
                    } else {
                        const uploadBox = uploadContainer.closest('.upload-box');
                        if (uploadBox) uploadBox.classList.remove('upload-loading');
                    }
                }
                
                // Create image preview in upload box
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    
                    // Show image at natural size within fixed upload box
                    img.onload = () => {
                        // Style the image to fit within the fixed upload box
                        img.className = 'image-preview';
                        img.style.cursor = 'zoom-in';
                        
                        // Add click handler for image expansion
                        img.onclick = (e) => {
                            e.stopPropagation();
                            const promptId = storePrompt('Source image for AI transformation');
                            openImageModal(img.src, 'Original Upload', promptId);
                        };
                        
                        // Clear and rebuild upload container
                        uploadContainer.innerHTML = '';
                        
                        // Create image container
                        const imageContainer = document.createElement('div');
                        imageContainer.className = 'image-container';
                        imageContainer.appendChild(img);
                        
                        // Create start button outside of clickable area
                        const startButton = document.createElement('button');
                        startButton.className = 'start-button';
                        startButton.innerHTML = 'Generate';
                        startButton.onclick = (e) => {
                            e.stopPropagation();
                            const numImagesInput = document.getElementById('numImagesInput');
                            const numImages = Math.max(1, Math.min(parseInt(numImagesInput?.value) || 8, 48));
                            console.log('🎯 RE-KONTEXT button clicked, starting autoplay with', numImages, 'images...');
                            
                            // Add immediate loading feedback
                            startButton.classList.add('generating');
                            startButton.innerHTML = 'Generating...';
                            startButton.disabled = true;
                            
                            // Hide button after brief feedback
                            setTimeout(() => {
                                startButton.style.display = 'none';
                                autoplaySequence(numImages);
                            }, 300);
                        };
                        
                        // Ensure button is enabled and clickable
                        startButton.disabled = false;
                        startButton.style.pointerEvents = 'auto';
                        console.log('✅ RE-KONTEXT button created and ready to click');
                        
                        // Create change image button
                        const changeButton = document.createElement('button');
                        changeButton.className = 'change-button';
                        changeButton.innerHTML = '🔄 Change Image';
                        changeButton.onclick = (e) => {
                            e.stopPropagation();
                            fileInput.click();
                        };
                        
                        // Add elements to upload container
                        uploadContainer.appendChild(imageContainer);
                        uploadContainer.appendChild(startButton);
                        uploadContainer.appendChild(changeButton);
                        
                        // Remove loading state
                        if (isFirstUpload) {
                            uploadContainer.classList.remove('loading');
                        } else {
                            const uploadBox = uploadContainer.closest('.upload-box');
                            if (uploadBox) uploadBox.classList.remove('loading');
                        }
                        
                        // Add original image to seed history
                        if (isFirstUpload) {
                            clearSeedHistory(); // Clear any existing history for new uploads
                            addToSeedHistory(img.src, 'Original Upload', true);
                        }
                        
                        console.log(`📏 Upload image loaded: ${img.naturalWidth}x${img.naturalHeight}`);
                    };
                };
                reader.readAsDataURL(file);
                
            } catch (error) {
                console.error('Error processing image:', error);
                
                // Remove loading state on error
                if (isFirstUpload) {
                    uploadContainer.classList.remove('loading');
                } else {
                    const uploadBox = uploadContainer.closest('.upload-box');
                    if (uploadBox) uploadBox.classList.remove('loading');
                }
                
                alert('Error processing image. Please try again.');
            }
        }
        
        async function autoplaySequence(NUM_IMAGES = 8) {
            console.log('🎬 Starting autoplay sequence...');
            
            // Step 1: Create immediate skeleton loading tiles for better UX
            console.log('📏 Creating immediate skeleton tiles...');
            createImmediateSkeletonTiles(NUM_IMAGES);
            
            // Skip createBlankLayout - keep skeleton tiles until images start loading
            
            // Step 2: Start AI analysis
            console.log('🤖 Analyzing image with AI...');
            console.log('Current image base64 length:', currentImageBase64?.length || 'undefined');
            
            try {
                //const analysisResult = await analyzeImageWithMistral(currentImageBase64);
                //console.log('🎯 Analysis result:', analysisResult);
                
                // Step 3: Immediately show caption while generating images
                //fillCaptionBox(analysisResult.caption);
                
                // Step 4: Request prompts for all images at once
                console.log(`📝 Requesting ${NUM_IMAGES} prompts from backend...`);
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        count: NUM_IMAGES
                    })
                });
                let prompts = [];
                if (promptResponse.ok) {
                    const promptData = await promptResponse.json();
                    prompts = promptData.prompts || [];
                }
                if (prompts.length < NUM_IMAGES) {
                    // Fallback: fill with generic prompts if not enough
                    while (prompts.length < NUM_IMAGES) {
                        prompts.push(`Transform the image in a wild, creative way #${prompts.length + 1}.`);
                    }
                }
                console.log(`✅ Received ${prompts.length} prompts, starting image generation...`);
                
                // Step 5: Generate all images in parallel using the prompts
                const promises = [];
                let completedCount = 0;
                // Find the start button so we can show it again later
                const startButton = document.querySelector('.start-button');
                for (let i = 0; i < NUM_IMAGES; i++) {
                    updateCardLoading(i + 1, `Generating transformation...`);
                    const promise = generateSingleCardImageWithPrompt(i + 1, prompts[i])
                        .finally(() => {
                            completedCount++;
                            if (completedCount === NUM_IMAGES && startButton) {
                                startButton.style.display = '';
                            }
                        });
                    promises.push(promise);
                    await animatedDelay(25);
                }
                console.log('✨ All image generations started in parallel!');
                // Don't wait for all to complete - let them finish individually
            } catch (error) {
                console.error('❌ Error in autoplay sequence:', error);
                // Show error message
                const rightSection = document.querySelector('.right-section');
                if (rightSection) {
                    rightSection.innerHTML = `
                        <div class="error-card">
                            <h3>Analysis Failed</h3>
                            <p>Unable to analyze image. Please try again.</p>
                        </div>
                    `;
                }
                // Also show the start button again on error
                const startButton = document.querySelector('.start-button');
                if (startButton) startButton.style.display = '';
            }
        }
        
        async function animatedDelay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createImmediateSkeletonTiles(numImages) {
            console.log(`🏗️ Creating ${numImages} immediate skeleton tiles...`);
            
            const rightSection = document.querySelector('.right-section');
            if (!rightSection) return;
            
            // Clear existing content
            rightSection.innerHTML = '';
            
            // Create skeleton tiles immediately
            for (let i = 0; i < numImages; i++) {
                const skeletonTile = document.createElement('div');
                skeletonTile.className = 'skeleton-tile';
                skeletonTile.id = `skeleton-${i}`;
                rightSection.appendChild(skeletonTile);
            }
            
            console.log(`✅ Created ${numImages} skeleton loading tiles`);
        }

        function createBlankLayout() {
            console.log('🎨 Creating responsive image card layout...');
            
            const rightSection = document.querySelector('.right-section');
            if (!rightSection) return;
            
            // Clear skeleton tiles and prepare for actual image cards
            rightSection.innerHTML = '';
            
        }
        
        function createAddKonceptRow(rightSection) {
            // Calculate the next available row (each koncept now takes 2 rows: header + images)
            const nextRow = (totalKonceptRows * 2) + 1;
            
            console.log(`Creating add-koncept row at grid row ${nextRow} (totalKonceptRows: ${totalKonceptRows})`);
            
            // Create the add koncept label (clickable) - spans all columns like other koncept headers
            const addKonceptLabel = document.createElement('div');
            addKonceptLabel.className = 'add-koncept-label';
            addKonceptLabel.id = 'addKonceptLabel';
            addKonceptLabel.style.gridColumn = '1 / -1';
            addKonceptLabel.style.gridRow = nextRow.toString();
            addKonceptLabel.innerHTML = '+ Add Custom Koncept';
            addKonceptLabel.onclick = () => showCustomKonceptInput();
            rightSection.appendChild(addKonceptLabel);
            
            // Create 4 empty boxes for the row below the header
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.createElement('div');
                emptyBox.className = 'add-koncept-empty-box';
                emptyBox.id = `add-koncept-empty-${i}`;
                emptyBox.style.gridColumn = (i + 1).toString();
                emptyBox.style.gridRow = (nextRow + 1).toString();
                emptyBox.innerHTML = '...';
                rightSection.appendChild(emptyBox);
            }
            
            console.log(`✅ Add-koncept row created at rows ${nextRow} and ${nextRow + 1}`);
        }

        function fillCaptionBox(caption) {
            console.log('🔄 Filling caption box with:', caption.substring(0, 50) + '...');
            
            // Always create/recreate caption box to ensure it shows up immediately
            const captionContainer = document.querySelector('.caption-container');
            if (captionContainer) {
                // Clear any existing content first
                captionContainer.innerHTML = '';
                const captionElement = document.createElement('div');
                captionElement.className = 'canvas-element caption-box';
                captionElement.id = 'caption-box';
                captionElement.innerHTML = `
                    <div class="element-header">🔍 AI ANALYSIS</div>
                    <div class="element-content">
                        <div class="caption-text">${caption}</div>
                    </div>
                `;
                captionContainer.appendChild(captionElement);
                console.log('✅ Caption box created and filled immediately');
            } else {
                console.error('❌ Caption container not found');
            }
        }

        function fillKonceptLabels(koncepts) {
            console.log('🔄 Filling koncept labels with:', koncepts);
            for (let i = 0; i < 3; i++) {
                const konceptLabel = document.getElementById(`koncept-label-${i}`);
                
                if (konceptLabel) {
                    const konceptName = koncepts[i] || `creative-${i}`;
                    
                    // Create editable koncept label
                    konceptLabel.innerHTML = `
                        <span class="koncept-text" onclick="editKoncept(${i})">${konceptName.toUpperCase()}</span>
                    `;
                    
                    // Store the current koncept name
                    konceptLabel.dataset.koncept = konceptName;
                    
                    console.log(`✅ Updated koncept ${i}: ${konceptName}`);
                } else {
                    console.error(`❌ Koncept label ${i} not found`);
                }
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Compress if image is too large
                    const maxWidth = 2048;
                    const maxHeight = 2048;
                    const quality = 0.8;
                    
                    let { width, height } = img;
                    
                    // Calculate new dimensions if resizing needed
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width = Math.floor(width * ratio);
                        height = Math.floor(height * ratio);
                        console.log(`📏 Resizing image from ${img.width}x${img.height} to ${width}x${height}`);
                    }
                    
                    // Create canvas and compress
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw and compress
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    const base64 = compressedDataUrl.split(',')[1];
                    
                    console.log(`📦 Compressed image: ${base64.length} characters (${(base64.length/1024/1024*3/4).toFixed(1)}MB)`);
                    resolve(base64);
                };
                img.onerror = reject;
                
                // Load image for compression
                const reader = new FileReader();
                reader.onload = (e) => img.src = e.target.result;
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Hilarious random elements to combine with concepts
        const hilariousElements = [
            'but holding puppies',
            'while eating spaghetti',
            'but made of marshmallows',
            'riding a unicorn',
            'wearing a banana costume',
            'surrounded by rubber ducks',
            'but they\'re actually a cat',
            'made entirely of glitter',
            'but tiny and living in a teacup',
            'while juggling pineapples',
            'wearing rainbow socks',
            'but they\'re secretly a robot',
            'covered in post-it notes',
            'holding a very confused chicken',
            'made of jello',
            'wearing a crown of broccoli',
            'but they\'re floating',
            'surrounded by flying pizza slices',
            'wearing mismatched shoes',
            'but everything is backwards',
            'holding a magic spoon',
            'made of clouds',
            'wearing a cape of lettuce',
            'but they\'re upside down',
            'surrounded by dancing pickles',
            'wearing a hat made of cheese',
            'but they\'re transparent',
            'holding a tiny elephant',
            'made of bubble wrap',
            'wearing polka dot everything'
        ];

        function getRandomHilariousElement() {
            return hilariousElements[Math.floor(Math.random() * hilariousElements.length)];
        }

        async function analyzeImageWithMistral(base64Data) {
            try {
                const response = await fetch('/api/analyze-vibes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64Data })
                });

                if (!response.ok) throw new Error('Analysis failed');

                const data = await response.json();
                
                // Add hilarious elements to each vibe, but clean them first
                const enhancedVibes = (data.vibes || ['creative', 'unique', 'interesting']).map(vibe => {
                    // Clean the vibe by removing numbers, asterisks, and taking first few words
                    const cleanVibe = vibe
                        .replace(/^\d+\.\s*\**/g, '') // Remove "1. **" prefix
                        .replace(/\*\*/g, '') // Remove ** markdown
                        .replace(/[:]/g, '') // Remove colons
                        .split(/[,.\s]+/) // Split on punctuation and spaces
                        .filter(word => word.length > 2) // Keep meaningful words
                        .slice(0, 2) // Take first 2 words max
                        .join('-'); // Join with dashes
                    
                    return `${cleanVibe} ${getRandomHilariousElement()}`;
                });
                
                return {
                    caption: data.description || "Image analyzed successfully",
                    vibes: enhancedVibes
                };
            } catch (error) {
                console.error('Mistral analysis error:', error);
                return {
                    caption: "Could not analyze image with AI",
                    vibes: [
                        `mysterious ${getRandomHilariousElement()}`, 
                        `creative ${getRandomHilariousElement()}`, 
                        `unique ${getRandomHilariousElement()}`
                    ]
                };
            }
        }

        function createCaptionBox(caption, x, y) {
            const captionBox = createElement('caption', `
                <div class="element-header">
                    🤖 AI Analysis
                </div>
                <div class="element-content">
                    <div class="caption-text">${caption}</div>
                </div>
            `, x, y);

            // Add entrance animation
            captionBox.element.style.opacity = '0';
            captionBox.element.style.transform = 'translateX(-50px) scale(0.9)';
            
            // Animate in
            setTimeout(() => {
                captionBox.element.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                captionBox.element.style.opacity = '1';
                captionBox.element.style.transform = 'translateX(0) scale(1)';
            }, 100);

            // Grid layout handles positioning automatically
            
            return captionBox;
        }

        function createVibeNodes(vibes, startX, startY) {
            vibes.forEach((vibe, index) => {
                const x = startX;
                const y = startY + (index * 150);
                
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');

                // Grid layout handles positioning automatically

                // Add click handler for vibe generation
                vibeNode.element.addEventListener('click', () => generateVibeImages(vibe, vibeNode.id));
            });
        }
        
        async function createVibeNodesFan(vibes) {
            // const captionElement = elements.find(el => el.type === 'caption'); // Legacy - elements array no longer used
            const captionX = 500; // Default position
            const captionY = 200; // Default position
            
            const vibeNodes = [];
            const vibeSpacing = 180; // Vertical spacing between vibes  
            const vibeXOffset = 400; // Horizontal distance from caption
            
            for (let i = 0; i < vibes.length; i++) {
                const vibe = vibes[i];
                
                // Calculate clean vertical layout
                const x = captionX + vibeXOffset;
                const y = captionY + (i * vibeSpacing) - ((vibes.length - 1) * vibeSpacing / 2);
                
                // Create vibe node with animation delay
                const vibeNode = createElement('vibe', `
                    <div class="vibe-text">${vibe.toUpperCase()}</div>
                `, x, y, 'vibe-node');
                
                // Store vibe index for result layout
                vibeNode.vibeIndex = i;
                
                // Add entrance animation
                vibeNode.element.style.opacity = '0';
                vibeNode.element.style.transform = 'scale(0.5)';
                
                // Animate in with delay
                setTimeout(() => {
                    vibeNode.element.style.transition = 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    vibeNode.element.style.opacity = '1';
                    vibeNode.element.style.transform = 'scale(1)';
                }, i * 300);
                
                // Grid layout handles positioning automatically
                
                vibeNodes.push(vibeNode);
            }
            
            return vibeNodes;
        }

        function createElement(type, innerHTML, x, y, extraClass = '') {
            elementIdCounter++;
            const id = `element-${elementIdCounter}`;
            
            const element = document.createElement('div');
            element.id = id;
            element.className = `canvas-element ${type}-box ${extraClass}`;
            element.style.left = x + 'px';
            element.style.top = y + 'px';
            element.innerHTML = innerHTML;
            
            surface.appendChild(element);
            registerElement(id, type);
            
            return { id, element };
        }

        async function generateVibeImages(vibe, vibeNodeId) {
            const vibeElement = document.getElementById(vibeNodeId);
            vibeElement.classList.add('selected');
            
            try {
                // Check if we have the stored image data
                if (!currentImageBase64) {
                    throw new Error('No image available for transformation');
                }
                
                console.log(`Generating ${vibe} prompts...`);
                
                // Generate vibe-specific prompts using Mistral
                const promptResponse = await fetch('/api/generate-vibe-prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: currentImageBase64,
                        vibe: vibe 
                    })
                });
                
                if (!promptResponse.ok) {
                    throw new Error('Failed to generate vibe prompts');
                }
                
                const promptData = await promptResponse.json();
                const prompts = promptData.prompts || [];
                
                console.log(`Generated ${prompts.length} prompts for ${vibe}:`, prompts);
                
                // Create result boxes and generate images
                const baseX = parseInt(vibeElement.style.left) + 300;
                const baseY = parseInt(vibeElement.style.top);
                
                for (let i = 0; i < Math.min(4, prompts.length); i++) {
                    const prompt = prompts[i];
                    
                    const resultBox = createElement('result', `
                        <div class="element-header">
                            🎨 ${vibe.toUpperCase()} #${i + 1}
                        </div>
                        <div class="element-content">
                            <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                                Generating...
                            </div>
                            <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                        </div>
                    `, baseX + (i * 280), baseY + (i * 100));

                    // Grid layout handles positioning automatically
                    
                    // Generate image for this prompt
                    generateSingleVibeImage(prompt, resultBox.id, vibe, i + 1);
                }
                
            } catch (error) {
                console.error('Error generating vibe images:', error);
                alert(`Error generating ${vibe} images: ${error.message}`);
            } finally {
                vibeElement.classList.remove('selected');
            }
        }
        
        // New function to generate a single image for the card layout
        async function generateSingleCardImageWithPrompt(iteration, prompt) {
            try {
                console.log(`🎨 Generating card image ${iteration} with prompt: ${prompt.substring(0, 100)}...`);
                // Start generation and get request ID
                const startResponse = await fetch('/api/start-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        input_image: currentImageBase64,
                        steps: 50,
                        guidance: 3.0
                    })
                });
                if (!startResponse.ok) {
                    throw new Error(`Failed to start generation: ${startResponse.status}`);
                }
                const startResult = await startResponse.json();
                if (!startResult.success || !startResult.requestId) {
                    throw new Error('Failed to get request ID');
                }
                console.log(`⏳ Generation started for card ${iteration}, polling for completion...`);
                // Poll for completion
                const result = await pollForCompletion(startResult.requestId, iteration);
                if (result.success && result.imageUrl) {
                    // Update the card with the completed image
                    updateCardComplete(iteration, result.imageUrl, prompt);
                    console.log(`✅ Card ${iteration} completed successfully`);
                    // Save result to session
                    saveResultToSession(0, iteration - 1, {
                        prompt: prompt,
                        imageUrl: result.imageUrl,
                        status: 'completed'
                    });
                } else if (result.moderated) {
                    updateCardError(iteration, 'Content moderated');
                } else {
                    throw new Error('Generation failed');
                }
            } catch (error) {
                console.error(`❌ Error generating card ${iteration}:`, error);
                updateCardError(iteration, error.message.includes('timeout') ? 'Generation timeout' : 'Generation failed');
            }
        }
        
        // Update card with loading state
        function updateCardLoading(iteration, status) {
            const cardId = `image-card-${iteration}`;
            let card = document.getElementById(cardId);
            
            const rightSection = document.querySelector('.right-section');
            if (!rightSection) return;
            
            // Check if we can convert a skeleton tile instead
            const skeletonId = `skeleton-${iteration - 1}`; // iteration is 1-based, skeleton is 0-based
            const skeletonTile = document.getElementById(skeletonId);
            
            if (skeletonTile) {
                // Convert skeleton tile to actual image card
                skeletonTile.id = cardId;
                skeletonTile.className = 'image-card';
                skeletonTile.innerHTML = `
                    <div class="image-card-content">
                        <div class="loading-spinner"></div>
                        <p class="status-text">${status}</p>
                    </div>
                `;
                card = skeletonTile;
            } else if (!card) {
                // Fallback: create new card if skeleton doesn't exist
                const cardHTML = `
                    <div class="image-card" id="${cardId}">
                        <div class="image-card-content">
                            <div class="loading-spinner"></div>
                            <p class="status-text">${status}</p>
                        </div>
                    </div>
                `;
                rightSection.insertAdjacentHTML('beforeend', cardHTML);
                card = document.getElementById(cardId);
            } else {
                // Update existing card
                const content = card.querySelector('.image-card-content');
                if (content) {
                    content.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p class="status-text">${status}</p>
                    `;
                }
            }
        }
        
        // Update card with completed image
        function updateCardComplete(iteration, imageUrl, prompt) {
            const cardId = `image-card-${iteration}`;
            const card = document.getElementById(cardId);
            
            if (!card) return;
            
            const promptId = storePrompt(prompt);
            const content = card.querySelector('.image-card-content');
            
            if (content) {
                content.innerHTML = `
                    <div class="result-image-container" style="width: 100%; display: flex; align-items: center; justify-content: center; height: 100%; position: relative;">
                        <img src="${imageUrl}" class="result-image" 
                             data-prompt-id="${promptId}" 
                             onclick="openImageModal('${imageUrl}', 'Transformation ${iteration}', '${promptId}')"
                             style="cursor: zoom-in; max-width: 100%; max-height: 100%; object-fit: contain;"
                             title="Click to view full size">
                        <div class="use-as-input-icon" 
                             onclick="event.stopPropagation(); useAsInput('${imageUrl}', 'Transformation ${iteration}', '${promptId}')"
                             title="Use this image to start a new generation">
                            ↻
                        </div>
                    </div>
                `;
                // Dynamically set aspect ratio after image loads
                const img = content.querySelector('.result-image');
                const container = content.querySelector('.result-image-container');
                img.onload = function() {
                    const aspect = img.naturalWidth / img.naturalHeight;
                    // Use CSS aspect-ratio if supported
                    container.style.aspectRatio = aspect;
                    // Set aspect-ratio on the outer card as well for grid alignment
                    card.style.aspectRatio = aspect;
                    card.style.height = '';
                    card.style.minHeight = '';
                    // Force reflow to ensure browser applies new aspect
                    card.offsetHeight;
                    // Fallback for browsers without aspect-ratio support
                    if (!('aspectRatio' in document.body.style)) {
                        container.style.height = `${container.offsetWidth / aspect}px`;
                        card.style.height = `${card.offsetWidth / aspect}px`;
                    }
                };
            }
            
            // Add to modal images array
            modalImages.push({
                url: imageUrl,
                title: `Transformation ${iteration}`,
                promptId: promptId
            });
        }
        
        // Update card with error state
        function updateCardError(iteration, errorMessage) {
            const cardId = `image-card-${iteration}`;
            const card = document.getElementById(cardId);
            
            if (!card) return;
            
            const content = card.querySelector('.image-card-content');
            if (content) {
                content.innerHTML = `
                    <div class="error-state">
                        <p>❌ ${errorMessage}</p>
                    </div>
                `;
            }
        }

        function updateResultProgress(resultBoxId, text) {
            const resultBox = document.getElementById(resultBoxId);
            if (resultBox) {
                const content = resultBox.querySelector('.element-content');
                content.innerHTML = `
                    <div class="blank-result">
                        <div class="blank-image"></div>
                        <div class="progress-text">${text}</div>
                    </div>
                `;
            }
        }
        
        async function createResultBoxesFan(vibe, vibeNodeId, prompts, vibeIndex) {
            const vibeElement = document.getElementById(vibeNodeId);
            const vibeX = parseInt(vibeElement.style.left);
            const vibeY = parseInt(vibeElement.style.top);
            
            const resultBoxes = [];
            const resultSpacing = 300; // Horizontal spacing between results
            const resultXOffset = 280; // Distance from vibe node
            const resultStartX = vibeX + resultXOffset;
            
            // Calculate base Y position for this vibe's row - create elegant staggered layout
            const rowBaseY = vibeY - 30; // Slightly above vibe center for better flow
            
            for (let i = 0; i < Math.min(4, prompts.length); i++) {
                const prompt = prompts[i];
                
                // Create elegant branching layout with slight vertical offsets
                const x = resultStartX + (i * resultSpacing);
                const y = rowBaseY + (i * 15); // Subtle stagger for organic flow
                
                const resultBox = createElement('result', `
                    <div class="element-header">
                        🎨 ${vibe.toUpperCase()} #${i + 1}
                    </div>
                    <div class="element-content">
                        <div class="result-image loading" style="display: flex; align-items: center; justify-content: center; color: #666; font-weight: bold;">
                            Generating...
                        </div>
                        <div class="result-prompt">${prompt.substring(0, 100)}...</div>
                    </div>
                `, x, y);
                
                // Add entrance animation
                resultBox.element.style.opacity = '0';
                resultBox.element.style.transform = 'scale(0.8) translateY(20px)';
                
                // Animate in with delay
                setTimeout(() => {
                    resultBox.element.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    resultBox.element.style.opacity = '1';
                    resultBox.element.style.transform = 'scale(1) translateY(0)';
                }, i * 200);
                
                // Add connection with delay
                setTimeout(() => {
                    // Grid layout handles positioning automatically
                }, i * 200 + 100);
                
                resultBoxes.push(resultBox);
            }
            
            return resultBoxes;
        }
        
        async function generateSingleKonceptImage(prompt, resultBoxId, koncept, index, konceptIndex) {
            const resultBox = document.getElementById(resultBoxId);
            
            try {
                console.log(`🎨 Generating image ${index} for ${koncept}:`, prompt);
                
                // Add generating animation
                if (resultBox) {
                    resultBox.classList.add('generating');
                }
                
                // Start generation and get request ID
                const startResponse = await fetch('/api/start-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        input_image: currentImageBase64,
                        steps: 50,
                        guidance: 3.0
                    })
                });
                
                if (!startResponse.ok) {
                    throw new Error(`Failed to start generation: ${startResponse.status}`);
                }
                
                const startResult = await startResponse.json();
                if (!startResult.success || !startResult.requestId) {
                    throw new Error('Failed to get request ID');
                }
                
                console.log(`⏳ Generation started for image ${index}, polling for completion...`);
                
                // Poll for completion
                const result = await pollForCompletion(startResult.requestId, index);
                
                if (result.success && result.imageUrl) {
                    // Update the result box with the generated image
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        const promptId = storePrompt(prompt);
                        content.innerHTML = `
                            <div class="result-image-container">
                                <img src="${result.imageUrl}" class="result-image" data-prompt-id="${promptId}" style="
                                    cursor: zoom-in;
                                    width: 100%;
                                    height: auto;
                                    min-height: 400px;
                                    object-fit: contain;
                                " onclick="openImageModal('${result.imageUrl}', '${koncept.toUpperCase()} #${index}', '${promptId}')">
                            </div>
                        `;
                        
                        // Image is now immediately visible
                        
                        // Success visual feedback
                        resultBox.style.background = '#fff';
                        resultBox.style.color = '#000';
                        
                        console.log(`✅ Image ${index} completed for ${koncept}`);
                        
                        // Save result to session
                        saveResultToSession(konceptIndex, index - 1, {
                            prompt: prompt,
                            imageUrl: result.imageUrl,
                            status: 'completed'
                        });
                    }
                } else if (result.moderated) {
                    // Handle moderated content
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="moderated-result">
                                <div class="progress-text">⚠️ MODERATED</div>
                            </div>
                        `;
                        resultBox.style.background = '#ff6600';
                        resultBox.style.color = '#000';
                    }
                } else {
                    throw new Error('Generation failed');
                }
                
            } catch (error) {
                console.error(`❌ Error generating image ${index} for ${koncept}:`, error);
                
                // Update result box to show error
                if (resultBox) {
                    const content = resultBox.querySelector('.element-content');
                    const errorMessage = error.message.includes('timeout') 
                        ? '❌ TIMEOUT' 
                        : '❌ FAILED';
                    content.innerHTML = `
                        <div class="error-result">
                            <div class="progress-text">${errorMessage}</div>
                        </div>
                    `;
                    resultBox.style.background = '#ff6600';
                    resultBox.style.color = '#000';
                }
            } finally {
                // Remove generating animation
                if (resultBox) {
                    resultBox.classList.remove('generating');
                }
            }
        }

        // Connection functions removed - using CSS Grid layout instead

        // Touch event handlers with inertia support
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseDown({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY, 
                    target: e.target 
                });
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseMove({ 
                    clientX: touch.clientX, 
                    clientY: touch.clientY 
                });
            }
        }

        function handleTouchEnd(e) {
            // Touch end should trigger inertia like mouse up
            handleMouseUp(e);
        }

        // Image Modal Functions
        function openImageModal(imageSrc, title, promptId) {
            console.log('🖼️ Opening image modal:', title);
            console.log('🖼️ Image source:', imageSrc);
            console.log('🖼️ Prompt ID:', promptId);
            
            // Get actual prompt text from stored prompts
            const promptText = modalPrompts[promptId] || 'AI generated transformation';
            console.log('🖼️ Prompt text:', promptText);
            
            // Collect all available images for navigation
            collectModalImages();
            console.log('🖼️ Collected modal images:', modalImages.length);
            
            // Find the current image index
            currentModalIndex = modalImages.findIndex(img => img.src === imageSrc);
            if (currentModalIndex === -1) {
                // If not found, add current image and set as current
                modalImages.push({ src: imageSrc, title, prompt: promptText });
                currentModalIndex = modalImages.length - 1;
                console.log('🖼️ Added new image to modal collection');
            }
            console.log('🖼️ Current modal index:', currentModalIndex);
            
            showModalImage(currentModalIndex);
            
            const modal = document.getElementById('imageModal');
            console.log('🖼️ Modal element:', modal);
            if (modal) {
                modal.style.display = 'flex';
                console.log('🖼️ Modal display set to flex');
                
                // Trigger animation after display
                setTimeout(() => {
                    modal.classList.add('show');
                    console.log('🖼️ Modal show class added');
                }, 10);
                
                // Prevent body scrolling
                document.body.style.overflow = 'hidden';
                
                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeImageModal();
                    }
                });
                
                // Add event listeners
                document.addEventListener('keydown', handleModalKeydown);
                document.addEventListener('touchstart', handleModalTouchStart);
                document.addEventListener('touchmove', handleModalTouchMove);
                document.addEventListener('touchend', handleModalTouchEnd);
            } else {
                console.error('🖼️ Modal element not found!');
                return;
            }
        }
        
        function collectModalImages() {
            modalImages = [];
            
            // Add upload image if it exists
            const uploadImage = document.querySelector('.image-preview');
            if (uploadImage && uploadImage.src) {
                modalImages.push({
                    src: uploadImage.src,
                    title: 'Original Upload',
                    prompt: 'Source image for AI transformation'
                });
            }
            
            // Add all generated images
            const resultImages = document.querySelectorAll('.result-image');
            resultImages.forEach((img, index) => {
                if (img.src && img.src !== '') {
                    // Extract vibe info from result box
                    const resultBox = img.closest('.result-box');
                    const header = resultBox ? resultBox.querySelector('.element-header') : null;
                    const title = header ? header.textContent.trim() : `Generated Image ${index + 1}`;
                    
                    // Extract prompt from data attribute
                    let promptText = 'AI generated transformation';
                    const promptId = img.getAttribute('data-prompt-id');
                    if (promptId && modalPrompts[promptId]) {
                        promptText = modalPrompts[promptId];
                    }
                    
                    modalImages.push({
                        src: img.src,
                        title: title,
                        prompt: promptText
                    });
                }
            });
        }
        
        function showModalImage(index) {
            console.log('🖼️ showModalImage called with index:', index, 'of', modalImages.length);
            if (index < 0 || index >= modalImages.length) {
                console.error('🖼️ Invalid modal index:', index);
                return;
            }
            
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalPrompt = document.getElementById('modalPrompt');
            const modalCounter = document.getElementById('modalCounter');
            const modalPrev = document.getElementById('modalPrev');
            const modalNext = document.getElementById('modalNext');
            
            console.log('🖼️ Modal elements found:', {
                image: !!modalImage,
                title: !!modalTitle,
                prompt: !!modalPrompt,
                counter: !!modalCounter
            });
            
            const image = modalImages[index];
            console.log('🖼️ Setting modal image:', image);
            
            if (modalImage) modalImage.src = image.src;
            if (modalTitle) modalTitle.textContent = image.title;
            
            // Show full prompt or fallback message
            const promptText = image.prompt && image.prompt !== 'undefined' && image.prompt.trim() 
                ? image.prompt 
                : 'AI generated transformation';
            
            console.log('📝 Full image object:', image);
            console.log('📝 Prompt text to display:', promptText);
            
            if (modalPrompt) {
                modalPrompt.textContent = promptText;
                console.log('📝 Modal prompt element updated');
            } else {
                console.error('📝 Modal prompt element not found!');
            }
            modalCounter.textContent = `${index + 1} / ${modalImages.length}`;
            
            // Update navigation buttons
            modalPrev.classList.toggle('disabled', index === 0);
            modalNext.classList.toggle('disabled', index === modalImages.length - 1);
            
            currentModalIndex = index;
        }
        
        function navigateModal(direction) {
            const newIndex = currentModalIndex + direction;
            if (newIndex >= 0 && newIndex < modalImages.length) {
                showModalImage(newIndex);
            }
        }
        
        function closeImageModal() {
            console.log('🔒 Closing image modal');
            const modal = document.getElementById('imageModal');
            
            modal.classList.remove('show');
            
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
            
            // Remove event listeners
            document.removeEventListener('keydown', handleModalKeydown);
            document.removeEventListener('touchstart', handleModalTouchStart);
            document.removeEventListener('touchmove', handleModalTouchMove);
            document.removeEventListener('touchend', handleModalTouchEnd);
        }
        
        function handleModalKeydown(e) {
            if (e.key === 'Escape') {
                closeImageModal();
            } else if (e.key === 'ArrowLeft') {
                navigateModal(-1);
            } else if (e.key === 'ArrowRight') {
                navigateModal(1);
            }
        }
        
        // Touch handling for mobile swipe navigation
        let modalTouchStartX = 0;
        let modalTouchStartY = 0;
        
        function handleModalTouchStart(e) {
            if (e.touches.length === 1) {
                modalTouchStartX = e.touches[0].clientX;
                modalTouchStartY = e.touches[0].clientY;
            }
        }
        
        function handleModalTouchMove(e) {
            // Prevent default to avoid scrolling while swiping
            if (e.touches.length === 1) {
                e.preventDefault();
            }
        }
        
        function handleModalTouchEnd(e) {
            if (e.changedTouches.length === 1) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const deltaX = touchEndX - modalTouchStartX;
                const deltaY = touchEndY - modalTouchStartY;
                
                // Check if horizontal swipe is more significant than vertical
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        // Swipe right - go to previous image
                        navigateModal(-1);
                    } else {
                        // Swipe left - go to next image
                        navigateModal(1);
                    }
                }
            }
        }

        // Custom Koncept Functions
        function showAddKonceptButton() {
            const addKonceptContainer = document.getElementById('addKonceptContainer');
            addKonceptContainer.style.display = 'block';
            console.log('🎨 Add Koncept button now visible');
        }
        
        function showCustomKonceptInput() {
            const input = prompt('Enter your custom koncept (e.g., cyberpunk-medieval, neon-zen):');
            
            if (input && input.trim().length >= 3) {
                const customKoncept = input.trim();
                console.log(`🎭 Generating custom koncept: ${customKoncept}`);
                
                generateCustomKonceptDirect(customKoncept);
            } else if (input !== null) {
                alert('Please enter a koncept with at least 3 characters');
            }
        }
        
        async function generateCustomKonceptDirect(customKoncept) {
            try {
                // Increment custom koncept count and total rows
                customKonceptCount++;
                const konceptIndex = totalKonceptRows;
                totalKonceptRows++;
                
                // Replace the empty state row with the new koncept
                replaceAddKonceptRowWithResults(konceptIndex, customKoncept);
                
                // Generate images for the custom koncept
                await autoGenerateKonceptImages(customKoncept, `custom-koncept-${customKonceptCount}`, konceptIndex);
                
                // Add a new empty state row below
                const rightSection = document.getElementById('rightSection');
                createAddKonceptRow(rightSection);
                
                console.log(`✅ Custom koncept "${customKoncept}" generation complete!`);
                
            } catch (error) {
                console.error('❌ Error generating custom koncept:', error);
                alert(`Error generating "${customKoncept}" koncept. Please try again.`);
            }
        }
        
        function replaceAddKonceptRowWithResults(konceptIndex, konceptName) {
            const rightSection = document.getElementById('rightSection');
            
            // Remove the current add koncept row
            const addKonceptLabel = document.getElementById('addKonceptLabel');
            if (addKonceptLabel) addKonceptLabel.remove();
            
            for (let i = 0; i < 4; i++) {
                const emptyBox = document.getElementById(`add-koncept-empty-${i}`);
                if (emptyBox) emptyBox.remove();
            }
            
            // Calculate the row numbers (header and images)
            const headerRow = (konceptIndex * 2) + 1;
            const imagesRow = headerRow + 1;
            
            // Add koncept label header (spans all columns)
            const konceptLabel = document.createElement('div');
            konceptLabel.className = 'koncept-label';
            konceptLabel.id = `koncept-label-${konceptIndex}`;
            konceptLabel.style.gridColumn = '1 / -1';
            konceptLabel.style.gridRow = headerRow;
            konceptLabel.innerHTML = `
                <span class="koncept-text" onclick="editKoncept(${konceptIndex})">${konceptName.toUpperCase()}</span>
            `;
            konceptLabel.dataset.koncept = konceptName;
            rightSection.appendChild(konceptLabel);
            
            // Add 4 result boxes in the row below the header
            for (let resultIndex = 0; resultIndex < 4; resultIndex++) {
                const resultElement = document.createElement('div');
                resultElement.className = 'canvas-element result-box';
                resultElement.id = `result-${konceptIndex}-${resultIndex}`;
                resultElement.style.gridColumn = resultIndex + 1;
                resultElement.style.gridRow = imagesRow;
                resultElement.innerHTML = `
                    <div class="element-header">🎨 RESULT ${resultIndex + 1}</div>
                    <div class="element-content">
                        <div class="blank-result">
                            <div class="blank-image"></div>
                            <div class="progress-text">WAITING...</div>
                        </div>
                    </div>
                `;
                rightSection.appendChild(resultElement);
            }
            
            console.log(`✅ Replaced empty state with koncept row for: ${konceptName} (header: row ${headerRow}, images: row ${imagesRow})`);
        }

        // Session management functions
        function saveResultToSession(konceptIndex, resultIndex, result) {
            if (isSharedSession) return; // Don't save results for shared sessions
            
            // Initialize session results structure if needed
            while (sessionResults.length <= konceptIndex) {
                sessionResults.push([]);
            }
            while (sessionResults[konceptIndex].length <= resultIndex) {
                sessionResults[konceptIndex].push(null);
            }
            
            sessionResults[konceptIndex][resultIndex] = result;
            console.log(`💾 Saved result to session: koncept ${konceptIndex}, result ${resultIndex}`);
            
            // Auto-save session periodically
            debounceSessionSave();
        }
        
        let sessionSaveTimeout;
        function debounceSessionSave() {
            clearTimeout(sessionSaveTimeout);
            sessionSaveTimeout = setTimeout(saveCurrentSession, 2000); // Save after 2 seconds of inactivity
        }
        
        async function saveCurrentSession() {
            if (isSharedSession || !currentImageBase64 || sessionResults.length === 0) return;
            
            try {
                console.log('💾 Saving current session...');
                
                // Flatten session results for API
                const flatResults = [];
                sessionResults.forEach((konceptResults, konceptIndex) => {
                    konceptResults.forEach((result, resultIndex) => {
                        if (result) {
                            flatResults.push(result);
                        }
                    });
                });
                
                if (flatResults.length === 0) return;
                
                // Get current caption from caption box
                let currentCaption = null;
                const captionBox = document.getElementById('caption-box');
                if (captionBox) {
                    const captionText = captionBox.querySelector('.caption-text');
                    if (captionText) {
                        currentCaption = captionText.textContent || captionText.innerText;
                    }
                }
                
                // Get current koncept names
                const konceptNames = [];
                for (let i = 0; i < totalKonceptRows; i++) {
                    const konceptLabel = document.getElementById(`koncept-label-${i}`);
                    if (konceptLabel && konceptLabel.dataset.koncept) {
                        konceptNames.push(konceptLabel.dataset.koncept);
                    }
                }
                
                const response = await fetch('/api/save-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        originalImage: currentImageBase64,
                        results: flatResults,
                        sessionId: currentSessionId,
                        caption: currentCaption,
                        konceptNames: konceptNames
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('✅ Session saved:', data.sessionId);
                    
                    // URL is already updated at session creation, no need to update again
                    
                    // Show share button once session is saved
                    showShareButton(data.shareUrl);
                } else {
                    console.error('❌ Failed to save session');
                }
                
            } catch (error) {
                console.error('❌ Error saving session:', error);
            }
        }
        
        function showShareButton(shareUrl) {
            // Check if share button already exists
            if (document.getElementById('shareButton')) return;
            
            // Try multiple possible containers for the share button
            const controlsContainer = document.querySelector('.canvas-controls') || 
                                    document.querySelector('.upload-container') ||
                                    document.querySelector('body');
            
            if (!controlsContainer) {
                console.log('No suitable container found for share button');
                return;
            }
            
            const shareButton = document.createElement('button');
            shareButton.id = 'shareButton';
            shareButton.className = 'control-btn';
            shareButton.innerHTML = 'SHARE';
            shareButton.onclick = () => shareSession(shareUrl);
            
            controlsContainer.appendChild(shareButton);
        }
        
        function shareSession(shareUrl) {
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show temporary success message
                const shareButton = document.getElementById('shareButton');
                const originalText = shareButton.innerHTML;
                shareButton.innerHTML = '✅ Copied!';
                shareButton.style.background = '#00ff00';
                shareButton.style.color = '#000';
                
                setTimeout(() => {
                    shareButton.innerHTML = originalText;
                    shareButton.style.background = '';
                    shareButton.style.color = '';
                }, 2000);
            }).catch(() => {
                // Fallback: show URL in prompt
                prompt('Share this URL:', shareUrl);
            });
        }
        
        // Koncept editing and regeneration functions
        function editKoncept(konceptIndex) {
            if (isSharedSession) return; // Don't allow editing in shared sessions
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const currentKoncept = konceptLabel.dataset.koncept || '';
            const konceptText = konceptLabel.querySelector('.koncept-text');
            
            // Create input field
            const input = document.createElement('input');
            input.className = 'koncept-input';
            input.value = currentKoncept;
            input.placeholder = 'Enter koncept...';
            
            // Replace text with input
            konceptText.style.display = 'none';
            konceptLabel.classList.add('editing');
            konceptLabel.insertBefore(input, konceptText);
            
            // Focus and select text
            input.focus();
            input.select();
            
            // Handle save on Enter or blur
            const saveKoncept = () => {
                const newKoncept = input.value.trim();
                if (newKoncept && newKoncept !== currentKoncept) {
                    // Update the koncept
                    konceptLabel.dataset.koncept = newKoncept;
                    konceptText.textContent = newKoncept.toUpperCase();
                    
                    console.log(`🔄 Koncept ${konceptIndex} updated to: ${newKoncept}`);
                    
                    // Auto-regenerate the row with new koncept
                    regenerateKonceptRow(konceptIndex);
                } else {
                    // Revert if no change or empty
                    konceptText.textContent = currentKoncept.toUpperCase();
                }
                
                // Cleanup
                input.remove();
                konceptText.style.display = '';
                konceptLabel.classList.remove('editing');
            };
            
            // Save on Enter
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKoncept();
                }
            });
            
            // Save on blur (click outside)
            input.addEventListener('blur', saveKoncept);
        }
        
        async function regenerateKonceptRow(konceptIndex) {
            if (isSharedSession) return; // Don't allow regeneration in shared sessions
            if (!currentImageBase64) {
                alert('Please upload an image first');
                return;
            }
            
            const konceptLabel = document.getElementById(`koncept-label-${konceptIndex}`);
            if (!konceptLabel) return;
            
            const koncept = konceptLabel.dataset.koncept || `koncept-${konceptIndex}`;
            
            console.log(`🔄 Regenerating row ${konceptIndex} with koncept: ${koncept}`);
            
            // Clear existing results in this row
            for (let i = 0; i < 4; i++) {
                const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                if (resultBox) {
                    updateResultProgress(`result-${konceptIndex}-${i}`, 'REGENERATING...');
                }
            }
            
            // Visual feedback - dim the label
            konceptLabel.style.opacity = '0.7';
            
            try {
                // Generate new images for this koncept
                await autoGenerateKonceptImages(koncept, `koncept-${konceptIndex}`, konceptIndex);
                
                console.log(`✅ Row ${konceptIndex} regenerated successfully`);
                
            } catch (error) {
                console.error(`❌ Error regenerating row ${konceptIndex}:`, error);
                alert(`Failed to regenerate ${koncept} row. Please try again.`);
                
                // Show error state
                for (let i = 0; i < 4; i++) {
                    const resultBox = document.getElementById(`result-${konceptIndex}-${i}`);
                    if (resultBox) {
                        const content = resultBox.querySelector('.element-content');
                        content.innerHTML = `
                            <div class="error-result">
                                <div class="progress-text">❌ REGENERATION FAILED</div>
                            </div>
                        `;
                    }
                }
            } finally {
                // Remove animation
                konceptLabel.style.animation = '';
            }
        }
        
        // Start new session function
        function resetApp() {
            // Confirm if user wants to start fresh
            const confirmNew = confirm('Reset the app? This will clear everything and start fresh.');
            
            if (confirmNew) {
                // Generate new session ID
                currentSessionId = generateSessionId();
                
                // Update URL immediately
                window.history.pushState({}, '', `/session/${currentSessionId}`);
                
                // Reset session state
                sessionResults = [];
                isSharedSession = false;
                currentImageBase64 = null;
                clearSeedHistory();
                
                // Clear the interface
                clearWorkspace();
                
                // Reset zoom and position
                autoPositionCamera();
                
                // Remove share button if it exists
                const shareButton = document.getElementById('shareButton');
                if (shareButton) {
                    shareButton.remove();
                }
                
                console.log('🆕 New session started:', currentSessionId);
            }
        }
        
        // Clear the workspace for new session
        function clearWorkspace() {
            // Clear right section
            const rightSection = document.getElementById('rightSection');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Clear caption container
            const captionContainer = document.querySelector('.caption-container');
            if (captionContainer) {
                captionContainer.innerHTML = '';
            }
            
            // Reset upload zone
            const uploadZone = document.getElementById('uploadZone');
            if (uploadZone) {
                uploadZone.style.pointerEvents = '';
                uploadZone.style.opacity = '';
                uploadZone.innerHTML = `
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8e8e93" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="margin-bottom: 16px;">
                        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path>
                        <circle cx="12" cy="13" r="3"></circle>
                    </svg>
                    <div style="font-size: 18px; font-weight: 600; color: #8e8e93; margin-bottom: 6px;">Upload Image</div>
                    <div style="font-size: 14px; color: #666; line-height: 1.4;">Drop or click to start generating</div>
                `;
            }
            
            // Reset counters
            customKonceptCount = 0;
            totalKonceptRows = 3;
            
            console.log('🧹 Workspace cleared');
        }
        
        // Spawn 18 variations from clicked image for maximum exploration
        async function spawnVariationsFromImage(imageUrl, title, promptId) {
            console.log('🚀 Spawning variations from clicked image:', title);
            
            // Clear current grid
            const rightSection = document.querySelector('.right-section');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Generate analysis vibes for variation prompts
            const variationVibes = [
                'dramatic', 'ethereal', 'vibrant', 'moody', 'cinematic', 'surreal',
                'minimalist', 'bold', 'dreamy', 'intense', 'elegant', 'gritty',
                'futuristic', 'vintage', 'abstract', 'realistic', 'artistic', 'experimental'
            ];
            
            // Generate 18 variations instantly
            const promises = [];
            for (let i = 1; i <= 18; i++) {
                const vibe = variationVibes[(i - 1) % variationVibes.length];
                
                // Create loading card immediately
                updateCardLoading(i, `Spawning ${vibe} variation...`);
                
                // Start generation with variation prompt
                const variationPrompt = `Transform this image with a ${vibe} aesthetic, maintaining the core subject but exploring new ${vibe} interpretations`;
                const promise = generateImageFromSource(imageUrl, variationPrompt, i);
                promises.push(promise);
                
                // Ultra-fast flow
                await animatedDelay(10);
            }
            
            console.log('✨ All 18 variations spawning in parallel!');
        }
        
        // Generate image from source image (for variations)
        async function generateImageFromSource(sourceImageUrl, prompt, iteration) {
            try {
                // Convert source image to base64 for img2img
                const response = await fetch(sourceImageUrl);
                const blob = await response.blob();
                const base64 = await blobToBase64(blob);
                
                // Generate with img2img
                const result = await generateImageFromPrompt(prompt, base64);
                
                if (result?.imageUrl) {
                    updateCardComplete(iteration, result.imageUrl, prompt);
                } else {
                    updateCardError(iteration, 'Generation failed');
                }
                
            } catch (error) {
                console.error(`❌ Error generating variation ${iteration}:`, error);
                updateCardError(iteration, 'Failed to generate');
            }
        }
        
        
        // Spawn 18 text-only variations (no img2img, avoids CORS)
        async function spawnTextOnlyVariations() {
            console.log('🚀 Spawning 18 text-only variations...');
            
            // Clear current grid
            const rightSection = document.querySelector('.right-section');
            if (rightSection) {
                rightSection.innerHTML = '';
            }
            
            // Get current analysis for variation prompts
            const analysisResult = window.currentAnalysis;
            if (!analysisResult?.vibes) {
                console.log('❌ No analysis available for variations');
                return;
            }
            
            // Enhanced variation styles for maximum diversity
            const variationStyles = [
                'photorealistic portrait', 'digital art', 'oil painting', 'watercolor', 
                'pencil sketch', 'cyberpunk style', 'steampunk aesthetic', 'vintage photo',
                'neon noir', 'minimalist design', 'abstract art', 'pop art style',
                'renaissance painting', 'anime style', 'comic book art', 'surreal art',
                'black and white photography', 'fantasy illustration'
            ];
            
            // Generate 18 variations instantly
            const promises = [];
            for (let i = 1; i <= 18; i++) {
                const baseVibe = analysisResult.vibes[(i - 1) % analysisResult.vibes.length];
                const style = variationStyles[(i - 1) % variationStyles.length];
                
                // Create loading card immediately
                updateCardLoading(i, `Creating ${style} variation...`);
                
                // Enhanced prompt combining base analysis with style
                const variationPrompt = `${baseVibe}, rendered as ${style}, high quality, detailed`;
                const promise = generateSingleCardImage(variationPrompt, i);
                promises.push(promise);
                
                // Ultra-fast flow
                await animatedDelay(10);
            }
            
            console.log('✨ All 18 text-only variations spawning in parallel!');
        }

        // Convert image URL to base64 using proxy method
        async function urlToBase64(url) {
            console.log('🔄 Converting URL to base64:', url);
            
            return new Promise((resolve, reject) => {
                // First try fetch method (works better with CORS)
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        console.log('📦 Got blob, size:', blob.size);
                        const reader = new FileReader();
                        reader.onload = function() {
                            const base64 = this.result.split(',')[1];
                            console.log('✅ Converted to base64, length:', base64.length);
                            resolve(base64);
                        };
                        reader.onerror = () => {
                            console.error('❌ FileReader error');
                            reject(new Error('FileReader failed'));
                        };
                        reader.readAsDataURL(blob);
                    })
                    .catch(fetchError => {
                        console.log('⚠️ Fetch failed, trying canvas method:', fetchError.message);
                        
                        // Fallback to canvas method
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        
                        img.onload = function() {
                            try {
                                console.log('🎨 Using canvas method, image size:', this.naturalWidth, 'x', this.naturalHeight);
                                
                                // Create canvas
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                
                                // Set canvas size to image size
                                canvas.width = this.naturalWidth;
                                canvas.height = this.naturalHeight;
                                
                                // Draw image to canvas
                                ctx.drawImage(this, 0, 0);
                                
                                // Convert to base64
                                const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                                const base64 = dataURL.split(',')[1];
                                
                                console.log('✅ Canvas conversion successful, length:', base64.length);
                                resolve(base64);
                            } catch (canvasError) {
                                console.error('❌ Canvas conversion failed:', canvasError);
                                reject(canvasError);
                            }
                        };
                        
                        img.onerror = (imgError) => {
                            console.error('❌ Image load failed:', imgError);
                            reject(new Error('Image load failed'));
                        };
                        
                        // Try to load the image
                        img.src = url;
                    });
            });
        }

        // Use generated image as input for next generation
        async function useAsInput(imageUrl, title, promptId) {
            console.log('🔄 Using generated image as new input:', title);
            
            try {
                // Show loading state immediately
                const uploadContainer = document.getElementById('uploadZone') || document.querySelector('.upload-box .element-content');
                if (uploadContainer) {
                    uploadContainer.classList.add('upload-loading');
                }
                
                // Clear previous session state immediately for better UX
                sessionResults = [];
                totalKonceptRows = 3;
                customKonceptCount = 0;
                
                // Create new session
                if (isSharedSession) {
                    isSharedSession = false;
                    currentSessionId = generateSessionId();
                    window.history.pushState({}, '', `/session/${currentSessionId}`);
                    console.log('🔄 New session created for image switch:', currentSessionId);
                }
                
                // Clear existing results immediately for responsiveness
                const rightSection = document.getElementById('rightSection');
                if (rightSection) {
                    const resultElements = rightSection.querySelectorAll('.canvas-element:not(.upload-box)');
                    resultElements.forEach(element => element.remove());
                }
                
                // Clear caption container
                const captionContainer = document.querySelector('.caption-container');
                if (captionContainer) {
                    captionContainer.innerHTML = '';
                }
                
                // Remove share button
                const shareButton = document.getElementById('shareButton');
                if (shareButton) {
                    shareButton.remove();
                }
                
                // Use server endpoint to handle image storage and conversion
                console.log('📤 Requesting server to store and convert generated image...');
                try {
                    const response = await fetch('/api/store-generated-image', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            imageUrl: imageUrl,
                            title: title,
                            sessionId: currentSessionId
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    currentImageBase64 = result.base64;
                    const localImageUrl = result.localUrl; // Use this for display instead of external URL
                    
                    console.log('✅ Image stored and converted successfully, length:', currentImageBase64.length);
                    
                    // Update imageUrl to use local stored version
                    imageUrl = localImageUrl;
                    
                } catch (conversionError) {
                    console.error('❌ Server conversion failed:', conversionError);
                    
                    // Fallback: try client-side conversion (will likely fail due to CORS but worth trying)
                    try {
                        console.log('🔄 Attempting client-side fallback conversion...');
                        currentImageBase64 = await urlToBase64(imageUrl);
                        console.log('✅ Fallback conversion successful');
                    } catch (fallbackError) {
                        console.error('❌ Fallback conversion also failed:', fallbackError);
                        throw new Error('Unable to convert image - server storage required');
                    }
                }
                
                // Update upload container with new image immediately
                if (uploadContainer) {
                    uploadContainer.innerHTML = '';
                    
                    // Create image preview using the original URL
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.className = 'image-preview';
                    img.style.cursor = 'zoom-in';
                    img.onclick = (e) => {
                        e.stopPropagation();
                        const newPromptId = storePrompt(`${title} (used as input)`);
                        openImageModal(imageUrl, title, newPromptId);
                    };
                    
                    // Create image container
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'image-container';
                    imageContainer.appendChild(img);
                    
                    // Create generate button (will auto-trigger)
                    const startButton = document.createElement('button');
                    startButton.className = 'start-button generating';
                    startButton.innerHTML = 'Generating...';
                    startButton.disabled = true;
                    
                    // Create change button
                    const changeButton = document.createElement('button');
                    changeButton.className = 'change-button';
                    changeButton.innerHTML = '🔄 Change Image';
                    changeButton.onclick = (e) => {
                        e.stopPropagation();
                        const fileInput = document.getElementById('fileInput');
                        fileInput.click();
                    };
                    
                    // Add elements
                    uploadContainer.appendChild(imageContainer);
                    uploadContainer.appendChild(startButton);
                    uploadContainer.appendChild(changeButton);
                    
                    // Remove loading state and add success
                    uploadContainer.classList.remove('upload-loading');
                    uploadContainer.classList.add('upload-success');
                    
                    // Remove success indicator after a moment
                    setTimeout(() => {
                        uploadContainer.classList.remove('upload-success');
                    }, 1000);
                }
                
                // Automatically start generation after a brief delay
                console.log('🚀 Auto-starting generation with looped input...');
                console.log('📊 Using base64 data length:', currentImageBase64?.length || 'undefined');
                
                setTimeout(() => {
                    // Get number of images to generate
                    const numImagesInput = document.getElementById('numImagesInput');
                    const numImages = Math.max(1, Math.min(parseInt(numImagesInput?.value) || 18, 48));
                    console.log('🎯 Auto-generating', numImages, 'images from looped input...');
                    
                    // Hide the generate button and start
                    const startButton = uploadContainer?.querySelector('.start-button');
                    if (startButton) {
                        startButton.style.display = 'none';
                    }
                    
                    // Start the generation sequence
                    autoplaySequence(numImages);
                }, 800); // Brief delay to show the image loaded
                
                console.log('✅ Successfully switched to generated image as input');
                
                // Add this iteration to seed history
                addToSeedHistory(imageUrl, title);
                
            } catch (error) {
                console.error('❌ Error using image as input:', error);
                
                // Remove loading state on error
                const uploadContainer = document.getElementById('uploadZone') || document.querySelector('.upload-box .element-content');
                if (uploadContainer) {
                    uploadContainer.classList.remove('upload-loading');
                }
                
                // Show user-friendly error message
                alert('Unable to use this image as input. This may be due to browser security restrictions.');
            }
        }

        // High-velocity keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ignore if typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch(e.key.toLowerCase()) {
                case 'r':
                    e.preventDefault();
                    // Regenerate all images
                    const autoplayBtn = document.querySelector('button[onclick*="autoplaySequence"]');
                    if (autoplayBtn) autoplayBtn.click();
                    break;
                case 'v':
                    e.preventDefault();
                    // Spawn variations using original image
                    console.log('🎨 Spawning 18 text-only variations...');
                    spawnTextOnlyVariations();
                    break;
                case 'c':
                    e.preventDefault();
                    // Clear all images
                    const rightSection = document.querySelector('.right-section');
                    if (rightSection) rightSection.innerHTML = '';
                    break;
                case ' ':
                    e.preventDefault();
                    // Spacebar to regenerate
                    const autoplayBtn2 = document.querySelector('button[onclick*="autoplaySequence"]');
                    if (autoplayBtn2) autoplayBtn2.click();
                    break;
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initWhiteboard);

        // Add persistent number of images input to left-section after upload box
        document.addEventListener('DOMContentLoaded', function() {
            const leftSection = document.querySelector('.left-section');
            if (leftSection && !document.getElementById('numImagesContainer')) {
                const numImagesContainer = document.createElement('div');
                numImagesContainer.id = 'numImagesContainer';
                numImagesContainer.style.display = 'flex';
                numImagesContainer.style.flexDirection = 'column';
                numImagesContainer.style.alignItems = 'center';
                numImagesContainer.style.justifyContent = 'center';
                numImagesContainer.style.margin = '0 0 10px 0';
                numImagesContainer.style.padding = '8px 0 4px 0';
                numImagesContainer.style.background = 'transparent';
                numImagesContainer.style.borderRadius = '8px';
                numImagesContainer.style.boxShadow = 'none';

                const numImagesLabel = document.createElement('label');
                numImagesLabel.textContent = 'Number of Images';
                numImagesLabel.setAttribute('for', 'numImagesInput');
                numImagesLabel.style.fontSize = '13px';
                numImagesLabel.style.fontWeight = '500';
                numImagesLabel.style.marginBottom = '4px';
                numImagesLabel.style.letterSpacing = '0.2px';
                numImagesLabel.style.color = '#1c1c1e';
                numImagesLabel.style.textAlign = 'center';

                const numImagesInput = document.createElement('input');
                numImagesInput.type = 'number';
                numImagesInput.id = 'numImagesInput';
                numImagesInput.value = 18;
                numImagesInput.min = 1;
                numImagesInput.max = 48;
                numImagesInput.style.width = '60px';
                numImagesInput.style.fontSize = '15px';
                numImagesInput.style.textAlign = 'center';
                numImagesInput.style.padding = '4px 8px';
                numImagesInput.style.borderRadius = '5px';
                numImagesInput.style.border = '1px solid #bbb';
                numImagesInput.style.background = '#fff';
                numImagesInput.style.boxShadow = '0 1px 2px rgba(0,0,0,0.01)';
                numImagesInput.style.marginBottom = '0';

                numImagesContainer.appendChild(numImagesLabel);
                numImagesContainer.appendChild(numImagesInput);

                // Insert under the START HERE header, above the upload zone
                const uploadBox = document.querySelector('.upload-box');
                if (uploadBox) {
                    const header = uploadBox.querySelector('.element-header');
                    if (header && header.nextSibling) {
                        uploadBox.insertBefore(numImagesContainer, header.nextSibling);
                    } else {
                        uploadBox.appendChild(numImagesContainer);
                    }
                } else {
                    leftSection.appendChild(numImagesContainer);
                }
            }
        });
    </script>
    <!-- Comic Strip Modal -->
    <div id="comicStripModal" class="comic-strip-modal">
        <div class="comic-strip-content">
            <button class="comic-close-btn" onclick="closeComicStripModal()">×</button>
            
            <div class="comic-strip-header">
                <h2>Iterative Transformation Sequence</h2>
                <p>A visual documentation of the progressive image development process</p>
            </div>
            
            <div class="comic-strip-sequence" id="comicStripSequence">
                <!-- Comic panels will be generated here -->
            </div>
            
            <div class="comic-strip-controls">
                <button class="comic-control-btn" onclick="downloadComicStrip()">
                    Export Sequence
                </button>
                <button class="comic-control-btn secondary" onclick="closeComicStripModal()">
                    Close
                </button>
            </div>
        </div>
    </div>

</body>
</html>